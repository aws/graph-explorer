import {
  require_react
} from "./chunk-57SFASAQ.js";
import {
  __esm,
  __export,
  __toCommonJS,
  __toESM
} from "./chunk-S5KM4IGW.js";

// ../../node_modules/.pnpm/@emotion+memoize@0.7.4/node_modules/@emotion/memoize/dist/memoize.browser.esm.js
function memoize(fn) {
  var cache = {};
  return function(arg) {
    if (cache[arg] === void 0)
      cache[arg] = fn(arg);
    return cache[arg];
  };
}
var memoize_browser_esm_default;
var init_memoize_browser_esm = __esm({
  "../../node_modules/.pnpm/@emotion+memoize@0.7.4/node_modules/@emotion/memoize/dist/memoize.browser.esm.js"() {
    memoize_browser_esm_default = memoize;
  }
});

// ../../node_modules/.pnpm/@emotion+is-prop-valid@0.8.8/node_modules/@emotion/is-prop-valid/dist/is-prop-valid.browser.esm.js
var is_prop_valid_browser_esm_exports = {};
__export(is_prop_valid_browser_esm_exports, {
  default: () => is_prop_valid_browser_esm_default
});
var reactPropsRegex, index, is_prop_valid_browser_esm_default;
var init_is_prop_valid_browser_esm = __esm({
  "../../node_modules/.pnpm/@emotion+is-prop-valid@0.8.8/node_modules/@emotion/is-prop-valid/dist/is-prop-valid.browser.esm.js"() {
    init_memoize_browser_esm();
    reactPropsRegex = /^((children|dangerouslySetInnerHTML|key|ref|autoFocus|defaultValue|defaultChecked|innerHTML|suppressContentEditableWarning|suppressHydrationWarning|valueLink|accept|acceptCharset|accessKey|action|allow|allowUserMedia|allowPaymentRequest|allowFullScreen|allowTransparency|alt|async|autoComplete|autoPlay|capture|cellPadding|cellSpacing|challenge|charSet|checked|cite|classID|className|cols|colSpan|content|contentEditable|contextMenu|controls|controlsList|coords|crossOrigin|data|dateTime|decoding|default|defer|dir|disabled|disablePictureInPicture|download|draggable|encType|form|formAction|formEncType|formMethod|formNoValidate|formTarget|frameBorder|headers|height|hidden|high|href|hrefLang|htmlFor|httpEquiv|id|inputMode|integrity|is|keyParams|keyType|kind|label|lang|list|loading|loop|low|marginHeight|marginWidth|max|maxLength|media|mediaGroup|method|min|minLength|multiple|muted|name|nonce|noValidate|open|optimum|pattern|placeholder|playsInline|poster|preload|profile|radioGroup|readOnly|referrerPolicy|rel|required|reversed|role|rows|rowSpan|sandbox|scope|scoped|scrolling|seamless|selected|shape|size|sizes|slot|span|spellCheck|src|srcDoc|srcLang|srcSet|start|step|style|summary|tabIndex|target|title|type|useMap|value|width|wmode|wrap|about|datatype|inlist|prefix|property|resource|typeof|vocab|autoCapitalize|autoCorrect|autoSave|color|inert|itemProp|itemScope|itemType|itemID|itemRef|on|results|security|unselectable|accentHeight|accumulate|additive|alignmentBaseline|allowReorder|alphabetic|amplitude|arabicForm|ascent|attributeName|attributeType|autoReverse|azimuth|baseFrequency|baselineShift|baseProfile|bbox|begin|bias|by|calcMode|capHeight|clip|clipPathUnits|clipPath|clipRule|colorInterpolation|colorInterpolationFilters|colorProfile|colorRendering|contentScriptType|contentStyleType|cursor|cx|cy|d|decelerate|descent|diffuseConstant|direction|display|divisor|dominantBaseline|dur|dx|dy|edgeMode|elevation|enableBackground|end|exponent|externalResourcesRequired|fill|fillOpacity|fillRule|filter|filterRes|filterUnits|floodColor|floodOpacity|focusable|fontFamily|fontSize|fontSizeAdjust|fontStretch|fontStyle|fontVariant|fontWeight|format|from|fr|fx|fy|g1|g2|glyphName|glyphOrientationHorizontal|glyphOrientationVertical|glyphRef|gradientTransform|gradientUnits|hanging|horizAdvX|horizOriginX|ideographic|imageRendering|in|in2|intercept|k|k1|k2|k3|k4|kernelMatrix|kernelUnitLength|kerning|keyPoints|keySplines|keyTimes|lengthAdjust|letterSpacing|lightingColor|limitingConeAngle|local|markerEnd|markerMid|markerStart|markerHeight|markerUnits|markerWidth|mask|maskContentUnits|maskUnits|mathematical|mode|numOctaves|offset|opacity|operator|order|orient|orientation|origin|overflow|overlinePosition|overlineThickness|panose1|paintOrder|pathLength|patternContentUnits|patternTransform|patternUnits|pointerEvents|points|pointsAtX|pointsAtY|pointsAtZ|preserveAlpha|preserveAspectRatio|primitiveUnits|r|radius|refX|refY|renderingIntent|repeatCount|repeatDur|requiredExtensions|requiredFeatures|restart|result|rotate|rx|ry|scale|seed|shapeRendering|slope|spacing|specularConstant|specularExponent|speed|spreadMethod|startOffset|stdDeviation|stemh|stemv|stitchTiles|stopColor|stopOpacity|strikethroughPosition|strikethroughThickness|string|stroke|strokeDasharray|strokeDashoffset|strokeLinecap|strokeLinejoin|strokeMiterlimit|strokeOpacity|strokeWidth|surfaceScale|systemLanguage|tableValues|targetX|targetY|textAnchor|textDecoration|textRendering|textLength|to|transform|u1|u2|underlinePosition|underlineThickness|unicode|unicodeBidi|unicodeRange|unitsPerEm|vAlphabetic|vHanging|vIdeographic|vMathematical|values|vectorEffect|version|vertAdvY|vertOriginX|vertOriginY|viewBox|viewTarget|visibility|widths|wordSpacing|writingMode|x|xHeight|x1|x2|xChannelSelector|xlinkActuate|xlinkArcrole|xlinkHref|xlinkRole|xlinkShow|xlinkTitle|xlinkType|xmlBase|xmlns|xmlnsXlink|xmlLang|xmlSpace|y|y1|y2|yChannelSelector|z|zoomAndPan|for|class|autofocus)|(([Dd][Aa][Tt][Aa]|[Aa][Rr][Ii][Aa]|x)-.*))$/;
    index = memoize_browser_esm_default(
      function(prop) {
        return reactPropsRegex.test(prop) || prop.charCodeAt(0) === 111 && prop.charCodeAt(1) === 110 && prop.charCodeAt(2) < 91;
      }
    );
    is_prop_valid_browser_esm_default = index;
  }
});

// ../../node_modules/.pnpm/tslib@1.14.1/node_modules/tslib/tslib.es6.js
var extendStatics = function(d, b2) {
  extendStatics = Object.setPrototypeOf || { __proto__: [] } instanceof Array && function(d2, b3) {
    d2.__proto__ = b3;
  } || function(d2, b3) {
    for (var p in b3)
      if (b3.hasOwnProperty(p))
        d2[p] = b3[p];
  };
  return extendStatics(d, b2);
};
function __extends(d, b2) {
  extendStatics(d, b2);
  function __() {
    this.constructor = d;
  }
  d.prototype = b2 === null ? Object.create(b2) : (__.prototype = b2.prototype, new __());
}
var __assign = function() {
  __assign = Object.assign || function __assign2(t) {
    for (var s, i = 1, n = arguments.length; i < n; i++) {
      s = arguments[i];
      for (var p in s)
        if (Object.prototype.hasOwnProperty.call(s, p))
          t[p] = s[p];
    }
    return t;
  };
  return __assign.apply(this, arguments);
};
function __rest(s, e) {
  var t = {};
  for (var p in s)
    if (Object.prototype.hasOwnProperty.call(s, p) && e.indexOf(p) < 0)
      t[p] = s[p];
  if (s != null && typeof Object.getOwnPropertySymbols === "function")
    for (var i = 0, p = Object.getOwnPropertySymbols(s); i < p.length; i++) {
      if (e.indexOf(p[i]) < 0 && Object.prototype.propertyIsEnumerable.call(s, p[i]))
        t[p[i]] = s[p[i]];
    }
  return t;
}
function __values(o) {
  var s = typeof Symbol === "function" && Symbol.iterator, m2 = s && o[s], i = 0;
  if (m2)
    return m2.call(o);
  if (o && typeof o.length === "number")
    return {
      next: function() {
        if (o && i >= o.length)
          o = void 0;
        return { value: o && o[i++], done: !o };
      }
    };
  throw new TypeError(s ? "Object is not iterable." : "Symbol.iterator is not defined.");
}
function __read(o, n) {
  var m2 = typeof Symbol === "function" && o[Symbol.iterator];
  if (!m2)
    return o;
  var i = m2.call(o), r, ar = [], e;
  try {
    while ((n === void 0 || n-- > 0) && !(r = i.next()).done)
      ar.push(r.value);
  } catch (error) {
    e = { error };
  } finally {
    try {
      if (r && !r.done && (m2 = i["return"]))
        m2.call(i);
    } finally {
      if (e)
        throw e.error;
    }
  }
  return ar;
}
function __spread() {
  for (var ar = [], i = 0; i < arguments.length; i++)
    ar = ar.concat(__read(arguments[i]));
  return ar;
}
function __spreadArrays() {
  for (var s = 0, i = 0, il = arguments.length; i < il; i++)
    s += arguments[i].length;
  for (var r = Array(s), k = 0, i = 0; i < il; i++)
    for (var a2 = arguments[i], j = 0, jl = a2.length; j < jl; j++, k++)
      r[k] = a2[j];
  return r;
}

// ../../node_modules/.pnpm/hey-listen@1.0.8/node_modules/hey-listen/dist/hey-listen.es.js
var warning = function() {
};
var invariant = function() {
};
if (true) {
  warning = function(check, message) {
    if (!check && typeof console !== "undefined") {
      console.warn(message);
    }
  };
  invariant = function(check, message) {
    if (!check) {
      throw new Error(message);
    }
  };
}

// ../../node_modules/.pnpm/framesync@4.1.0/node_modules/framesync/dist/framesync.es.js
var prevTime = 0;
var onNextFrame = typeof window !== "undefined" && window.requestAnimationFrame !== void 0 ? function(callback) {
  return window.requestAnimationFrame(callback);
} : function(callback) {
  var timestamp = Date.now();
  var timeToCall = Math.max(0, 16.7 - (timestamp - prevTime));
  prevTime = timestamp + timeToCall;
  setTimeout(function() {
    return callback(prevTime);
  }, timeToCall);
};
var createStep = function(setRunNextFrame) {
  var processToRun = [];
  var processToRunNextFrame = [];
  var numThisFrame = 0;
  var isProcessing2 = false;
  var i = 0;
  var cancelled = /* @__PURE__ */ new WeakSet();
  var toKeepAlive = /* @__PURE__ */ new WeakSet();
  var renderStep = {
    cancel: function(process2) {
      var indexOfCallback = processToRunNextFrame.indexOf(process2);
      cancelled.add(process2);
      if (indexOfCallback !== -1) {
        processToRunNextFrame.splice(indexOfCallback, 1);
      }
    },
    process: function(frame2) {
      var _a;
      isProcessing2 = true;
      _a = [processToRunNextFrame, processToRun], processToRun = _a[0], processToRunNextFrame = _a[1];
      processToRunNextFrame.length = 0;
      numThisFrame = processToRun.length;
      if (numThisFrame) {
        var process_1;
        for (i = 0; i < numThisFrame; i++) {
          process_1 = processToRun[i];
          process_1(frame2);
          if (toKeepAlive.has(process_1) === true && !cancelled.has(process_1)) {
            renderStep.schedule(process_1);
            setRunNextFrame(true);
          }
        }
      }
      isProcessing2 = false;
    },
    schedule: function(process2, keepAlive, immediate) {
      if (keepAlive === void 0) {
        keepAlive = false;
      }
      if (immediate === void 0) {
        immediate = false;
      }
      invariant(typeof process2 === "function", "Argument must be a function");
      var addToCurrentBuffer = immediate && isProcessing2;
      var buffer = addToCurrentBuffer ? processToRun : processToRunNextFrame;
      cancelled.delete(process2);
      if (keepAlive)
        toKeepAlive.add(process2);
      if (buffer.indexOf(process2) === -1) {
        buffer.push(process2);
        if (addToCurrentBuffer)
          numThisFrame = processToRun.length;
      }
    }
  };
  return renderStep;
};
var maxElapsed = 40;
var defaultElapsed = 1 / 60 * 1e3;
var useDefaultElapsed = true;
var willRunNextFrame = false;
var isProcessing = false;
var frame = {
  delta: 0,
  timestamp: 0
};
var stepsOrder = ["read", "update", "preRender", "render", "postRender"];
var setWillRunNextFrame = function(willRun) {
  return willRunNextFrame = willRun;
};
var steps = stepsOrder.reduce(function(acc, key) {
  acc[key] = createStep(setWillRunNextFrame);
  return acc;
}, {});
var sync = stepsOrder.reduce(function(acc, key) {
  var step = steps[key];
  acc[key] = function(process2, keepAlive, immediate) {
    if (keepAlive === void 0) {
      keepAlive = false;
    }
    if (immediate === void 0) {
      immediate = false;
    }
    if (!willRunNextFrame)
      startLoop();
    step.schedule(process2, keepAlive, immediate);
    return process2;
  };
  return acc;
}, {});
var cancelSync = stepsOrder.reduce(function(acc, key) {
  acc[key] = steps[key].cancel;
  return acc;
}, {});
var processStep = function(stepId) {
  return steps[stepId].process(frame);
};
var processFrame = function(timestamp) {
  willRunNextFrame = false;
  frame.delta = useDefaultElapsed ? defaultElapsed : Math.max(Math.min(timestamp - frame.timestamp, maxElapsed), 1);
  if (!useDefaultElapsed)
    defaultElapsed = frame.delta;
  frame.timestamp = timestamp;
  isProcessing = true;
  stepsOrder.forEach(processStep);
  isProcessing = false;
  if (willRunNextFrame) {
    useDefaultElapsed = false;
    onNextFrame(processFrame);
  }
};
var startLoop = function() {
  willRunNextFrame = true;
  useDefaultElapsed = true;
  if (!isProcessing)
    onNextFrame(processFrame);
};
var getFrameData = function() {
  return frame;
};
var framesync_es_default = sync;

// ../../node_modules/.pnpm/style-value-types@3.2.0/node_modules/style-value-types/dist/style-value-types.es.js
var clamp = function(min, max) {
  return function(v) {
    return Math.max(Math.min(v, max), min);
  };
};
var sanitize = function(v) {
  return v % 1 ? Number(v.toFixed(5)) : v;
};
var floatRegex = /(-)?(\d[\d\.]*)/g;
var colorRegex = /(#[0-9a-f]{6}|#[0-9a-f]{3}|#(?:[0-9a-f]{2}){2,4}|(rgb|hsl)a?\((-?[\d\.]+%?[,\s]+){2,3}\s*\/*\s*[\d\.]+%?\))/gi;
var singleColorRegex = /^(#[0-9a-f]{3}|#(?:[0-9a-f]{2}){2,4}|(rgb|hsl)a?\((-?[\d\.]+%?[,\s]+){2,3}\s*\/*\s*[\d\.]+%?\))$/i;
var number = {
  test: function(v) {
    return typeof v === "number";
  },
  parse: parseFloat,
  transform: function(v) {
    return v;
  }
};
var alpha = __assign(__assign({}, number), { transform: clamp(0, 1) });
var scale = __assign(__assign({}, number), { default: 1 });
var createUnitType = function(unit) {
  return {
    test: function(v) {
      return typeof v === "string" && v.endsWith(unit) && v.split(" ").length === 1;
    },
    parse: parseFloat,
    transform: function(v) {
      return "" + v + unit;
    }
  };
};
var degrees = createUnitType("deg");
var percent = createUnitType("%");
var px = createUnitType("px");
var vh = createUnitType("vh");
var vw = createUnitType("vw");
var progressPercentage = __assign(__assign({}, percent), { parse: function(v) {
  return percent.parse(v) / 100;
}, transform: function(v) {
  return percent.transform(v * 100);
} });
var getValueFromFunctionString = function(value) {
  return value.substring(value.indexOf("(") + 1, value.lastIndexOf(")"));
};
var clampRgbUnit = clamp(0, 255);
var isRgba = function(v) {
  return v.red !== void 0;
};
var isHsla = function(v) {
  return v.hue !== void 0;
};
function getValuesAsArray(value) {
  return getValueFromFunctionString(value).replace(/(,|\/)/g, " ").split(/ \s*/);
}
var splitColorValues = function(terms) {
  return function(v) {
    if (typeof v !== "string")
      return v;
    var values = {};
    var valuesArray = getValuesAsArray(v);
    for (var i = 0; i < 4; i++) {
      values[terms[i]] = valuesArray[i] !== void 0 ? parseFloat(valuesArray[i]) : 1;
    }
    return values;
  };
};
var rgbaTemplate = function(_a) {
  var red = _a.red, green = _a.green, blue = _a.blue, _b = _a.alpha, alpha2 = _b === void 0 ? 1 : _b;
  return "rgba(" + red + ", " + green + ", " + blue + ", " + alpha2 + ")";
};
var hslaTemplate = function(_a) {
  var hue = _a.hue, saturation = _a.saturation, lightness = _a.lightness, _b = _a.alpha, alpha2 = _b === void 0 ? 1 : _b;
  return "hsla(" + hue + ", " + saturation + ", " + lightness + ", " + alpha2 + ")";
};
var rgbUnit = __assign(__assign({}, number), { transform: function(v) {
  return Math.round(clampRgbUnit(v));
} });
function isColorString(color2, colorType) {
  return color2.startsWith(colorType) && singleColorRegex.test(color2);
}
var rgba = {
  test: function(v) {
    return typeof v === "string" ? isColorString(v, "rgb") : isRgba(v);
  },
  parse: splitColorValues(["red", "green", "blue", "alpha"]),
  transform: function(_a) {
    var red = _a.red, green = _a.green, blue = _a.blue, _b = _a.alpha, alpha$1 = _b === void 0 ? 1 : _b;
    return rgbaTemplate({
      red: rgbUnit.transform(red),
      green: rgbUnit.transform(green),
      blue: rgbUnit.transform(blue),
      alpha: sanitize(alpha.transform(alpha$1))
    });
  }
};
var hsla = {
  test: function(v) {
    return typeof v === "string" ? isColorString(v, "hsl") : isHsla(v);
  },
  parse: splitColorValues(["hue", "saturation", "lightness", "alpha"]),
  transform: function(_a) {
    var hue = _a.hue, saturation = _a.saturation, lightness = _a.lightness, _b = _a.alpha, alpha$1 = _b === void 0 ? 1 : _b;
    return hslaTemplate({
      hue: Math.round(hue),
      saturation: percent.transform(sanitize(saturation)),
      lightness: percent.transform(sanitize(lightness)),
      alpha: sanitize(alpha.transform(alpha$1))
    });
  }
};
var hex = __assign(__assign({}, rgba), { test: function(v) {
  return typeof v === "string" && isColorString(v, "#");
}, parse: function(v) {
  var r = "";
  var g = "";
  var b2 = "";
  if (v.length > 4) {
    r = v.substr(1, 2);
    g = v.substr(3, 2);
    b2 = v.substr(5, 2);
  } else {
    r = v.substr(1, 1);
    g = v.substr(2, 1);
    b2 = v.substr(3, 1);
    r += r;
    g += g;
    b2 += b2;
  }
  return {
    red: parseInt(r, 16),
    green: parseInt(g, 16),
    blue: parseInt(b2, 16),
    alpha: 1
  };
} });
var color = {
  test: function(v) {
    return typeof v === "string" && singleColorRegex.test(v) || isRgba(v) || isHsla(v);
  },
  parse: function(v) {
    if (rgba.test(v)) {
      return rgba.parse(v);
    } else if (hsla.test(v)) {
      return hsla.parse(v);
    } else if (hex.test(v)) {
      return hex.parse(v);
    }
    return v;
  },
  transform: function(v) {
    if (isRgba(v)) {
      return rgba.transform(v);
    } else if (isHsla(v)) {
      return hsla.transform(v);
    }
    return v;
  }
};
var COLOR_TOKEN = "${c}";
var NUMBER_TOKEN = "${n}";
var convertNumbersToZero = function(v) {
  return typeof v === "number" ? 0 : v;
};
var complex = {
  test: function(v) {
    if (typeof v !== "string" || !isNaN(v))
      return false;
    var numValues = 0;
    var foundNumbers = v.match(floatRegex);
    var foundColors = v.match(colorRegex);
    if (foundNumbers)
      numValues += foundNumbers.length;
    if (foundColors)
      numValues += foundColors.length;
    return numValues > 0;
  },
  parse: function(v) {
    var input = v;
    var parsed = [];
    var foundColors = input.match(colorRegex);
    if (foundColors) {
      input = input.replace(colorRegex, COLOR_TOKEN);
      parsed.push.apply(parsed, foundColors.map(color.parse));
    }
    var foundNumbers = input.match(floatRegex);
    if (foundNumbers) {
      parsed.push.apply(parsed, foundNumbers.map(number.parse));
    }
    return parsed;
  },
  createTransformer: function(prop) {
    var template = prop;
    var token = 0;
    var foundColors = prop.match(colorRegex);
    var numColors = foundColors ? foundColors.length : 0;
    if (foundColors) {
      for (var i = 0; i < numColors; i++) {
        template = template.replace(foundColors[i], COLOR_TOKEN);
        token++;
      }
    }
    var foundNumbers = template.match(floatRegex);
    var numNumbers = foundNumbers ? foundNumbers.length : 0;
    if (foundNumbers) {
      for (var i = 0; i < numNumbers; i++) {
        template = template.replace(foundNumbers[i], NUMBER_TOKEN);
        token++;
      }
    }
    return function(v) {
      var output = template;
      for (var i2 = 0; i2 < token; i2++) {
        output = output.replace(i2 < numColors ? COLOR_TOKEN : NUMBER_TOKEN, i2 < numColors ? color.transform(v[i2]) : sanitize(v[i2]));
      }
      return output;
    };
  },
  getAnimatableNone: function(target2) {
    var parsedTarget = complex.parse(target2);
    var targetTransformer = complex.createTransformer(target2);
    return targetTransformer(parsedTarget.map(convertNumbersToZero));
  }
};

// ../../node_modules/.pnpm/popmotion@9.0.0-rc.20/node_modules/popmotion/dist/popmotion.es.js
var clamp2 = function(min, max, v) {
  return Math.min(Math.max(v, min), max);
};
var safeMin = 1e-3;
var minDuration = 0.01;
var maxDuration = 10;
var minDamping = 0.05;
var maxDamping = 1;
function findSpring(_a) {
  var _b = _a.duration, duration = _b === void 0 ? 800 : _b, _c = _a.bounce, bounce = _c === void 0 ? 0.25 : _c, _d = _a.velocity, velocity = _d === void 0 ? 0 : _d, _e = _a.mass, mass = _e === void 0 ? 1 : _e;
  var envelope;
  var derivative;
  warning(duration <= maxDuration * 1e3, "Spring duration must be 10 seconds or less");
  var dampingRatio = 1 - bounce;
  dampingRatio = clamp2(minDamping, maxDamping, dampingRatio);
  duration = clamp2(minDuration, maxDuration, duration / 1e3);
  if (dampingRatio < 1) {
    envelope = function(undampedFreq2) {
      var exponentialDecay = undampedFreq2 * dampingRatio;
      var delta2 = exponentialDecay * duration;
      var a2 = exponentialDecay - velocity;
      var b2 = calcAngularFreq(undampedFreq2, dampingRatio);
      var c2 = Math.exp(-delta2);
      return safeMin - a2 / b2 * c2;
    };
    derivative = function(undampedFreq2) {
      var exponentialDecay = undampedFreq2 * dampingRatio;
      var delta2 = exponentialDecay * duration;
      var d = delta2 * velocity + velocity;
      var e = Math.pow(dampingRatio, 2) * Math.pow(undampedFreq2, 2) * duration;
      var f = Math.exp(-delta2);
      var g = calcAngularFreq(Math.pow(undampedFreq2, 2), dampingRatio);
      var factor = -envelope(undampedFreq2) + safeMin > 0 ? -1 : 1;
      return factor * ((d - e) * f) / g;
    };
  } else {
    envelope = function(undampedFreq2) {
      var a2 = Math.exp(-undampedFreq2 * duration);
      var b2 = (undampedFreq2 - velocity) * duration + 1;
      return -safeMin + a2 * b2;
    };
    derivative = function(undampedFreq2) {
      var a2 = Math.exp(-undampedFreq2 * duration);
      var b2 = (velocity - undampedFreq2) * (duration * duration);
      return a2 * b2;
    };
  }
  var initialGuess = 5 / duration;
  var undampedFreq = approximateRoot(envelope, derivative, initialGuess);
  if (isNaN(undampedFreq)) {
    return {
      stiffness: 100,
      damping: 10
    };
  } else {
    var stiffness = Math.pow(undampedFreq, 2) * mass;
    return {
      stiffness,
      damping: dampingRatio * 2 * Math.sqrt(mass * stiffness)
    };
  }
}
var rootIterations = 12;
function approximateRoot(envelope, derivative, initialGuess) {
  var result = initialGuess;
  for (var i = 1; i < rootIterations; i++) {
    result = result - envelope(result) / derivative(result);
  }
  return result;
}
function calcAngularFreq(undampedFreq, dampingRatio) {
  return undampedFreq * Math.sqrt(1 - dampingRatio * dampingRatio);
}
var durationKeys = ["duration", "bounce"];
var physicsKeys = ["stiffness", "damping", "mass"];
function isSpringType(options, keys) {
  return keys.some(function(key) {
    return options[key] !== void 0;
  });
}
function getSpringOptions(options) {
  var springOptions = __assign({ velocity: 0, stiffness: 100, damping: 10, mass: 1, isResolvedFromDuration: false }, options);
  if (!isSpringType(options, physicsKeys) && isSpringType(options, durationKeys)) {
    var derived = findSpring(options);
    springOptions = __assign(__assign(__assign({}, springOptions), derived), { velocity: 0, mass: 1 });
    springOptions.isResolvedFromDuration = true;
  }
  return springOptions;
}
function spring(_a) {
  var _b = _a.from, from = _b === void 0 ? 0 : _b, _c = _a.to, to = _c === void 0 ? 1 : _c, _d = _a.restSpeed, restSpeed = _d === void 0 ? 2 : _d, restDelta = _a.restDelta, options = __rest(_a, ["from", "to", "restSpeed", "restDelta"]);
  var state = { done: false, value: from };
  var _e = getSpringOptions(options), stiffness = _e.stiffness, damping = _e.damping, mass = _e.mass, velocity = _e.velocity, isResolvedFromDuration = _e.isResolvedFromDuration;
  var resolveSpring = zero;
  var resolveVelocity = zero;
  function createSpring() {
    var initialVelocity = velocity ? -(velocity / 1e3) : 0;
    var initialDelta = to - from;
    var dampingRatio = damping / (2 * Math.sqrt(stiffness * mass));
    var undampedAngularFreq = Math.sqrt(stiffness / mass) / 1e3;
    restDelta !== null && restDelta !== void 0 ? restDelta : restDelta = Math.abs(to - from) <= 1 ? 0.01 : 0.4;
    if (dampingRatio < 1) {
      var angularFreq_1 = calcAngularFreq(undampedAngularFreq, dampingRatio);
      resolveSpring = function(t) {
        var envelope = Math.exp(-dampingRatio * undampedAngularFreq * t);
        return to - envelope * ((initialVelocity + dampingRatio * undampedAngularFreq * initialDelta) / angularFreq_1 * Math.sin(angularFreq_1 * t) + initialDelta * Math.cos(angularFreq_1 * t));
      };
      resolveVelocity = function(t) {
        var envelope = Math.exp(-dampingRatio * undampedAngularFreq * t);
        return dampingRatio * undampedAngularFreq * envelope * (Math.sin(angularFreq_1 * t) * (initialVelocity + dampingRatio * undampedAngularFreq * initialDelta) / angularFreq_1 + initialDelta * Math.cos(angularFreq_1 * t)) - envelope * (Math.cos(angularFreq_1 * t) * (initialVelocity + dampingRatio * undampedAngularFreq * initialDelta) - angularFreq_1 * initialDelta * Math.sin(angularFreq_1 * t));
      };
    } else if (dampingRatio === 1) {
      resolveSpring = function(t) {
        return to - Math.exp(-undampedAngularFreq * t) * (initialDelta + (initialVelocity + undampedAngularFreq * initialDelta) * t);
      };
    } else {
      var dampedAngularFreq_1 = undampedAngularFreq * Math.sqrt(dampingRatio * dampingRatio - 1);
      resolveSpring = function(t) {
        var envelope = Math.exp(-dampingRatio * undampedAngularFreq * t);
        var freqForT = Math.min(dampedAngularFreq_1 * t, 300);
        return to - envelope * ((initialVelocity + dampingRatio * undampedAngularFreq * initialDelta) * Math.sinh(freqForT) + dampedAngularFreq_1 * initialDelta * Math.cosh(freqForT)) / dampedAngularFreq_1;
      };
    }
  }
  createSpring();
  return {
    next: function(t) {
      var current = resolveSpring(t);
      if (!isResolvedFromDuration) {
        var currentVelocity = resolveVelocity(t) * 1e3;
        var isBelowVelocityThreshold = Math.abs(currentVelocity) <= restSpeed;
        var isBelowDisplacementThreshold = Math.abs(to - current) <= restDelta;
        state.done = isBelowVelocityThreshold && isBelowDisplacementThreshold;
      } else {
        state.done = t >= options.duration;
      }
      state.value = state.done ? to : current;
      return state;
    },
    flipTarget: function() {
      var _a2;
      velocity = -velocity;
      _a2 = [to, from], from = _a2[0], to = _a2[1];
      createSpring();
    }
  };
}
spring.needsInterpolation = function(a2, b2) {
  return typeof a2 === "string" || typeof b2 === "string";
};
var zero = function(_t) {
  return 0;
};
var progress = function(from, to, value) {
  var toFromDifference = to - from;
  return toFromDifference === 0 ? 1 : (value - from) / toFromDifference;
};
var mix = function(from, to, progress2) {
  return -progress2 * from + progress2 * to + from;
};
var mixLinearColor = function(from, to, v) {
  var fromExpo = from * from;
  var toExpo = to * to;
  return Math.sqrt(Math.max(0, v * (toExpo - fromExpo) + fromExpo));
};
var colorTypes = [hex, rgba, hsla];
var getColorType = function(v) {
  return colorTypes.find(function(type) {
    return type.test(v);
  });
};
var notAnimatable = function(color2) {
  return "'" + color2 + "' is not an animatable color. Use the equivalent color code instead.";
};
var mixColor = function(from, to) {
  var fromColorType = getColorType(from);
  var toColorType = getColorType(to);
  invariant(!!fromColorType, notAnimatable(from));
  invariant(!!toColorType, notAnimatable(to));
  invariant(fromColorType.transform === toColorType.transform, "Both colors must be hex/RGBA, OR both must be HSLA.");
  var fromColor = fromColorType.parse(from);
  var toColor = toColorType.parse(to);
  var blended = __assign({}, fromColor);
  var mixFunc = fromColorType === hsla ? mix : mixLinearColor;
  return function(v) {
    for (var key in blended) {
      if (key !== "alpha") {
        blended[key] = mixFunc(fromColor[key], toColor[key], v);
      }
    }
    blended.alpha = mix(fromColor.alpha, toColor.alpha, v);
    return fromColorType.transform(blended);
  };
};
var isNum = function(v) {
  return typeof v === "number";
};
var combineFunctions = function(a2, b2) {
  return function(v) {
    return b2(a2(v));
  };
};
var pipe = function() {
  var transformers = [];
  for (var _i = 0; _i < arguments.length; _i++) {
    transformers[_i] = arguments[_i];
  }
  return transformers.reduce(combineFunctions);
};
function getMixer(origin, target2) {
  if (isNum(origin)) {
    return function(v) {
      return mix(origin, target2, v);
    };
  } else if (color.test(origin)) {
    return mixColor(origin, target2);
  } else {
    return mixComplex(origin, target2);
  }
}
var mixArray = function(from, to) {
  var output = __spreadArrays(from);
  var numValues = output.length;
  var blendValue = from.map(function(fromThis, i) {
    return getMixer(fromThis, to[i]);
  });
  return function(v) {
    for (var i = 0; i < numValues; i++) {
      output[i] = blendValue[i](v);
    }
    return output;
  };
};
var mixObject = function(origin, target2) {
  var output = __assign(__assign({}, origin), target2);
  var blendValue = {};
  for (var key in output) {
    if (origin[key] !== void 0 && target2[key] !== void 0) {
      blendValue[key] = getMixer(origin[key], target2[key]);
    }
  }
  return function(v) {
    for (var key2 in blendValue) {
      output[key2] = blendValue[key2](v);
    }
    return output;
  };
};
function analyse(value) {
  var parsed = complex.parse(value);
  var numValues = parsed.length;
  var numNumbers = 0;
  var numRGB = 0;
  var numHSL = 0;
  for (var i = 0; i < numValues; i++) {
    if (numNumbers || typeof parsed[i] === "number") {
      numNumbers++;
    } else {
      if (parsed[i].hue !== void 0) {
        numHSL++;
      } else {
        numRGB++;
      }
    }
  }
  return { parsed, numNumbers, numRGB, numHSL };
}
var mixComplex = function(origin, target2) {
  var template = complex.createTransformer(target2);
  var originStats = analyse(origin);
  var targetStats = analyse(target2);
  invariant(originStats.numHSL === targetStats.numHSL && originStats.numRGB === targetStats.numRGB && originStats.numNumbers >= targetStats.numNumbers, "Complex values '" + origin + "' and '" + target2 + "' too different to mix. Ensure all colors are of the same type.");
  return pipe(mixArray(originStats.parsed, targetStats.parsed), template);
};
var mixNumber = function(from, to) {
  return function(p) {
    return mix(from, to, p);
  };
};
function detectMixerFactory(v) {
  if (typeof v === "number") {
    return mixNumber;
  } else if (typeof v === "string") {
    if (color.test(v)) {
      return mixColor;
    } else {
      return mixComplex;
    }
  } else if (Array.isArray(v)) {
    return mixArray;
  } else if (typeof v === "object") {
    return mixObject;
  }
}
function createMixers(output, ease, customMixer) {
  var mixers = [];
  var mixerFactory = customMixer || detectMixerFactory(output[0]);
  var numMixers = output.length - 1;
  for (var i = 0; i < numMixers; i++) {
    var mixer = mixerFactory(output[i], output[i + 1]);
    if (ease) {
      var easingFunction = Array.isArray(ease) ? ease[i] : ease;
      mixer = pipe(easingFunction, mixer);
    }
    mixers.push(mixer);
  }
  return mixers;
}
function fastInterpolate(_a, _b) {
  var from = _a[0], to = _a[1];
  var mixer = _b[0];
  return function(v) {
    return mixer(progress(from, to, v));
  };
}
function slowInterpolate(input, mixers) {
  var inputLength = input.length;
  var lastInputIndex = inputLength - 1;
  return function(v) {
    var mixerIndex = 0;
    var foundMixerIndex = false;
    if (v <= input[0]) {
      foundMixerIndex = true;
    } else if (v >= input[lastInputIndex]) {
      mixerIndex = lastInputIndex - 1;
      foundMixerIndex = true;
    }
    if (!foundMixerIndex) {
      var i = 1;
      for (; i < inputLength; i++) {
        if (input[i] > v || i === lastInputIndex) {
          break;
        }
      }
      mixerIndex = i - 1;
    }
    var progressInRange = progress(input[mixerIndex], input[mixerIndex + 1], v);
    return mixers[mixerIndex](progressInRange);
  };
}
function interpolate(input, output, _a) {
  var _b = _a === void 0 ? {} : _a, _c = _b.clamp, isClamp = _c === void 0 ? true : _c, ease = _b.ease, mixer = _b.mixer;
  var inputLength = input.length;
  invariant(inputLength === output.length, "Both input and output ranges must be the same length");
  invariant(!ease || !Array.isArray(ease) || ease.length === inputLength - 1, "Array of easing functions must be of length `input.length - 1`, as it applies to the transitions **between** the defined values.");
  if (input[0] > input[inputLength - 1]) {
    input = [].concat(input);
    output = [].concat(output);
    input.reverse();
    output.reverse();
  }
  var mixers = createMixers(output, ease, mixer);
  var interpolator = inputLength === 2 ? fastInterpolate(input, mixers) : slowInterpolate(input, mixers);
  return isClamp ? function(v) {
    return interpolator(clamp2(input[0], input[inputLength - 1], v));
  } : interpolator;
}
var reverseEasing = function(easing) {
  return function(p) {
    return 1 - easing(1 - p);
  };
};
var mirrorEasing = function(easing) {
  return function(p) {
    return p <= 0.5 ? easing(2 * p) / 2 : (2 - easing(2 * (1 - p))) / 2;
  };
};
var createExpoIn = function(power) {
  return function(p) {
    return Math.pow(p, power);
  };
};
var createBackIn = function(power) {
  return function(p) {
    return p * p * ((power + 1) * p - power);
  };
};
var createAnticipate = function(power) {
  var backEasing = createBackIn(power);
  return function(p) {
    return (p *= 2) < 1 ? 0.5 * backEasing(p) : 0.5 * (2 - Math.pow(2, -10 * (p - 1)));
  };
};
var DEFAULT_OVERSHOOT_STRENGTH = 1.525;
var BOUNCE_FIRST_THRESHOLD = 4 / 11;
var BOUNCE_SECOND_THRESHOLD = 8 / 11;
var BOUNCE_THIRD_THRESHOLD = 9 / 10;
var linear = function(p) {
  return p;
};
var easeIn = createExpoIn(2);
var easeOut = reverseEasing(easeIn);
var easeInOut = mirrorEasing(easeIn);
var circIn = function(p) {
  return 1 - Math.sin(Math.acos(p));
};
var circOut = reverseEasing(circIn);
var circInOut = mirrorEasing(circOut);
var backIn = createBackIn(DEFAULT_OVERSHOOT_STRENGTH);
var backOut = reverseEasing(backIn);
var backInOut = mirrorEasing(backIn);
var anticipate = createAnticipate(DEFAULT_OVERSHOOT_STRENGTH);
var ca = 4356 / 361;
var cb = 35442 / 1805;
var cc = 16061 / 1805;
var bounceOut = function(p) {
  if (p === 1 || p === 0)
    return p;
  var p2 = p * p;
  return p < BOUNCE_FIRST_THRESHOLD ? 7.5625 * p2 : p < BOUNCE_SECOND_THRESHOLD ? 9.075 * p2 - 9.9 * p + 3.4 : p < BOUNCE_THIRD_THRESHOLD ? ca * p2 - cb * p + cc : 10.8 * p * p - 20.52 * p + 10.72;
};
var bounceIn = reverseEasing(bounceOut);
var bounceInOut = function(p) {
  return p < 0.5 ? 0.5 * (1 - bounceOut(1 - p * 2)) : 0.5 * bounceOut(p * 2 - 1) + 0.5;
};
function defaultEasing(values, easing) {
  return values.map(function() {
    return easing || easeInOut;
  }).splice(0, values.length - 1);
}
function defaultOffset(values) {
  var numValues = values.length;
  return values.map(function(_value, i) {
    return i !== 0 ? i / (numValues - 1) : 0;
  });
}
function convertOffsetToTimes(offset, duration) {
  return offset.map(function(o) {
    return o * duration;
  });
}
function keyframes(_a) {
  var _b = _a.from, from = _b === void 0 ? 0 : _b, _c = _a.to, to = _c === void 0 ? 1 : _c, ease = _a.ease, offset = _a.offset, _d = _a.duration, duration = _d === void 0 ? 300 : _d;
  var state = { done: false, value: from };
  var values = Array.isArray(to) ? to : [from, to];
  var times = convertOffsetToTimes(offset !== null && offset !== void 0 ? offset : defaultOffset(values), duration);
  function createInterpolator() {
    return interpolate(times, values, {
      ease: Array.isArray(ease) ? ease : defaultEasing(values, ease)
    });
  }
  var interpolator = createInterpolator();
  return {
    next: function(t) {
      state.value = interpolator(t);
      state.done = t >= duration;
      return state;
    },
    flipTarget: function() {
      values.reverse();
      interpolator = createInterpolator();
    }
  };
}
function decay(_a) {
  var _b = _a.velocity, velocity = _b === void 0 ? 0 : _b, _c = _a.from, from = _c === void 0 ? 0 : _c, _d = _a.power, power = _d === void 0 ? 0.8 : _d, _e = _a.timeConstant, timeConstant = _e === void 0 ? 350 : _e, _f = _a.restDelta, restDelta = _f === void 0 ? 0.5 : _f, modifyTarget = _a.modifyTarget;
  var state = { done: false, value: from };
  var amplitude = power * velocity;
  var ideal = from + amplitude;
  var target2 = modifyTarget === void 0 ? ideal : modifyTarget(ideal);
  if (target2 !== ideal)
    amplitude = target2 - from;
  return {
    next: function(t) {
      var delta2 = -amplitude * Math.exp(-t / timeConstant);
      state.done = !(delta2 > restDelta || delta2 < -restDelta);
      state.value = state.done ? target2 : target2 + delta2;
      return state;
    },
    flipTarget: function() {
    }
  };
}
var types = { keyframes, spring, decay };
function detectAnimationFromOptions(config) {
  if (Array.isArray(config.to)) {
    return keyframes;
  } else if (types[config.type]) {
    return types[config.type];
  }
  var keys = new Set(Object.keys(config));
  if (keys.has("ease") || keys.has("duration") && !keys.has("dampingRatio")) {
    return keyframes;
  } else if (keys.has("dampingRatio") || keys.has("stiffness") || keys.has("mass") || keys.has("damping") || keys.has("restSpeed") || keys.has("restDelta")) {
    return spring;
  }
  return keyframes;
}
function loopElapsed(elapsed, duration, delay) {
  if (delay === void 0) {
    delay = 0;
  }
  return elapsed - duration - delay;
}
function reverseElapsed(elapsed, duration, delay, isForwardPlayback) {
  if (delay === void 0) {
    delay = 0;
  }
  if (isForwardPlayback === void 0) {
    isForwardPlayback = true;
  }
  return isForwardPlayback ? loopElapsed(duration + -elapsed, duration, delay) : duration - (elapsed - duration) + delay;
}
function hasRepeatDelayElapsed(elapsed, duration, delay, isForwardPlayback) {
  return isForwardPlayback ? elapsed >= duration + delay : elapsed <= -delay;
}
var framesync = function(update) {
  var passTimestamp = function(_a) {
    var delta2 = _a.delta;
    return update(delta2);
  };
  return {
    start: function() {
      return framesync_es_default.update(passTimestamp, true, true);
    },
    stop: function() {
      return cancelSync.update(passTimestamp);
    }
  };
};
function animate(_a) {
  var _b, _c;
  var from = _a.from, _d = _a.autoplay, autoplay = _d === void 0 ? true : _d, _e = _a.driver, driver = _e === void 0 ? framesync : _e, _f = _a.elapsed, elapsed = _f === void 0 ? 0 : _f, _g = _a.repeat, repeatMax = _g === void 0 ? 0 : _g, _h = _a.repeatType, repeatType = _h === void 0 ? "loop" : _h, _j = _a.repeatDelay, repeatDelay = _j === void 0 ? 0 : _j, onPlay = _a.onPlay, onStop = _a.onStop, onComplete = _a.onComplete, onRepeat = _a.onRepeat, onUpdate = _a.onUpdate, options = __rest(_a, ["from", "autoplay", "driver", "elapsed", "repeat", "repeatType", "repeatDelay", "onPlay", "onStop", "onComplete", "onRepeat", "onUpdate"]);
  var to = options.to;
  var driverControls;
  var repeatCount = 0;
  var computedDuration = options.duration;
  var latest;
  var isComplete = false;
  var isForwardPlayback = true;
  var interpolateFromNumber;
  var animator = detectAnimationFromOptions(options);
  if ((_c = (_b = animator).needsInterpolation) === null || _c === void 0 ? void 0 : _c.call(_b, from, to)) {
    interpolateFromNumber = interpolate([0, 100], [from, to], {
      clamp: false
    });
    from = 0;
    to = 100;
  }
  var animation = animator(__assign(__assign({}, options), { from, to }));
  function repeat() {
    repeatCount++;
    if (repeatType === "reverse") {
      isForwardPlayback = repeatCount % 2 === 0;
      elapsed = reverseElapsed(elapsed, computedDuration, repeatDelay, isForwardPlayback);
    } else {
      elapsed = loopElapsed(elapsed, computedDuration, repeatDelay);
      if (repeatType === "mirror")
        animation.flipTarget();
    }
    isComplete = false;
    onRepeat && onRepeat();
  }
  function complete() {
    driverControls.stop();
    onComplete && onComplete();
  }
  function update(delta2) {
    if (!isForwardPlayback)
      delta2 = -delta2;
    elapsed += delta2;
    if (!isComplete) {
      var state = animation.next(Math.max(0, elapsed));
      latest = state.value;
      if (interpolateFromNumber)
        latest = interpolateFromNumber(latest);
      isComplete = isForwardPlayback ? state.done : elapsed <= 0;
    }
    onUpdate === null || onUpdate === void 0 ? void 0 : onUpdate(latest);
    if (isComplete) {
      if (repeatCount === 0)
        computedDuration !== null && computedDuration !== void 0 ? computedDuration : computedDuration = elapsed;
      if (repeatCount < repeatMax) {
        hasRepeatDelayElapsed(elapsed, computedDuration, repeatDelay, isForwardPlayback) && repeat();
      } else {
        complete();
      }
    }
  }
  function play() {
    onPlay === null || onPlay === void 0 ? void 0 : onPlay();
    driverControls = driver(update);
    driverControls.start();
  }
  autoplay && play();
  return {
    stop: function() {
      onStop === null || onStop === void 0 ? void 0 : onStop();
      driverControls.stop();
    }
  };
}
function velocityPerSecond(velocity, frameDuration) {
  return frameDuration ? velocity * (1e3 / frameDuration) : 0;
}
function inertia(_a) {
  var _b = _a.from, from = _b === void 0 ? 0 : _b, _c = _a.velocity, velocity = _c === void 0 ? 0 : _c, min = _a.min, max = _a.max, _d = _a.power, power = _d === void 0 ? 0.8 : _d, _e = _a.timeConstant, timeConstant = _e === void 0 ? 750 : _e, _f = _a.bounceStiffness, bounceStiffness = _f === void 0 ? 500 : _f, _g = _a.bounceDamping, bounceDamping = _g === void 0 ? 10 : _g, _h = _a.restDelta, restDelta = _h === void 0 ? 1 : _h, modifyTarget = _a.modifyTarget, driver = _a.driver, onUpdate = _a.onUpdate, onComplete = _a.onComplete;
  var currentAnimation;
  function isOutOfBounds(v) {
    return min !== void 0 && v < min || max !== void 0 && v > max;
  }
  function boundaryNearest(v) {
    if (min === void 0)
      return max;
    if (max === void 0)
      return min;
    return Math.abs(min - v) < Math.abs(max - v) ? min : max;
  }
  function startAnimation2(options) {
    currentAnimation === null || currentAnimation === void 0 ? void 0 : currentAnimation.stop();
    currentAnimation = animate(__assign(__assign({}, options), { driver, onUpdate: function(v) {
      var _a2;
      onUpdate === null || onUpdate === void 0 ? void 0 : onUpdate(v);
      (_a2 = options.onUpdate) === null || _a2 === void 0 ? void 0 : _a2.call(options, v);
    }, onComplete }));
  }
  function startSpring(options) {
    startAnimation2(__assign({ type: "spring", stiffness: bounceStiffness, damping: bounceDamping, restDelta }, options));
  }
  if (isOutOfBounds(from)) {
    startSpring({ from, velocity, to: boundaryNearest(from) });
  } else {
    var target2 = power * velocity + from;
    if (typeof modifyTarget !== "undefined")
      target2 = modifyTarget(target2);
    var boundary_1 = boundaryNearest(target2);
    var heading_1 = boundary_1 === min ? -1 : 1;
    var prev_1;
    var current_1;
    var checkBoundary = function(v) {
      prev_1 = current_1;
      current_1 = v;
      velocity = velocityPerSecond(v - prev_1, getFrameData().delta);
      if (heading_1 === 1 && v > boundary_1 || heading_1 === -1 && v < boundary_1) {
        startSpring({ from: v, to: boundary_1, velocity });
      }
    };
    startAnimation2({
      type: "decay",
      from,
      velocity,
      timeConstant,
      power,
      restDelta,
      modifyTarget,
      onUpdate: isOutOfBounds(target2) ? checkBoundary : void 0
    });
  }
  return {
    stop: function() {
      return currentAnimation === null || currentAnimation === void 0 ? void 0 : currentAnimation.stop();
    }
  };
}
var identity = function(v) {
  return v;
};
var createAttractor = function(alterDisplacement) {
  if (alterDisplacement === void 0) {
    alterDisplacement = identity;
  }
  return function(constant, origin, v) {
    var displacement = origin - v;
    var springModifiedDisplacement = -(0 - constant + 1) * (0 - alterDisplacement(Math.abs(displacement)));
    return displacement <= 0 ? origin + springModifiedDisplacement : origin - springModifiedDisplacement;
  };
};
var attract = createAttractor();
var attractExpo = createAttractor(Math.sqrt);
var isPoint = function(point) {
  return point.hasOwnProperty("x") && point.hasOwnProperty("y");
};
var isPoint3D = function(point) {
  return isPoint(point) && point.hasOwnProperty("z");
};
var distance1D = function(a2, b2) {
  return Math.abs(a2 - b2);
};
function distance(a2, b2) {
  if (isNum(a2) && isNum(b2)) {
    return distance1D(a2, b2);
  } else if (isPoint(a2) && isPoint(b2)) {
    var xDelta = distance1D(a2.x, b2.x);
    var yDelta = distance1D(a2.y, b2.y);
    var zDelta = isPoint3D(a2) && isPoint3D(b2) ? distance1D(a2.z, b2.z) : 0;
    return Math.sqrt(Math.pow(xDelta, 2) + Math.pow(yDelta, 2) + Math.pow(zDelta, 2));
  }
}
var wrap = function(min, max, v) {
  var rangeSize = max - min;
  return ((v - min) % rangeSize + rangeSize) % rangeSize + min;
};
var a = function(a1, a2) {
  return 1 - 3 * a2 + 3 * a1;
};
var b = function(a1, a2) {
  return 3 * a2 - 6 * a1;
};
var c = function(a1) {
  return 3 * a1;
};
var calcBezier = function(t, a1, a2) {
  return ((a(a1, a2) * t + b(a1, a2)) * t + c(a1)) * t;
};
var getSlope = function(t, a1, a2) {
  return 3 * a(a1, a2) * t * t + 2 * b(a1, a2) * t + c(a1);
};
var subdivisionPrecision = 1e-7;
var subdivisionMaxIterations = 10;
function binarySubdivide(aX, aA, aB, mX1, mX2) {
  var currentX;
  var currentT;
  var i = 0;
  do {
    currentT = aA + (aB - aA) / 2;
    currentX = calcBezier(currentT, mX1, mX2) - aX;
    if (currentX > 0) {
      aB = currentT;
    } else {
      aA = currentT;
    }
  } while (Math.abs(currentX) > subdivisionPrecision && ++i < subdivisionMaxIterations);
  return currentT;
}
var newtonIterations = 8;
var newtonMinSlope = 1e-3;
function newtonRaphsonIterate(aX, aGuessT, mX1, mX2) {
  for (var i = 0; i < newtonIterations; ++i) {
    var currentSlope = getSlope(aGuessT, mX1, mX2);
    if (currentSlope === 0) {
      return aGuessT;
    }
    var currentX = calcBezier(aGuessT, mX1, mX2) - aX;
    aGuessT -= currentX / currentSlope;
  }
  return aGuessT;
}
var kSplineTableSize = 11;
var kSampleStepSize = 1 / (kSplineTableSize - 1);
function cubicBezier(mX1, mY1, mX2, mY2) {
  if (mX1 === mY1 && mX2 === mY2)
    return linear;
  var sampleValues = new Float32Array(kSplineTableSize);
  for (var i = 0; i < kSplineTableSize; ++i) {
    sampleValues[i] = calcBezier(i * kSampleStepSize, mX1, mX2);
  }
  function getTForX(aX) {
    var intervalStart = 0;
    var currentSample = 1;
    var lastSample = kSplineTableSize - 1;
    for (; currentSample !== lastSample && sampleValues[currentSample] <= aX; ++currentSample) {
      intervalStart += kSampleStepSize;
    }
    --currentSample;
    var dist = (aX - sampleValues[currentSample]) / (sampleValues[currentSample + 1] - sampleValues[currentSample]);
    var guessForT = intervalStart + dist * kSampleStepSize;
    var initialSlope = getSlope(guessForT, mX1, mX2);
    if (initialSlope >= newtonMinSlope) {
      return newtonRaphsonIterate(aX, guessForT, mX1, mX2);
    } else if (initialSlope === 0) {
      return guessForT;
    } else {
      return binarySubdivide(aX, intervalStart, intervalStart + kSampleStepSize, mX1, mX2);
    }
  }
  return function(t) {
    return t === 0 || t === 1 ? t : calcBezier(getTForX(t), mY1, mY2);
  };
}

// ../../node_modules/.pnpm/framer-motion@2.9.5_react-dom@17.0.2_react@17.0.2/node_modules/framer-motion/dist/framer-motion.es.js
var import_react = __toESM(require_react());
var isRefObject = function(ref) {
  return typeof ref === "object" && ref.hasOwnProperty("current");
};
var SubscriptionManager = function() {
  function SubscriptionManager2() {
    this.subscriptions = /* @__PURE__ */ new Set();
  }
  SubscriptionManager2.prototype.add = function(handler) {
    var _this = this;
    this.subscriptions.add(handler);
    return function() {
      return void _this.subscriptions.delete(handler);
    };
  };
  SubscriptionManager2.prototype.notify = function(a2, b2, c2) {
    var e_1, _a;
    if (!this.subscriptions.size)
      return;
    try {
      for (var _b = __values(this.subscriptions), _c = _b.next(); !_c.done; _c = _b.next()) {
        var handler = _c.value;
        handler(a2, b2, c2);
      }
    } catch (e_1_1) {
      e_1 = { error: e_1_1 };
    } finally {
      try {
        if (_c && !_c.done && (_a = _b.return))
          _a.call(_b);
      } finally {
        if (e_1)
          throw e_1.error;
      }
    }
  };
  SubscriptionManager2.prototype.clear = function() {
    this.subscriptions.clear();
  };
  return SubscriptionManager2;
}();
var isFloat = function(value) {
  return !isNaN(parseFloat(value));
};
var MotionValue = function() {
  function MotionValue2(init) {
    var _this = this;
    this.timeDelta = 0;
    this.lastUpdated = 0;
    this.updateSubscribers = new SubscriptionManager();
    this.renderSubscribers = new SubscriptionManager();
    this.canTrackVelocity = false;
    this.updateAndNotify = function(v, render2) {
      if (render2 === void 0) {
        render2 = true;
      }
      _this.prev = _this.current;
      _this.current = v;
      if (_this.prev !== _this.current) {
        _this.updateSubscribers.notify(_this.current);
      }
      if (render2) {
        _this.renderSubscribers.notify(_this.current);
      }
      var _a = getFrameData(), delta2 = _a.delta, timestamp = _a.timestamp;
      if (_this.lastUpdated !== timestamp) {
        _this.timeDelta = delta2;
        _this.lastUpdated = timestamp;
        framesync_es_default.postRender(_this.scheduleVelocityCheck);
      }
    };
    this.scheduleVelocityCheck = function() {
      return framesync_es_default.postRender(_this.velocityCheck);
    };
    this.velocityCheck = function(_a) {
      var timestamp = _a.timestamp;
      if (timestamp !== _this.lastUpdated) {
        _this.prev = _this.current;
      }
    };
    this.set(init, false);
    this.canTrackVelocity = isFloat(this.current);
  }
  MotionValue2.prototype.onChange = function(subscription) {
    return this.updateSubscribers.add(subscription);
  };
  MotionValue2.prototype.clearListeners = function() {
    this.updateSubscribers.clear();
  };
  MotionValue2.prototype.onRenderRequest = function(subscription) {
    subscription(this.get());
    return this.renderSubscribers.add(subscription);
  };
  MotionValue2.prototype.attach = function(passiveEffect) {
    this.passiveEffect = passiveEffect;
  };
  MotionValue2.prototype.set = function(v, render2) {
    if (render2 === void 0) {
      render2 = true;
    }
    if (!render2 || !this.passiveEffect) {
      this.updateAndNotify(v, render2);
    } else {
      this.passiveEffect(v, this.updateAndNotify);
    }
  };
  MotionValue2.prototype.get = function() {
    return this.current;
  };
  MotionValue2.prototype.getPrevious = function() {
    return this.prev;
  };
  MotionValue2.prototype.getVelocity = function() {
    return this.canTrackVelocity ? velocityPerSecond(parseFloat(this.current) - parseFloat(this.prev), this.timeDelta) : 0;
  };
  MotionValue2.prototype.start = function(animation) {
    var _this = this;
    this.stop();
    return new Promise(function(resolve) {
      _this.stopAnimation = animation(resolve);
    }).then(function() {
      return _this.clearAnimation();
    });
  };
  MotionValue2.prototype.stop = function() {
    if (this.stopAnimation)
      this.stopAnimation();
    this.clearAnimation();
  };
  MotionValue2.prototype.isAnimating = function() {
    return !!this.stopAnimation;
  };
  MotionValue2.prototype.clearAnimation = function() {
    this.stopAnimation = null;
  };
  MotionValue2.prototype.destroy = function() {
    this.updateSubscribers.clear();
    this.renderSubscribers.clear();
    this.stop();
  };
  return MotionValue2;
}();
function motionValue(init) {
  return new MotionValue(init);
}
var secondsToMilliseconds = function(seconds) {
  return seconds * 1e3;
};
var easingLookup = {
  linear,
  easeIn,
  easeInOut,
  easeOut,
  circIn,
  circInOut,
  circOut,
  backIn,
  backInOut,
  backOut,
  anticipate,
  bounceIn,
  bounceInOut,
  bounceOut
};
var easingDefinitionToFunction = function(definition) {
  if (Array.isArray(definition)) {
    invariant(definition.length === 4, "Cubic bezier arrays must contain four numerical values.");
    var _a = __read(definition, 4), x1 = _a[0], y1 = _a[1], x2 = _a[2], y2 = _a[3];
    return cubicBezier(x1, y1, x2, y2);
  } else if (typeof definition === "string") {
    invariant(easingLookup[definition] !== void 0, "Invalid easing type '" + definition + "'");
    return easingLookup[definition];
  }
  return definition;
};
var isEasingArray = function(ease) {
  return Array.isArray(ease) && typeof ease[0] !== "number";
};
var isAnimatable = function(key, value) {
  if (key === "zIndex")
    return false;
  if (typeof value === "number" || Array.isArray(value))
    return true;
  if (typeof value === "string" && complex.test(value) && !value.startsWith("url(")) {
    return true;
  }
  return false;
};
var isKeyframesTarget = function(v) {
  return Array.isArray(v);
};
var underDampedSpring = function() {
  return {
    type: "spring",
    stiffness: 500,
    damping: 25,
    restDelta: 0.5,
    restSpeed: 10
  };
};
var overDampedSpring = function(to) {
  return {
    type: "spring",
    stiffness: 550,
    damping: to === 0 ? 100 : 30,
    restDelta: 0.01,
    restSpeed: 10
  };
};
var linearTween = function() {
  return {
    type: "keyframes",
    ease: "linear",
    duration: 0.3
  };
};
var keyframes2 = function(values) {
  return {
    type: "keyframes",
    duration: 0.8,
    values
  };
};
var defaultTransitions = {
  x: underDampedSpring,
  y: underDampedSpring,
  z: underDampedSpring,
  rotate: underDampedSpring,
  rotateX: underDampedSpring,
  rotateY: underDampedSpring,
  rotateZ: underDampedSpring,
  scaleX: overDampedSpring,
  scaleY: overDampedSpring,
  scale: overDampedSpring,
  opacity: linearTween,
  backgroundColor: linearTween,
  color: linearTween,
  default: overDampedSpring
};
var getDefaultTransition = function(valueKey, to) {
  var transitionFactory;
  if (isKeyframesTarget(to)) {
    transitionFactory = keyframes2;
  } else {
    transitionFactory = defaultTransitions[valueKey] || defaultTransitions.default;
  }
  return __assign({ to }, transitionFactory(to));
};
function isTransitionDefined(_a) {
  var when = _a.when, delay = _a.delay, delayChildren = _a.delayChildren, staggerChildren = _a.staggerChildren, staggerDirection = _a.staggerDirection, repeat = _a.repeat, repeatType = _a.repeatType, repeatDelay = _a.repeatDelay, from = _a.from, transition = __rest(_a, ["when", "delay", "delayChildren", "staggerChildren", "staggerDirection", "repeat", "repeatType", "repeatDelay", "from"]);
  return !!Object.keys(transition).length;
}
function convertTransitionToAnimationOptions(_a) {
  var yoyo = _a.yoyo, loop = _a.loop, flip = _a.flip, ease = _a.ease, times = _a.times, transition = __rest(_a, ["yoyo", "loop", "flip", "ease", "times"]);
  var options = __assign({}, transition);
  if (times) {
    options.offset = times;
  }
  if (transition.duration)
    options["duration"] = secondsToMilliseconds(transition.duration);
  if (transition.repeatDelay)
    options.repeatDelay = secondsToMilliseconds(transition.repeatDelay);
  if (ease) {
    options["ease"] = isEasingArray(ease) ? ease.map(easingDefinitionToFunction) : easingDefinitionToFunction(ease);
  }
  if (transition.type === "tween")
    options.type = "keyframes";
  if (yoyo) {
    options.repeatType = "reverse";
  } else if (loop) {
    options.repeatType = "loop";
  } else if (flip) {
    options.repeatType = "mirror";
  }
  options.repeat = loop || yoyo || flip || transition.repeat;
  if (transition.type !== "spring")
    options.type = "keyframes";
  return options;
}
function getDelayFromTransition(transition, key) {
  var _a, _b, _c, _d, _e;
  return (_e = (_d = (_b = (_a = transition[key]) === null || _a === void 0 ? void 0 : _a.delay) !== null && _b !== void 0 ? _b : (_c = transition["default"]) === null || _c === void 0 ? void 0 : _c.delay) !== null && _d !== void 0 ? _d : transition.delay) !== null && _e !== void 0 ? _e : 0;
}
function hydrateKeyframes(options) {
  if (Array.isArray(options.to) && options.to[0] === null) {
    options.to = __spread(options.to);
    options.to[0] = options.from;
  }
  return options;
}
function getPopmotionAnimationOptions(transition, options, key) {
  var _a;
  if (Array.isArray(options.to)) {
    (_a = transition.duration) !== null && _a !== void 0 ? _a : transition.duration = 0.8;
  }
  hydrateKeyframes(options);
  if (!isTransitionDefined(transition)) {
    transition = __assign(__assign({}, transition), getDefaultTransition(key, options.to));
  }
  return __assign(__assign({}, options), convertTransitionToAnimationOptions(transition));
}
function getAnimation(key, value, target2, transition, onComplete) {
  var _a;
  var valueTransition = getValueTransition(transition, key);
  var origin = (_a = valueTransition.from) !== null && _a !== void 0 ? _a : value.get();
  var isTargetAnimatable = isAnimatable(key, target2);
  if (origin === "none" && isTargetAnimatable && typeof target2 === "string") {
    origin = complex.getAnimatableNone(target2);
  }
  var isOriginAnimatable = isAnimatable(key, origin);
  warning(isOriginAnimatable === isTargetAnimatable, "You are trying to animate " + key + ' from "' + origin + '" to "' + target2 + '". ' + origin + " is not an animatable value - to enable this animation set " + origin + " to a value animatable to " + target2 + " via the `style` property.");
  function start() {
    var options = {
      from: origin,
      to: target2,
      velocity: value.getVelocity(),
      onComplete,
      onUpdate: function(v) {
        return value.set(v);
      }
    };
    return valueTransition.type === "inertia" || valueTransition.type === "decay" ? inertia(__assign(__assign({}, options), valueTransition)) : animate(__assign(__assign({}, getPopmotionAnimationOptions(valueTransition, options, key)), { onUpdate: function(v) {
      var _a2;
      options.onUpdate(v);
      (_a2 = valueTransition.onUpdate) === null || _a2 === void 0 ? void 0 : _a2.call(valueTransition, v);
    }, onComplete: function() {
      var _a2;
      options.onComplete();
      (_a2 = valueTransition.onComplete) === null || _a2 === void 0 ? void 0 : _a2.call(valueTransition);
    } }));
  }
  function set() {
    var _a2;
    value.set(target2);
    onComplete();
    (_a2 = valueTransition === null || valueTransition === void 0 ? void 0 : valueTransition.onComplete) === null || _a2 === void 0 ? void 0 : _a2.call(valueTransition);
    return { stop: function() {
    } };
  }
  return !isOriginAnimatable || !isTargetAnimatable || valueTransition.type === false ? set : start;
}
function getValueTransition(transition, key) {
  return transition[key] || transition["default"] || transition;
}
function startAnimation(key, value, target2, transition) {
  if (transition === void 0) {
    transition = {};
  }
  return value.start(function(onComplete) {
    var delayTimer;
    var controls2;
    var animation = getAnimation(key, value, target2, transition, onComplete);
    var delay = getDelayFromTransition(transition, key);
    var start = function() {
      return controls2 = animation();
    };
    if (delay) {
      delayTimer = setTimeout(start, secondsToMilliseconds(delay));
    } else {
      start();
    }
    return function() {
      clearTimeout(delayTimer);
      controls2 === null || controls2 === void 0 ? void 0 : controls2.stop();
    };
  });
}
var isCustomValue = function(v) {
  return Boolean(v && typeof v === "object" && v.mix && v.toValue);
};
var resolveFinalValueInKeyframes = function(v) {
  return isKeyframesTarget(v) ? v[v.length - 1] || 0 : v;
};
var isNumericalString = function(v) {
  return /^\-?\d*\.?\d+$/.test(v);
};
var auto = {
  test: function(v) {
    return v === "auto";
  },
  parse: function(v) {
    return v;
  }
};
var int = __assign(__assign({}, number), { transform: Math.round });
var defaultValueTypes = {
  color,
  backgroundColor: color,
  outlineColor: color,
  fill: color,
  stroke: color,
  borderColor: color,
  borderTopColor: color,
  borderRightColor: color,
  borderBottomColor: color,
  borderLeftColor: color,
  borderWidth: px,
  borderTopWidth: px,
  borderRightWidth: px,
  borderBottomWidth: px,
  borderLeftWidth: px,
  borderRadius: px,
  radius: px,
  borderTopLeftRadius: px,
  borderTopRightRadius: px,
  borderBottomRightRadius: px,
  borderBottomLeftRadius: px,
  width: px,
  maxWidth: px,
  height: px,
  maxHeight: px,
  size: px,
  top: px,
  right: px,
  bottom: px,
  left: px,
  padding: px,
  paddingTop: px,
  paddingRight: px,
  paddingBottom: px,
  paddingLeft: px,
  margin: px,
  marginTop: px,
  marginRight: px,
  marginBottom: px,
  marginLeft: px,
  rotate: degrees,
  rotateX: degrees,
  rotateY: degrees,
  rotateZ: degrees,
  scale,
  scaleX: scale,
  scaleY: scale,
  scaleZ: scale,
  skew: degrees,
  skewX: degrees,
  skewY: degrees,
  distance: px,
  translateX: px,
  translateY: px,
  translateZ: px,
  x: px,
  y: px,
  z: px,
  perspective: px,
  transformPerspective: px,
  opacity: alpha,
  originX: progressPercentage,
  originY: progressPercentage,
  originZ: px,
  zIndex: int,
  fillOpacity: alpha,
  strokeOpacity: alpha,
  numOctaves: int
};
var dimensionValueTypes = [number, px, percent, degrees, vw, vh, auto];
var testValueType = function(v) {
  return function(type) {
    return type.test(v);
  };
};
var findDimensionValueType = function(v) {
  return dimensionValueTypes.find(testValueType(v));
};
var valueTypes = __spread(dimensionValueTypes, [color, complex]);
var findValueType = function(v) {
  return valueTypes.find(testValueType(v));
};
var getDefaultValueType = function(key) {
  return defaultValueTypes[key];
};
var getValueAsType = function(value, type) {
  return type && typeof value === "number" ? type.transform(value) : value;
};
function isVariantResolver(variant2) {
  return typeof variant2 === "function";
}
function isVariantLabels(v) {
  return Array.isArray(v);
}
function isVariantLabel(v) {
  return typeof v === "string" || isVariantLabels(v);
}
function getCurrent(visualElement) {
  var current = {};
  visualElement.forEachValue(function(value, key) {
    return current[key] = value.get();
  });
  return current;
}
function getVelocity(visualElement) {
  var velocity = {};
  visualElement.forEachValue(function(value, key) {
    return velocity[key] = value.getVelocity();
  });
  return velocity;
}
function resolveVariant(visualElement, variant2, custom) {
  var resolved = {};
  if (!variant2) {
    return resolved;
  } else if (isVariantResolver(variant2)) {
    resolved = variant2(custom !== null && custom !== void 0 ? custom : visualElement.getVariantPayload(), getCurrent(visualElement), getVelocity(visualElement));
  } else {
    resolved = variant2;
  }
  return __assign({ transition: visualElement.getDefaultTransition() }, resolved);
}
function setMotionValue(visualElement, key, value) {
  if (visualElement.hasValue(key)) {
    visualElement.getValue(key).set(value);
  } else {
    visualElement.addValue(key, motionValue(value));
  }
}
function setTarget(visualElement, definition, _a) {
  var priority = (_a === void 0 ? {} : _a).priority;
  var _b = visualElement.makeTargetAnimatable(resolveVariant(visualElement, definition), false), _c = _b.transitionEnd, transitionEnd = _c === void 0 ? {} : _c, transition = _b.transition, target2 = __rest(_b, ["transitionEnd", "transition"]);
  target2 = __assign(__assign({}, target2), transitionEnd);
  for (var key in target2) {
    var value = resolveFinalValueInKeyframes(target2[key]);
    setMotionValue(visualElement, key, value);
    if (!priority)
      visualElement.baseTarget[key] = value;
  }
}
function setVariants(visualElement, variantLabels) {
  var reversedLabels = __spread(variantLabels).reverse();
  reversedLabels.forEach(function(key) {
    var _a;
    setTarget(visualElement, visualElement.getVariant(key));
    (_a = visualElement.variantChildren) === null || _a === void 0 ? void 0 : _a.forEach(function(child) {
      setVariants(child, variantLabels);
    });
  });
}
function setValues(visualElement, definition) {
  if (Array.isArray(definition)) {
    return setVariants(visualElement, definition);
  } else if (typeof definition === "string") {
    return setVariants(visualElement, [definition]);
  } else {
    setTarget(visualElement, definition);
  }
}
function checkTargetForNewValues(visualElement, target2, origin) {
  var _a, _b;
  var _c;
  var newValueKeys = Object.keys(target2).filter(function(key2) {
    return !visualElement.hasValue(key2);
  });
  var numNewValues = newValueKeys.length;
  if (!numNewValues)
    return;
  for (var i = 0; i < numNewValues; i++) {
    var key = newValueKeys[i];
    var targetValue = target2[key];
    var value = null;
    if (Array.isArray(targetValue)) {
      value = targetValue[0];
    }
    if (value === null) {
      var readValue = (_a = origin[key]) !== null && _a !== void 0 ? _a : visualElement.readNativeValue(key);
      value = readValue !== void 0 ? readValue : target2[key];
      invariant(value !== null, 'No initial value for "' + key + '" can be inferred. Ensure an initial value for "' + key + '" is defined on the component.');
    }
    if (typeof value === "string" && isNumericalString(value)) {
      value = parseFloat(value);
    } else if (!findValueType(value) && complex.test(targetValue)) {
      value = complex.getAnimatableNone(targetValue);
    }
    visualElement.addValue(key, motionValue(value));
    (_b = (_c = origin)[key]) !== null && _b !== void 0 ? _b : _c[key] = value;
    visualElement.baseTarget[key] = value;
  }
}
function getOriginFromTransition(key, transition) {
  if (!transition)
    return;
  var valueTransition = transition[key] || transition["default"] || transition;
  return valueTransition.from;
}
function getOrigin(target2, transition, visualElement) {
  var _a, _b;
  var origin = {};
  for (var key in target2) {
    origin[key] = (_a = getOriginFromTransition(key, transition)) !== null && _a !== void 0 ? _a : (_b = visualElement.getValue(key)) === null || _b === void 0 ? void 0 : _b.get();
  }
  return origin;
}
function startVisualElementAnimation(visualElement, definition, opts) {
  if (opts === void 0) {
    opts = {};
  }
  if (opts.priority) {
    visualElement.activeOverrides.add(opts.priority);
  }
  visualElement.resetIsAnimating(opts.priority);
  var animation;
  if (isVariantLabels(definition)) {
    animation = animateVariantLabels(visualElement, definition, opts);
  } else if (isVariantLabel(definition)) {
    animation = animateVariant(visualElement, definition, opts);
  } else {
    animation = animateTarget(visualElement, definition, opts);
  }
  visualElement.onAnimationStart();
  return animation.then(function() {
    return visualElement.onAnimationComplete();
  });
}
function animateVariantLabels(visualElement, variantLabels, opts) {
  var animations = __spread(variantLabels).reverse().map(function(label) {
    return animateVariant(visualElement, label, opts);
  });
  return Promise.all(animations);
}
function animateVariant(visualElement, label, opts) {
  var _a;
  var priority = opts && opts.priority || 0;
  var variantDefinition = visualElement.getVariant(label);
  var variant2 = resolveVariant(visualElement, variantDefinition, opts && opts.custom);
  var transition = variant2.transition || {};
  var getAnimation2 = variantDefinition ? function() {
    return animateTarget(visualElement, variant2, opts);
  } : function() {
    return Promise.resolve();
  };
  var getChildrenAnimations = ((_a = visualElement.variantChildrenOrder) === null || _a === void 0 ? void 0 : _a.size) ? function(forwardDelay) {
    if (forwardDelay === void 0) {
      forwardDelay = 0;
    }
    var _a2 = transition.delayChildren, delayChildren = _a2 === void 0 ? 0 : _a2;
    return animateChildren(visualElement, label, delayChildren + forwardDelay, transition.staggerChildren, transition.staggerDirection, priority, opts === null || opts === void 0 ? void 0 : opts.custom);
  } : function() {
    return Promise.resolve();
  };
  var when = transition.when;
  if (when) {
    var _b = __read(when === "beforeChildren" ? [getAnimation2, getChildrenAnimations] : [getChildrenAnimations, getAnimation2], 2), first = _b[0], last = _b[1];
    return first().then(last);
  } else {
    return Promise.all([getAnimation2(), getChildrenAnimations(opts === null || opts === void 0 ? void 0 : opts.delay)]);
  }
}
function animateChildren(visualElement, variantLabel, delayChildren, staggerChildren, staggerDirection, priority, custom) {
  if (delayChildren === void 0) {
    delayChildren = 0;
  }
  if (staggerChildren === void 0) {
    staggerChildren = 0;
  }
  if (staggerDirection === void 0) {
    staggerDirection = 1;
  }
  if (priority === void 0) {
    priority = 0;
  }
  var animations = [];
  var maxStaggerDuration = (visualElement.variantChildrenOrder.size - 1) * staggerChildren;
  var generateStaggerDuration = staggerDirection === 1 ? function(i) {
    return i * staggerChildren;
  } : function(i) {
    return maxStaggerDuration - i * staggerChildren;
  };
  Array.from(visualElement.variantChildrenOrder).forEach(function(child, i) {
    var animation = animateVariant(child, variantLabel, {
      priority,
      delay: delayChildren + generateStaggerDuration(i),
      custom
    });
    animations.push(animation);
  });
  return Promise.all(animations);
}
function stopAnimation(visualElement) {
  visualElement.forEachValue(function(value) {
    return value.stop();
  });
}
function animateTarget(visualElement, definition, _a) {
  var _b = _a === void 0 ? {} : _a, _c = _b.delay, delay = _c === void 0 ? 0 : _c, _d = _b.priority, priority = _d === void 0 ? 0 : _d, transitionOverride = _b.transitionOverride, custom = _b.custom;
  var targetAndTransition = resolveVariant(visualElement, definition, custom);
  if (transitionOverride)
    targetAndTransition.transition = transitionOverride;
  var _e = visualElement.makeTargetAnimatable(targetAndTransition), transitionEnd = _e.transitionEnd, transition = _e.transition, target2 = __rest(_e, ["transitionEnd", "transition"]);
  if (priority)
    visualElement.resolvedOverrides[priority] = target2;
  var animations = [];
  for (var key in target2) {
    var value = visualElement.getValue(key);
    if (!value || !target2 || target2[key] === void 0)
      continue;
    var valueTarget = target2[key];
    if (!priority) {
      visualElement.baseTarget[key] = resolveFinalValueInKeyframes(valueTarget);
    }
    if (visualElement.isAnimating.has(key))
      continue;
    visualElement.isAnimating.add(key);
    animations.push(startAnimation(key, value, valueTarget, __assign({ delay }, transition)));
  }
  var allAnimations = Promise.all(animations);
  return transitionEnd ? allAnimations.then(function() {
    return setTarget(visualElement, transitionEnd, { priority });
  }) : allAnimations;
}
function setOverride(visualElement, definition, index2) {
  var _a;
  visualElement.overrides[index2] = definition;
  (_a = visualElement.variantChildren) === null || _a === void 0 ? void 0 : _a.forEach(function(child) {
    setOverride(child, definition, index2);
  });
}
function startOverride(visualElement, index2) {
  var override = visualElement.overrides[index2];
  if (override) {
    return startVisualElementAnimation(visualElement, override, {
      priority: index2
    });
  }
}
function clearOverride(visualElement, index2) {
  var _a;
  (_a = visualElement.variantChildrenOrder) === null || _a === void 0 ? void 0 : _a.forEach(function(child) {
    clearOverride(child, index2);
  });
  var override = visualElement.overrides[index2];
  if (!override)
    return;
  visualElement.activeOverrides.delete(index2);
  var highest = getHighestOverridePriortiy(visualElement);
  visualElement.resetIsAnimating();
  if (highest) {
    var highestOverride = visualElement.overrides[highest];
    highestOverride && startOverride(visualElement, highest);
  }
  var overrideTarget = visualElement.resolvedOverrides[index2];
  if (!overrideTarget)
    return;
  var remainingValues = {};
  for (var key in visualElement.baseTarget) {
    if (overrideTarget[key] !== void 0) {
      remainingValues[key] = visualElement.baseTarget[key];
    }
  }
  visualElement.onAnimationStart();
  animateTarget(visualElement, remainingValues).then(function() {
    visualElement.onAnimationComplete();
  });
}
function getHighestOverridePriortiy(visualElement) {
  if (!visualElement.activeOverrides.size)
    return 0;
  return Math.max.apply(Math, __spread(Array.from(visualElement.activeOverrides)));
}
var VisualElement = function() {
  function VisualElement2(parent, ref) {
    var _this = this;
    this.children = /* @__PURE__ */ new Set();
    this.baseTarget = {};
    this.overrides = [];
    this.resolvedOverrides = [];
    this.activeOverrides = /* @__PURE__ */ new Set();
    this.isAnimating = /* @__PURE__ */ new Set();
    this.latest = {};
    this.values = /* @__PURE__ */ new Map();
    this.valueSubscriptions = /* @__PURE__ */ new Map();
    this.config = {};
    this.isMounted = false;
    this.update = function() {
      return _this.config.onUpdate(_this.latest);
    };
    this.triggerRender = function() {
      return _this.render();
    };
    this.ref = function(element) {
      element ? _this.mount(element) : _this.unmount();
      if (!_this.externalRef)
        return;
      if (typeof _this.externalRef === "function") {
        _this.externalRef(element);
      } else if (isRefObject(_this.externalRef)) {
        _this.externalRef.current = element;
      }
    };
    this.parent = parent;
    this.rootParent = parent ? parent.rootParent : this;
    this.treePath = parent ? __spread(parent.treePath, [parent]) : [];
    this.depth = parent ? parent.depth + 1 : 0;
    this.externalRef = ref;
  }
  VisualElement2.prototype.getVariantPayload = function() {
    return this.config.custom;
  };
  VisualElement2.prototype.getVariant = function(label) {
    var _a;
    return (_a = this.config.variants) === null || _a === void 0 ? void 0 : _a[label];
  };
  VisualElement2.prototype.addVariantChild = function(visualElement) {
    if (!this.variantChildren)
      this.variantChildren = /* @__PURE__ */ new Set();
    this.variantChildren.add(visualElement);
  };
  VisualElement2.prototype.addVariantChildOrder = function(visualElement) {
    if (!this.variantChildrenOrder)
      this.variantChildrenOrder = /* @__PURE__ */ new Set();
    this.variantChildrenOrder.add(visualElement);
  };
  VisualElement2.prototype.onAnimationStart = function() {
    var _a, _b;
    (_b = (_a = this.config).onAnimationStart) === null || _b === void 0 ? void 0 : _b.call(_a);
  };
  VisualElement2.prototype.onAnimationComplete = function() {
    var _a, _b;
    this.isMounted && ((_b = (_a = this.config).onAnimationComplete) === null || _b === void 0 ? void 0 : _b.call(_a));
  };
  VisualElement2.prototype.getDefaultTransition = function() {
    return this.config.transition;
  };
  VisualElement2.prototype.resetIsAnimating = function(priority) {
    var _a;
    if (priority === void 0) {
      priority = 0;
    }
    this.isAnimating.clear();
    if (priority < getHighestOverridePriortiy(this)) {
      this.checkOverrideIsAnimating(priority);
    }
    (_a = this.variantChildren) === null || _a === void 0 ? void 0 : _a.forEach(function(child) {
      return child.resetIsAnimating(priority);
    });
  };
  VisualElement2.prototype.checkOverrideIsAnimating = function(priority) {
    var numOverrides = this.overrides.length;
    for (var i = priority + 1; i < numOverrides; i++) {
      var resolvedOverride = this.resolvedOverrides[i];
      if (resolvedOverride) {
        for (var key in resolvedOverride) {
          this.isAnimating.add(key);
        }
      }
    }
  };
  VisualElement2.prototype.subscribe = function(child) {
    var _this = this;
    this.children.add(child);
    return function() {
      return _this.children.delete(child);
    };
  };
  VisualElement2.prototype.hasValue = function(key) {
    return this.values.has(key);
  };
  VisualElement2.prototype.addValue = function(key, value) {
    if (this.hasValue(key))
      this.removeValue(key);
    this.values.set(key, value);
    this.setSingleStaticValue(key, value.get());
    this.subscribeToValue(key, value);
  };
  VisualElement2.prototype.removeValue = function(key) {
    var _a;
    (_a = this.valueSubscriptions.get(key)) === null || _a === void 0 ? void 0 : _a();
    this.valueSubscriptions.delete(key);
    this.values.delete(key);
    delete this.latest[key];
  };
  VisualElement2.prototype.getValue = function(key, defaultValue) {
    var value = this.values.get(key);
    if (value === void 0 && defaultValue !== void 0) {
      value = new MotionValue(defaultValue);
      this.addValue(key, value);
    }
    return value;
  };
  VisualElement2.prototype.forEachValue = function(callback) {
    this.values.forEach(callback);
  };
  VisualElement2.prototype.getInstance = function() {
    return this.element;
  };
  VisualElement2.prototype.updateConfig = function(config) {
    if (config === void 0) {
      config = {};
    }
    this.config = __assign({}, config);
  };
  VisualElement2.prototype.setSingleStaticValue = function(key, value) {
    this.latest[key] = value;
  };
  VisualElement2.prototype.setStaticValues = function(values, value) {
    if (typeof values === "string") {
      this.setSingleStaticValue(values, value);
    } else {
      for (var key in values) {
        this.setSingleStaticValue(key, values[key]);
      }
    }
  };
  VisualElement2.prototype.scheduleRender = function() {
    framesync_es_default.render(this.triggerRender, false, true);
  };
  VisualElement2.prototype.scheduleUpdateLayoutDelta = function() {
    framesync_es_default.preRender(this.rootParent.updateLayoutDelta, false, true);
  };
  VisualElement2.prototype.subscribeToValue = function(key, value) {
    var _this = this;
    var onChange = function(latest) {
      _this.setSingleStaticValue(key, latest);
      _this.element && _this.config.onUpdate && framesync_es_default.update(_this.update, false, true);
    };
    var onRender = function() {
      _this.element && _this.scheduleRender();
    };
    var unsubscribeOnChange = value.onChange(onChange);
    var unsubscribeOnRender = value.onRenderRequest(onRender);
    this.valueSubscriptions.set(key, function() {
      unsubscribeOnChange();
      unsubscribeOnRender();
    });
  };
  VisualElement2.prototype.mount = function(element) {
    invariant(!!element, "No ref found. Ensure components created with motion.custom forward refs using React.forwardRef");
    if (this.parent) {
      this.removeFromParent = this.parent.subscribe(this);
    }
    this.element = this.current = element;
  };
  VisualElement2.prototype.unmount = function() {
    var _this = this;
    this.forEachValue(function(_, key) {
      return _this.removeValue(key);
    });
    cancelSync.update(this.update);
    cancelSync.render(this.render);
    this.removeFromParent && this.removeFromParent();
  };
  return VisualElement2;
}();
function noop(any) {
  return any;
}
function convertBoundingBoxToAxisBox(_a) {
  var top = _a.top, left = _a.left, right = _a.right, bottom = _a.bottom;
  return {
    x: { min: left, max: right },
    y: { min: top, max: bottom }
  };
}
function convertAxisBoxToBoundingBox(_a) {
  var x = _a.x, y = _a.y;
  return {
    top: y.min,
    bottom: y.max,
    left: x.min,
    right: x.max
  };
}
function transformBoundingBox(_a, transformPoint2) {
  var top = _a.top, left = _a.left, bottom = _a.bottom, right = _a.right;
  if (transformPoint2 === void 0) {
    transformPoint2 = noop;
  }
  var topLeft = transformPoint2({ x: left, y: top });
  var bottomRight = transformPoint2({ x: right, y: bottom });
  return {
    top: topLeft.y,
    left: topLeft.x,
    bottom: bottomRight.y,
    right: bottomRight.x
  };
}
function axisBox() {
  return { x: { min: 0, max: 1 }, y: { min: 0, max: 1 } };
}
function copyAxisBox(box) {
  return {
    x: __assign({}, box.x),
    y: __assign({}, box.y)
  };
}
var zeroDelta = {
  translate: 0,
  scale: 1,
  origin: 0,
  originPoint: 0
};
function delta() {
  return {
    x: __assign({}, zeroDelta),
    y: __assign({}, zeroDelta)
  };
}
var transformAxes = ["", "X", "Y", "Z"];
var order = ["perspective", "translate", "scale", "rotate", "skew"];
var boxDistortingKeys = /* @__PURE__ */ new Set();
var transformProps = ["transformPerspective", "x", "y", "z"];
order.forEach(function(operationKey) {
  var isDistorting = (/* @__PURE__ */ new Set(["rotate", "skew"])).has(operationKey);
  transformAxes.forEach(function(axesKey) {
    var key = operationKey + axesKey;
    transformProps.push(key);
    isDistorting && boxDistortingKeys.add(key);
  });
});
function sortTransformProps(a2, b2) {
  return transformProps.indexOf(a2) - transformProps.indexOf(b2);
}
var transformPropSet = new Set(transformProps);
function isTransformProp(key) {
  return transformPropSet.has(key);
}
var transformOriginProps = /* @__PURE__ */ new Set(["originX", "originY", "originZ"]);
function isTransformOriginProp(key) {
  return transformOriginProps.has(key);
}
var translateAlias = {
  x: "translateX",
  y: "translateY",
  z: "translateZ",
  transformPerspective: "perspective"
};
function buildTransform(transform2, transformKeys2, transformTemplate, transformIsDefault, enableHardwareAcceleration, allowTransformNone) {
  if (enableHardwareAcceleration === void 0) {
    enableHardwareAcceleration = true;
  }
  if (allowTransformNone === void 0) {
    allowTransformNone = true;
  }
  var transformString = "";
  transformKeys2.sort(sortTransformProps);
  var transformHasZ = false;
  var numTransformKeys = transformKeys2.length;
  for (var i = 0; i < numTransformKeys; i++) {
    var key = transformKeys2[i];
    transformString += (translateAlias[key] || key) + "(" + transform2[key] + ") ";
    if (key === "z")
      transformHasZ = true;
  }
  if (!transformHasZ && enableHardwareAcceleration) {
    transformString += "translateZ(0)";
  } else {
    transformString = transformString.trim();
  }
  if (transformTemplate) {
    transformString = transformTemplate(transform2, transformIsDefault ? "" : transformString);
  } else if (allowTransformNone && transformIsDefault) {
    transformString = "none";
  }
  return transformString;
}
function buildTransformOrigin(_a) {
  var _b = _a.originX, originX = _b === void 0 ? "50%" : _b, _c = _a.originY, originY = _c === void 0 ? "50%" : _c, _d = _a.originZ, originZ = _d === void 0 ? 0 : _d;
  return originX + " " + originY + " " + originZ;
}
function buildLayoutProjectionTransform(_a, treeScale) {
  var x = _a.x, y = _a.y;
  var xTranslate = x.translate / treeScale.x;
  var yTranslate = y.translate / treeScale.y;
  return "translate3d(" + xTranslate + "px, " + yTranslate + "px, 0) scale(" + x.scale + ", " + y.scale + ")";
}
var identityProjection = buildLayoutProjectionTransform(delta(), {
  x: 1,
  y: 1
});
function buildLayoutProjectionTransformOrigin(_a) {
  var x = _a.x, y = _a.y;
  return x.origin * 100 + "% " + y.origin * 100 + "% 0";
}
function buildBoxDistortingTransforms(transform2, transformKeys2) {
  var transformString = "";
  transformKeys2.sort(sortTransformProps);
  var numTransformKeys = transformKeys2.length;
  for (var i = 0; i < numTransformKeys; i++) {
    var key = transformKeys2[i];
    if (boxDistortingKeys.has(key)) {
      transformString += key + "(" + transform2[key] + ") ";
    }
  }
  return transformString;
}
function isCSSVariable(key) {
  return key.startsWith("--");
}
function isCSSVariable$1(value) {
  return typeof value === "string" && value.startsWith("var(--");
}
var cssVariableRegex = /var\((--[a-zA-Z0-9-_]+),? ?([a-zA-Z0-9 ()%#.,-]+)?\)/;
function parseCSSVariable(current) {
  var match = cssVariableRegex.exec(current);
  if (!match)
    return [,];
  var _a = __read(match, 3), token = _a[1], fallback = _a[2];
  return [token, fallback];
}
var maxDepth = 4;
function getVariableValue(current, element, depth) {
  if (depth === void 0) {
    depth = 1;
  }
  invariant(depth <= maxDepth, 'Max CSS variable fallback depth detected in property "' + current + '". This may indicate a circular fallback dependency.');
  var _a = __read(parseCSSVariable(current), 2), token = _a[0], fallback = _a[1];
  if (!token)
    return;
  var resolved = window.getComputedStyle(element).getPropertyValue(token);
  if (resolved) {
    return resolved.trim();
  } else if (isCSSVariable$1(fallback)) {
    return getVariableValue(fallback, element, depth + 1);
  } else {
    return fallback;
  }
}
function resolveCSSVariables(visualElement, _a, transitionEnd) {
  var _b;
  var target2 = __rest(_a, []);
  var element = visualElement.getInstance();
  if (!(element instanceof HTMLElement))
    return { target: target2, transitionEnd };
  if (transitionEnd) {
    transitionEnd = __assign({}, transitionEnd);
  }
  visualElement.forEachValue(function(value) {
    var current2 = value.get();
    if (!isCSSVariable$1(current2))
      return;
    var resolved2 = getVariableValue(current2, element);
    if (resolved2)
      value.set(resolved2);
  });
  for (var key in target2) {
    var current = target2[key];
    if (!isCSSVariable$1(current))
      continue;
    var resolved = getVariableValue(current, element);
    if (!resolved)
      continue;
    target2[key] = resolved;
    if (transitionEnd)
      (_b = transitionEnd[key]) !== null && _b !== void 0 ? _b : transitionEnd[key] = current;
  }
  return { target: target2, transitionEnd };
}
function pixelsToPercent(pixels, axis) {
  return pixels / (axis.max - axis.min) * 100;
}
function correctBorderRadius(latest, viewportBox) {
  if (typeof latest === "string") {
    if (px.test(latest)) {
      latest = parseFloat(latest);
    } else {
      return latest;
    }
  }
  var x = pixelsToPercent(latest, viewportBox.x);
  var y = pixelsToPercent(latest, viewportBox.y);
  return x + "% " + y + "%";
}
var varToken = "_$css";
function correctBoxShadow(latest, _viewportBox, delta2, treeScale) {
  var original = latest;
  var containsCSSVariables = latest.includes("var(");
  var cssVariables = [];
  if (containsCSSVariables) {
    latest = latest.replace(cssVariableRegex, function(match) {
      cssVariables.push(match);
      return varToken;
    });
  }
  var shadow = complex.parse(latest);
  if (shadow.length > 5)
    return original;
  var template = complex.createTransformer(latest);
  var offset = typeof shadow[0] !== "number" ? 1 : 0;
  var xScale = delta2.x.scale * treeScale.x;
  var yScale = delta2.y.scale * treeScale.y;
  shadow[0 + offset] /= xScale;
  shadow[1 + offset] /= yScale;
  var averageScale = mix(xScale, yScale, 0.5);
  if (typeof shadow[2 + offset] === "number")
    shadow[2 + offset] /= averageScale;
  if (typeof shadow[3 + offset] === "number")
    shadow[3 + offset] /= averageScale;
  var output = template(shadow);
  if (containsCSSVariables) {
    var i_1 = 0;
    output = output.replace(varToken, function() {
      var cssVariable = cssVariables[i_1];
      i_1++;
      return cssVariable;
    });
  }
  return output;
}
var borderCorrectionDefinition = {
  process: correctBorderRadius
};
var valueScaleCorrection = {
  borderRadius: __assign(__assign({}, borderCorrectionDefinition), { applyTo: [
    "borderTopLeftRadius",
    "borderTopRightRadius",
    "borderBottomLeftRadius",
    "borderBottomRightRadius"
  ] }),
  borderTopLeftRadius: borderCorrectionDefinition,
  borderTopRightRadius: borderCorrectionDefinition,
  borderBottomLeftRadius: borderCorrectionDefinition,
  borderBottomRightRadius: borderCorrectionDefinition,
  boxShadow: {
    process: correctBoxShadow
  }
};
function addScaleCorrection(correctors) {
  for (var key in correctors) {
    valueScaleCorrection[key] = correctors[key];
  }
}
function buildHTMLStyles(latest, style, vars, transform2, transformOrigin, transformKeys2, _a, isLayoutProjectionEnabled, delta2, deltaFinal, treeScale, targetBox) {
  var enableHardwareAcceleration = _a.enableHardwareAcceleration, transformTemplate = _a.transformTemplate, allowTransformNone = _a.allowTransformNone;
  transformKeys2.length = 0;
  var hasTransform = false;
  var hasTransformOrigin = false;
  var transformIsNone = true;
  for (var key in latest) {
    var value = latest[key];
    var valueType = getDefaultValueType(key);
    var valueAsType = getValueAsType(value, valueType);
    if (isTransformProp(key)) {
      hasTransform = true;
      transform2[key] = valueAsType;
      transformKeys2.push(key);
      if (!transformIsNone)
        continue;
      var defaultValue = valueType.default !== void 0 ? valueType.default : 0;
      if (value !== defaultValue)
        transformIsNone = false;
    } else if (isTransformOriginProp(key)) {
      transformOrigin[key] = valueAsType;
      hasTransformOrigin = true;
    } else if (key !== "transform" || typeof value !== "function") {
      var bucket = isCSSVariable(key) ? vars : style;
      if (isLayoutProjectionEnabled && valueScaleCorrection[key]) {
        var corrected = valueScaleCorrection[key].process(value, targetBox, delta2, treeScale);
        var applyTo = valueScaleCorrection[key].applyTo;
        if (applyTo) {
          var num = applyTo.length;
          for (var i = 0; i < num; i++) {
            bucket[applyTo[i]] = corrected;
          }
        } else {
          bucket[key] = corrected;
        }
      } else {
        bucket[key] = valueAsType;
      }
    }
  }
  if (isLayoutProjectionEnabled) {
    style.transform = buildLayoutProjectionTransform(deltaFinal, treeScale);
    if (style.transform === identityProjection)
      style.transform = "";
    if (hasTransform) {
      style.transform += " " + buildBoxDistortingTransforms(transform2, transformKeys2);
      style.transform = style.transform.trim();
    }
    if (transformTemplate) {
      style.transform = transformTemplate(transform2, style.transform);
    }
    style.transformOrigin = buildLayoutProjectionTransformOrigin(deltaFinal);
  } else {
    if (hasTransform) {
      style.transform = buildTransform(transform2, transformKeys2, transformTemplate, transformIsNone, enableHardwareAcceleration, allowTransformNone);
    }
    if (hasTransformOrigin) {
      style.transformOrigin = buildTransformOrigin(transformOrigin);
    }
  }
}
function resetAxis(axis, originAxis) {
  axis.min = originAxis.min;
  axis.max = originAxis.max;
}
function resetBox(box, originBox) {
  resetAxis(box.x, originBox.x);
  resetAxis(box.y, originBox.y);
}
function scalePoint(point, scale2, originPoint) {
  var distanceFromOrigin = point - originPoint;
  var scaled = scale2 * distanceFromOrigin;
  return originPoint + scaled;
}
function applyPointDelta(point, translate, scale2, originPoint, boxScale) {
  if (boxScale !== void 0) {
    point = scalePoint(point, boxScale, originPoint);
  }
  return scalePoint(point, scale2, originPoint) + translate;
}
function applyAxisDelta(axis, translate, scale2, originPoint, boxScale) {
  if (translate === void 0) {
    translate = 0;
  }
  if (scale2 === void 0) {
    scale2 = 1;
  }
  axis.min = applyPointDelta(axis.min, translate, scale2, originPoint, boxScale);
  axis.max = applyPointDelta(axis.max, translate, scale2, originPoint, boxScale);
}
function applyBoxDelta(box, _a) {
  var x = _a.x, y = _a.y;
  applyAxisDelta(box.x, x.translate, x.scale, x.originPoint);
  applyAxisDelta(box.y, y.translate, y.scale, y.originPoint);
}
function applyAxisTransforms(final, axis, transforms, _a) {
  var _b = __read(_a, 3), key = _b[0], scaleKey = _b[1], originKey = _b[2];
  final.min = axis.min;
  final.max = axis.max;
  var axisOrigin = transforms[originKey] !== void 0 ? transforms[originKey] : 0.5;
  var originPoint = mix(axis.min, axis.max, axisOrigin);
  applyAxisDelta(final, transforms[key], transforms[scaleKey], originPoint, transforms.scale);
}
var xKeys = ["x", "scaleX", "originX"];
var yKeys = ["y", "scaleY", "originY"];
function applyBoxTransforms(finalBox, box, transforms) {
  applyAxisTransforms(finalBox.x, box.x, transforms, xKeys);
  applyAxisTransforms(finalBox.y, box.y, transforms, yKeys);
}
function removePointDelta(point, translate, scale2, originPoint, boxScale) {
  point -= translate;
  point = scalePoint(point, 1 / scale2, originPoint);
  if (boxScale !== void 0) {
    point = scalePoint(point, 1 / boxScale, originPoint);
  }
  return point;
}
function removeAxisDelta(axis, translate, scale2, origin, boxScale) {
  if (translate === void 0) {
    translate = 0;
  }
  if (scale2 === void 0) {
    scale2 = 1;
  }
  if (origin === void 0) {
    origin = 0.5;
  }
  var originPoint = mix(axis.min, axis.max, origin) - translate;
  axis.min = removePointDelta(axis.min, translate, scale2, originPoint, boxScale);
  axis.max = removePointDelta(axis.max, translate, scale2, originPoint, boxScale);
}
function removeAxisTransforms(axis, transforms, _a) {
  var _b = __read(_a, 3), key = _b[0], scaleKey = _b[1], originKey = _b[2];
  removeAxisDelta(axis, transforms[key], transforms[scaleKey], transforms[originKey], transforms.scale);
}
function removeBoxTransforms(box, transforms) {
  removeAxisTransforms(box.x, transforms, xKeys);
  removeAxisTransforms(box.y, transforms, yKeys);
}
function applyTreeDeltas(box, treePath) {
  var treeLength = treePath.length;
  for (var i = 0; i < treeLength; i++) {
    applyBoxDelta(box, treePath[i].delta);
  }
}
var clampProgress = function(v) {
  return clamp2(0, 1, v);
};
function isNear(value, target2, maxDistance) {
  if (target2 === void 0) {
    target2 = 0;
  }
  if (maxDistance === void 0) {
    maxDistance = 0.01;
  }
  return distance(value, target2) < maxDistance;
}
function calcLength(axis) {
  return axis.max - axis.min;
}
function calcOrigin(source, target2) {
  var origin = 0.5;
  var sourceLength = calcLength(source);
  var targetLength = calcLength(target2);
  if (targetLength > sourceLength) {
    origin = progress(target2.min, target2.max - sourceLength, source.min);
  } else if (sourceLength > targetLength) {
    origin = progress(source.min, source.max - targetLength, target2.min);
  }
  return clampProgress(origin);
}
function updateAxisDelta(delta2, source, target2, origin) {
  delta2.origin = origin === void 0 ? calcOrigin(source, target2) : origin;
  delta2.originPoint = mix(source.min, source.max, delta2.origin);
  delta2.scale = calcLength(target2) / calcLength(source);
  if (isNear(delta2.scale, 1, 1e-4))
    delta2.scale = 1;
  delta2.translate = mix(target2.min, target2.max, delta2.origin) - delta2.originPoint;
  if (isNear(delta2.translate))
    delta2.translate = 0;
}
function updateBoxDelta(delta2, source, target2, origin) {
  updateAxisDelta(delta2.x, source.x, target2.x, origin);
  updateAxisDelta(delta2.y, source.y, target2.y, origin);
}
function updateTreeScale(treeScale, parentTreeScale, parentDelta) {
  treeScale.x = parentTreeScale.x * parentDelta.x.scale;
  treeScale.y = parentTreeScale.y * parentDelta.y.scale;
}
function eachAxis(handler) {
  return [handler("x"), handler("y")];
}
function getBoundingBox(element, transformPagePoint) {
  var box = element.getBoundingClientRect();
  return convertBoundingBoxToAxisBox(transformBoundingBox(box, transformPagePoint));
}
var positionalKeys = /* @__PURE__ */ new Set([
  "width",
  "height",
  "top",
  "left",
  "right",
  "bottom",
  "x",
  "y"
]);
var isPositionalKey = function(key) {
  return positionalKeys.has(key);
};
var hasPositionalKey = function(target2) {
  return Object.keys(target2).some(isPositionalKey);
};
var setAndResetVelocity = function(value, to) {
  value.set(to, false);
  value.set(to);
};
var isNumOrPxType = function(v) {
  return v === number || v === px;
};
var BoundingBoxDimension;
(function(BoundingBoxDimension2) {
  BoundingBoxDimension2["width"] = "width";
  BoundingBoxDimension2["height"] = "height";
  BoundingBoxDimension2["left"] = "left";
  BoundingBoxDimension2["right"] = "right";
  BoundingBoxDimension2["top"] = "top";
  BoundingBoxDimension2["bottom"] = "bottom";
})(BoundingBoxDimension || (BoundingBoxDimension = {}));
var getPosFromMatrix = function(matrix, pos) {
  return parseFloat(matrix.split(", ")[pos]);
};
var getTranslateFromMatrix = function(pos2, pos3) {
  return function(_bbox, _a) {
    var transform2 = _a.transform;
    if (transform2 === "none" || !transform2)
      return 0;
    var matrix3d = transform2.match(/^matrix3d\((.+)\)$/);
    if (matrix3d) {
      return getPosFromMatrix(matrix3d[1], pos3);
    } else {
      var matrix = transform2.match(/^matrix\((.+)\)$/);
      if (matrix) {
        return getPosFromMatrix(matrix[1], pos2);
      } else {
        return 0;
      }
    }
  };
};
var transformKeys = /* @__PURE__ */ new Set(["x", "y", "z"]);
var nonTranslationalTransformKeys = transformProps.filter(function(key) {
  return !transformKeys.has(key);
});
function removeNonTranslationalTransform(visualElement) {
  var removedTransforms = [];
  nonTranslationalTransformKeys.forEach(function(key) {
    var value = visualElement.getValue(key);
    if (value !== void 0) {
      removedTransforms.push([key, value.get()]);
      value.set(key.startsWith("scale") ? 1 : 0);
    }
  });
  if (removedTransforms.length)
    visualElement.render();
  return removedTransforms;
}
var positionalValues = {
  width: function(_a) {
    var x = _a.x;
    return x.max - x.min;
  },
  height: function(_a) {
    var y = _a.y;
    return y.max - y.min;
  },
  top: function(_bbox, _a) {
    var top = _a.top;
    return parseFloat(top);
  },
  left: function(_bbox, _a) {
    var left = _a.left;
    return parseFloat(left);
  },
  bottom: function(_a, _b) {
    var y = _a.y;
    var top = _b.top;
    return parseFloat(top) + (y.max - y.min);
  },
  right: function(_a, _b) {
    var x = _a.x;
    var left = _b.left;
    return parseFloat(left) + (x.max - x.min);
  },
  x: getTranslateFromMatrix(4, 13),
  y: getTranslateFromMatrix(5, 14)
};
var convertChangedValueTypes = function(target2, visualElement, changedKeys) {
  var originBbox = visualElement.getBoundingBox();
  var elementComputedStyle = visualElement.getComputedStyle();
  var display = elementComputedStyle.display, top = elementComputedStyle.top, left = elementComputedStyle.left, bottom = elementComputedStyle.bottom, right = elementComputedStyle.right, transform2 = elementComputedStyle.transform;
  var originComputedStyle = { top, left, bottom, right, transform: transform2 };
  if (display === "none") {
    visualElement.setStaticValues("display", target2.display || "block");
  }
  visualElement.render();
  var targetBbox = visualElement.getBoundingBox();
  changedKeys.forEach(function(key) {
    var value = visualElement.getValue(key);
    setAndResetVelocity(value, positionalValues[key](originBbox, originComputedStyle));
    target2[key] = positionalValues[key](targetBbox, elementComputedStyle);
  });
  return target2;
};
var checkAndConvertChangedValueTypes = function(visualElement, target2, origin, transitionEnd) {
  if (origin === void 0) {
    origin = {};
  }
  if (transitionEnd === void 0) {
    transitionEnd = {};
  }
  target2 = __assign({}, target2);
  transitionEnd = __assign({}, transitionEnd);
  var targetPositionalKeys = Object.keys(target2).filter(isPositionalKey);
  var removedTransformValues = [];
  var hasAttemptedToRemoveTransformValues = false;
  var changedValueTypeKeys = [];
  targetPositionalKeys.forEach(function(key) {
    var value = visualElement.getValue(key);
    if (!visualElement.hasValue(key))
      return;
    var from = origin[key];
    var to = target2[key];
    var fromType = findDimensionValueType(from);
    var toType;
    if (isKeyframesTarget(to)) {
      var numKeyframes = to.length;
      for (var i = to[0] === null ? 1 : 0; i < numKeyframes; i++) {
        if (!toType) {
          toType = findDimensionValueType(to[i]);
          invariant(toType === fromType || isNumOrPxType(fromType) && isNumOrPxType(toType), "Keyframes must be of the same dimension as the current value");
        } else {
          invariant(findDimensionValueType(to[i]) === toType, "All keyframes must be of the same type");
        }
      }
    } else {
      toType = findDimensionValueType(to);
    }
    if (fromType !== toType) {
      if (isNumOrPxType(fromType) && isNumOrPxType(toType)) {
        var current = value.get();
        if (typeof current === "string") {
          value.set(parseFloat(current));
        }
        if (typeof to === "string") {
          target2[key] = parseFloat(to);
        } else if (Array.isArray(to) && toType === px) {
          target2[key] = to.map(parseFloat);
        }
      } else if ((fromType === null || fromType === void 0 ? void 0 : fromType.transform) && (toType === null || toType === void 0 ? void 0 : toType.transform) && (from === 0 || to === 0)) {
        if (from === 0) {
          value.set(toType.transform(from));
        } else {
          target2[key] = fromType.transform(to);
        }
      } else {
        if (!hasAttemptedToRemoveTransformValues) {
          removedTransformValues = removeNonTranslationalTransform(visualElement);
          hasAttemptedToRemoveTransformValues = true;
        }
        changedValueTypeKeys.push(key);
        transitionEnd[key] = transitionEnd[key] !== void 0 ? transitionEnd[key] : target2[key];
        setAndResetVelocity(value, to);
      }
    }
  });
  if (changedValueTypeKeys.length) {
    var convertedTarget = convertChangedValueTypes(target2, visualElement, changedValueTypeKeys);
    if (removedTransformValues.length) {
      removedTransformValues.forEach(function(_a) {
        var _b = __read(_a, 2), key = _b[0], value = _b[1];
        visualElement.getValue(key).set(value);
      });
    }
    visualElement.render();
    return { target: convertedTarget, transitionEnd };
  } else {
    return { target: target2, transitionEnd };
  }
};
function unitConversion(visualElement, target2, origin, transitionEnd) {
  return hasPositionalKey(target2) ? checkAndConvertChangedValueTypes(visualElement, target2, origin, transitionEnd) : { target: target2, transitionEnd };
}
var parseDomVariant = function(visualElement, target2, origin, transitionEnd) {
  var resolved = resolveCSSVariables(visualElement, target2, transitionEnd);
  target2 = resolved.target;
  transitionEnd = resolved.transitionEnd;
  return unitConversion(visualElement, target2, origin, transitionEnd);
};
var HTMLVisualElement = function(_super) {
  __extends(HTMLVisualElement2, _super);
  function HTMLVisualElement2() {
    var _this = _super !== null && _super.apply(this, arguments) || this;
    _this.defaultConfig = {
      enableHardwareAcceleration: true,
      allowTransformNone: true
    };
    _this.style = {};
    _this.reactStyle = {};
    _this.vars = {};
    _this.transform = {};
    _this.transformOrigin = {};
    _this.transformKeys = [];
    _this.config = _this.defaultConfig;
    _this.isLayoutProjectionEnabled = false;
    _this.layoutUpdateListeners = new SubscriptionManager();
    _this.layoutMeasureListeners = new SubscriptionManager();
    _this.viewportBoxUpdateListeners = new SubscriptionManager();
    _this.hasViewportBoxUpdated = false;
    _this.targetBoxFinal = axisBox();
    _this.treeScale = { x: 1, y: 1 };
    _this.prevTreeScale = { x: 1, y: 1 };
    _this.delta = delta();
    _this.deltaFinal = delta();
    _this.deltaTransform = identityProjection;
    _this.stopLayoutAxisAnimation = {
      x: function() {
      },
      y: function() {
      }
    };
    _this.isTargetBoxLocked = false;
    _this.axisProgress = {
      x: motionValue(0),
      y: motionValue(0)
    };
    _this.updateLayoutDelta = function() {
      _this.isLayoutProjectionEnabled && _this.box && _this.updateLayoutDeltas();
      _this.children.forEach(fireUpdateLayoutDelta);
    };
    return _this;
  }
  HTMLVisualElement2.prototype.removeValue = function(key) {
    _super.prototype.removeValue.call(this, key);
    delete this.vars[key];
    delete this.style[key];
  };
  HTMLVisualElement2.prototype.clean = function() {
    this.style = {};
    this.vars = {};
    this.transform = {};
  };
  HTMLVisualElement2.prototype.updateConfig = function(config) {
    if (config === void 0) {
      config = {};
    }
    this.config = __assign(__assign({}, this.defaultConfig), config);
  };
  HTMLVisualElement2.prototype.read = function(key) {
    return this.getComputedStyle()[key] || 0;
  };
  HTMLVisualElement2.prototype.addValue = function(key, value) {
    _super.prototype.addValue.call(this, key, value);
    if (key.startsWith("rotate"))
      this.layoutOrigin = 0.5;
  };
  HTMLVisualElement2.prototype.readNativeValue = function(key) {
    if (isTransformProp(key)) {
      var defaultValueType = getDefaultValueType(key);
      return defaultValueType ? defaultValueType.default || 0 : 0;
    } else {
      return this.read(key);
    }
  };
  HTMLVisualElement2.prototype.makeTargetAnimatable = function(_a, parseDOMValues) {
    if (parseDOMValues === void 0) {
      parseDOMValues = true;
    }
    var transition = _a.transition, transitionEnd = _a.transitionEnd, target2 = __rest(_a, ["transition", "transitionEnd"]);
    var transformValues = this.config.transformValues;
    var origin = getOrigin(target2, transition || {}, this);
    if (transformValues) {
      if (transitionEnd)
        transitionEnd = transformValues(transitionEnd);
      if (target2)
        target2 = transformValues(target2);
      if (origin)
        origin = transformValues(origin);
    }
    if (parseDOMValues) {
      checkTargetForNewValues(this, target2, origin);
      var parsed = parseDomVariant(this, target2, origin, transitionEnd);
      transitionEnd = parsed.transitionEnd;
      target2 = parsed.target;
    }
    return __assign({
      transition,
      transitionEnd
    }, target2);
  };
  HTMLVisualElement2.prototype.enableLayoutProjection = function() {
    this.isLayoutProjectionEnabled = true;
  };
  HTMLVisualElement2.prototype.hide = function() {
    if (this.isVisible === false)
      return;
    this.isVisible = false;
    this.scheduleRender();
  };
  HTMLVisualElement2.prototype.show = function() {
    if (this.isVisible === true)
      return;
    this.isVisible = true;
    this.scheduleRender();
  };
  HTMLVisualElement2.prototype.onLayoutUpdate = function(callback) {
    return this.layoutUpdateListeners.add(callback);
  };
  HTMLVisualElement2.prototype.onLayoutMeasure = function(callback) {
    return this.layoutMeasureListeners.add(callback);
  };
  HTMLVisualElement2.prototype.onViewportBoxUpdate = function(callback) {
    return this.viewportBoxUpdateListeners.add(callback);
  };
  HTMLVisualElement2.prototype.layoutReady = function(config) {
    this.layoutUpdateListeners.notify(this.box, this.prevViewportBox || this.box, config);
  };
  HTMLVisualElement2.prototype.getBoundingBox = function() {
    var transformPagePoint = this.config.transformPagePoint;
    return getBoundingBox(this.element, transformPagePoint);
  };
  HTMLVisualElement2.prototype.getBoundingBoxWithoutTransforms = function() {
    var bbox = this.getBoundingBox();
    removeBoxTransforms(bbox, this.latest);
    return bbox;
  };
  HTMLVisualElement2.prototype.getComputedStyle = function() {
    return window.getComputedStyle(this.element);
  };
  HTMLVisualElement2.prototype.snapshotBoundingBox = function() {
    this.prevViewportBox = this.getBoundingBoxWithoutTransforms();
    this.rebaseTargetBox(false, this.prevViewportBox);
  };
  HTMLVisualElement2.prototype.rebaseTargetBox = function(force, box) {
    var _this = this;
    if (force === void 0) {
      force = false;
    }
    if (box === void 0) {
      box = this.box;
    }
    var _a = this.axisProgress, x = _a.x, y = _a.y;
    var shouldRebase = this.box && !this.isTargetBoxLocked && !x.isAnimating() && !y.isAnimating();
    if (force || shouldRebase) {
      eachAxis(function(axis) {
        var _a2 = box[axis], min = _a2.min, max = _a2.max;
        _this.setAxisTarget(axis, min, max);
      });
    }
  };
  HTMLVisualElement2.prototype.measureLayout = function() {
    var _this = this;
    this.box = this.getBoundingBox();
    this.boxCorrected = copyAxisBox(this.box);
    if (!this.targetBox)
      this.targetBox = copyAxisBox(this.box);
    this.layoutMeasureListeners.notify(this.box, this.prevViewportBox || this.box);
    framesync_es_default.update(function() {
      return _this.rebaseTargetBox();
    });
  };
  HTMLVisualElement2.prototype.lockTargetBox = function() {
    this.isTargetBoxLocked = true;
  };
  HTMLVisualElement2.prototype.unlockTargetBox = function() {
    this.stopLayoutAnimation();
    this.isTargetBoxLocked = false;
  };
  HTMLVisualElement2.prototype.resetTransform = function() {
    var transformTemplate = this.config.transformTemplate;
    this.element.style.transform = transformTemplate ? transformTemplate({}, "") : "none";
    this.scheduleRender();
  };
  HTMLVisualElement2.prototype.setAxisTarget = function(axis, min, max) {
    var targetAxis = this.targetBox[axis];
    targetAxis.min = min;
    targetAxis.max = max;
    this.hasViewportBoxUpdated = true;
    this.rootParent.scheduleUpdateLayoutDelta();
  };
  HTMLVisualElement2.prototype.startLayoutAxisAnimation = function(axis, transition) {
    var _this = this;
    var _a;
    var progress2 = this.axisProgress[axis];
    var _b = this.targetBox[axis], min = _b.min, max = _b.max;
    var length = max - min;
    progress2.clearListeners();
    progress2.set(min);
    progress2.set(min);
    progress2.onChange(function(v) {
      return _this.setAxisTarget(axis, v, v + length);
    });
    return (_a = this.animateMotionValue) === null || _a === void 0 ? void 0 : _a.call(this, axis, progress2, 0, transition);
  };
  HTMLVisualElement2.prototype.stopLayoutAnimation = function() {
    var _this = this;
    eachAxis(function(axis) {
      return _this.axisProgress[axis].stop();
    });
  };
  HTMLVisualElement2.prototype.updateLayoutDeltas = function() {
    resetBox(this.boxCorrected, this.box);
    if (this.parent) {
      this.prevTreeScale.x = this.treeScale.x;
      this.prevTreeScale.y = this.treeScale.y;
      updateTreeScale(this.treeScale, this.parent.treeScale, this.parent.delta);
    }
    applyTreeDeltas(this.boxCorrected, this.treePath);
    updateBoxDelta(this.delta, this.boxCorrected, this.targetBox, this.layoutOrigin);
    this.hasViewportBoxUpdated && this.viewportBoxUpdateListeners.notify(this.targetBox, this.delta);
    this.hasViewportBoxUpdated = false;
    var deltaTransform = buildLayoutProjectionTransform(this.delta, this.treeScale);
    if (deltaTransform !== this.deltaTransform || this.prevTreeScale.x !== this.treeScale.x || this.prevTreeScale.y !== this.treeScale.y) {
      this.scheduleRender();
    }
    this.deltaTransform = deltaTransform;
  };
  HTMLVisualElement2.prototype.updateTransformDeltas = function() {
    if (!this.isLayoutProjectionEnabled || !this.box)
      return;
    applyBoxTransforms(this.targetBoxFinal, this.targetBox, this.latest);
    updateBoxDelta(this.deltaFinal, this.boxCorrected, this.targetBoxFinal, this.layoutOrigin);
  };
  HTMLVisualElement2.prototype.build = function() {
    this.updateTransformDeltas();
    if (this.isVisible !== void 0) {
      this.style.visibility = this.isVisible ? "visible" : "hidden";
    }
    buildHTMLStyles(this.latest, this.style, this.vars, this.transform, this.transformOrigin, this.transformKeys, this.config, this.isLayoutProjectionEnabled && !!this.box, this.delta, this.deltaFinal, this.treeScale, this.targetBoxFinal);
  };
  HTMLVisualElement2.prototype.render = function() {
    this.build();
    Object.assign(this.element.style, this.style);
    for (var key in this.vars) {
      this.element.style.setProperty(key, this.vars[key]);
    }
  };
  return HTMLVisualElement2;
}(VisualElement);
var fireUpdateLayoutDelta = function(child) {
  return child.updateLayoutDelta();
};
function useConstant(init) {
  var ref = (0, import_react.useRef)(null);
  if (ref.current === null) {
    ref.current = init();
  }
  return ref.current;
}
function calcOrigin$1(origin, offset, size) {
  return typeof origin === "string" ? origin : px.transform(offset + size * origin);
}
function calcSVGTransformOrigin(dimensions, originX, originY) {
  var pxOriginX = calcOrigin$1(originX, dimensions.x, dimensions.width);
  var pxOriginY = calcOrigin$1(originY, dimensions.y, dimensions.height);
  return pxOriginX + " " + pxOriginY;
}
var progressToPixels = function(progress2, length) {
  return px.transform(progress2 * length);
};
var dashKeys = {
  offset: "stroke-dashoffset",
  array: "stroke-dasharray"
};
var camelKeys = {
  offset: "strokeDashoffset",
  array: "strokeDasharray"
};
function buildSVGPath(attrs, totalLength, length, spacing, offset, useDashCase) {
  if (spacing === void 0) {
    spacing = 1;
  }
  if (offset === void 0) {
    offset = 0;
  }
  if (useDashCase === void 0) {
    useDashCase = true;
  }
  var keys = useDashCase ? dashKeys : camelKeys;
  attrs[keys.offset] = progressToPixels(-offset, totalLength);
  var pathLength = progressToPixels(length, totalLength);
  var pathSpacing = progressToPixels(spacing, totalLength);
  attrs[keys.array] = pathLength + " " + pathSpacing;
}
var unmeasured = { x: 0, y: 0, width: 0, height: 0 };
function buildSVGAttrs(_a, style, vars, attrs, transform2, transformOrigin, transformKeys2, config, dimensions, totalPathLength, isLayoutProjectionEnabled, delta2, deltaFinal, treeScale, targetBox) {
  var attrX = _a.attrX, attrY = _a.attrY, originX = _a.originX, originY = _a.originY, pathLength = _a.pathLength, _b = _a.pathSpacing, pathSpacing = _b === void 0 ? 1 : _b, _c = _a.pathOffset, pathOffset = _c === void 0 ? 0 : _c, latest = __rest(_a, ["attrX", "attrY", "originX", "originY", "pathLength", "pathSpacing", "pathOffset"]);
  buildHTMLStyles(latest, attrs, vars, transform2, transformOrigin, transformKeys2, config, isLayoutProjectionEnabled, delta2, deltaFinal, treeScale, targetBox);
  if (attrs.transform) {
    style.transform = attrs.transform;
    delete attrs.transform;
  }
  if (originX !== void 0 || originY !== void 0 || style.transform) {
    style.transformOrigin = calcSVGTransformOrigin(dimensions || unmeasured, originX !== void 0 ? originX : 0.5, originY !== void 0 ? originY : 0.5);
  }
  if (attrX !== void 0)
    attrs.x = attrX;
  if (attrY !== void 0)
    attrs.y = attrY;
  if (totalPathLength !== void 0 && pathLength !== void 0) {
    buildSVGPath(attrs, totalPathLength, pathLength, pathSpacing, pathOffset, false);
  }
  return attrs;
}
var camelCaseAttributes = /* @__PURE__ */ new Set([
  "baseFrequency",
  "diffuseConstant",
  "kernelMatrix",
  "kernelUnitLength",
  "keySplines",
  "keyTimes",
  "limitingConeAngle",
  "markerHeight",
  "markerWidth",
  "numOctaves",
  "targetX",
  "targetY",
  "surfaceScale",
  "specularConstant",
  "specularExponent",
  "stdDeviation",
  "tableValues",
  "viewBox"
]);
var CAMEL_CASE_PATTERN = /([a-z])([A-Z])/g;
var REPLACE_TEMPLATE = "$1-$2";
var camelToDash = function(str) {
  return str.replace(CAMEL_CASE_PATTERN, REPLACE_TEMPLATE).toLowerCase();
};
var SVGVisualElement = function(_super) {
  __extends(SVGVisualElement2, _super);
  function SVGVisualElement2() {
    var _this = _super !== null && _super.apply(this, arguments) || this;
    _this.attrs = {};
    _this.defaultConfig = {
      enableHardwareAcceleration: false
    };
    _this.config = _this.defaultConfig;
    return _this;
  }
  SVGVisualElement2.prototype.mount = function(element) {
    _super.prototype.mount.call(this, element);
    this.measure();
  };
  SVGVisualElement2.prototype.measure = function() {
    try {
      this.dimensions = typeof this.element.getBBox === "function" ? this.element.getBBox() : this.element.getBoundingClientRect();
    } catch (e) {
      this.dimensions = { x: 0, y: 0, width: 0, height: 0 };
    }
    if (isPath(this.element)) {
      this.totalPathLength = this.element.getTotalLength();
    }
  };
  SVGVisualElement2.prototype.clean = function() {
    _super.prototype.clean.call(this);
    this.attrs = {};
  };
  SVGVisualElement2.prototype.read = function(key) {
    key = !camelCaseAttributes.has(key) ? camelToDash(key) : key;
    return this.element.getAttribute(key);
  };
  SVGVisualElement2.prototype.build = function() {
    this.updateTransformDeltas();
    buildSVGAttrs(this.latest, this.style, this.vars, this.attrs, this.transform, this.transformOrigin, this.transformKeys, this.config, this.dimensions, this.totalPathLength, this.isLayoutProjectionEnabled && !!this.box, this.delta, this.deltaFinal, this.treeScale, this.targetBoxFinal);
  };
  SVGVisualElement2.prototype.render = function() {
    _super.prototype.render.call(this);
    for (var key in this.attrs) {
      this.element.setAttribute(!camelCaseAttributes.has(key) ? camelToDash(key) : key, this.attrs[key]);
    }
  };
  return SVGVisualElement2;
}(HTMLVisualElement);
function isPath(element) {
  return element.tagName === "path";
}
var svgElements = [
  "animate",
  "circle",
  "clipPath",
  "defs",
  "desc",
  "ellipse",
  "feBlend",
  "feColorMatrix",
  "feComponentTransfer",
  "feComposite",
  "feConvolveMatrix",
  "feDiffuseLighting",
  "feDisplacementMap",
  "feDistantLight",
  "feDropShadow",
  "feFlood",
  "feFuncA",
  "feFuncB",
  "feFuncG",
  "feFuncR",
  "feGaussianBlur",
  "feImage",
  "feMerge",
  "feMergeNode",
  "feMorphology",
  "feOffset",
  "fePointLight",
  "feSpecularLighting",
  "feSpotLight",
  "feTile",
  "feTurbulence",
  "filter",
  "foreignObject",
  "g",
  "image",
  "line",
  "linearGradient",
  "marker",
  "mask",
  "metadata",
  "path",
  "pattern",
  "polygon",
  "polyline",
  "radialGradient",
  "rect",
  "stop",
  "svg",
  "switch",
  "symbol",
  "text",
  "textPath",
  "tspan",
  "use",
  "view"
];
var svgTagNames = new Set(svgElements);
function isSVGComponent(Component2) {
  return typeof Component2 === "string" && svgTagNames.has(Component2);
}
var PresenceContext = (0, import_react.createContext)(null);
var MotionContext = (0, import_react.createContext)({
  variantContext: {}
});
function useVariantContext() {
  return (0, import_react.useContext)(MotionContext).variantContext;
}
function useVisualElementContext() {
  return (0, import_react.useContext)(MotionContext).visualElement;
}
var useDomVisualElement = function(Component2, props, isStatic, ref) {
  var parent = useVisualElementContext();
  var visualElement = useConstant(function() {
    var DOMVisualElement = isSVGComponent(Component2) ? SVGVisualElement : HTMLVisualElement;
    return new DOMVisualElement(parent, ref);
  });
  visualElement.updateConfig(__assign(__assign(__assign({}, visualElement.config), { enableHardwareAcceleration: !isStatic }), props));
  visualElement.layoutId = props.layoutId;
  var presenceContext = (0, import_react.useContext)(PresenceContext);
  var isPresent2 = presenceContext === null ? true : presenceContext.isPresent;
  visualElement.isPresent = props.isPresent !== void 0 ? props.isPresent : isPresent2;
  var presenceId2 = presenceContext === null || presenceContext === void 0 ? void 0 : presenceContext.id;
  visualElement.isPresenceRoot = !parent || parent.presenceId !== presenceId2;
  (0, import_react.useEffect)(function() {
    if (props.onViewportBoxUpdate) {
      return visualElement.onViewportBoxUpdate(props.onViewportBoxUpdate);
    }
  }, [props.onViewportBoxUpdate]);
  return visualElement;
};
var validMotionProps = /* @__PURE__ */ new Set([
  "initial",
  "animate",
  "exit",
  "style",
  "variants",
  "transition",
  "transformTemplate",
  "transformValues",
  "custom",
  "inherit",
  "layout",
  "layoutId",
  "onLayoutAnimationComplete",
  "onViewportBoxUpdate",
  "onAnimationStart",
  "onAnimationComplete",
  "onUpdate",
  "onDragStart",
  "onDrag",
  "onDragEnd",
  "onMeasureDragConstraints",
  "onDirectionLock",
  "onDragTransitionEnd",
  "drag",
  "dragControls",
  "dragListener",
  "dragConstraints",
  "dragDirectionLock",
  "_dragX",
  "_dragY",
  "dragElastic",
  "dragMomentum",
  "dragPropagation",
  "dragTransition",
  "onPan",
  "onPanStart",
  "onPanEnd",
  "onPanSessionStart",
  "onTap",
  "onTapStart",
  "onTapCancel",
  "whileHover",
  "whileTap",
  "onHoverEnd",
  "onHoverStart"
]);
function isValidMotionProp(key) {
  return validMotionProps.has(key);
}
var isPropValid = function(key) {
  return !isValidMotionProp(key);
};
try {
  emotionIsPropValid_1 = (init_is_prop_valid_browser_esm(), __toCommonJS(is_prop_valid_browser_esm_exports)).default;
  isPropValid = function(key) {
    if (key.startsWith("on")) {
      return !isValidMotionProp(key);
    } else {
      return emotionIsPropValid_1(key);
    }
  };
} catch (_a) {
}
var emotionIsPropValid_1;
function filterProps(props) {
  var domProps = {};
  for (var key in props) {
    if (isPropValid(key))
      domProps[key] = props[key];
  }
  return domProps;
}
function buildHTMLProps(visualElement, _a) {
  var drag = _a.drag;
  var htmlProps = {
    style: __assign(__assign(__assign({}, visualElement.reactStyle), visualElement.style), visualElement.vars)
  };
  if (!!drag) {
    htmlProps.draggable = false;
    htmlProps.style.userSelect = "none";
    htmlProps.style.touchAction = drag === true ? "none" : "pan-" + (drag === "x" ? "y" : "x");
  }
  return htmlProps;
}
function buildSVGProps(visualElement) {
  return __assign(__assign({}, visualElement.attrs), { style: __assign({}, visualElement.reactStyle) });
}
function render(Component2, props, visualElement) {
  var forwardedProps = typeof Component2 === "string" ? filterProps(props) : props;
  visualElement.clean();
  visualElement.build();
  var visualProps = isSVGComponent(Component2) ? buildSVGProps(visualElement) : buildHTMLProps(visualElement, props);
  return (0, import_react.createElement)(Component2, __assign(__assign(__assign({}, forwardedProps), { ref: visualElement.ref }), visualProps));
}
var isMotionValue = function(value) {
  return value instanceof MotionValue;
};
function isForcedMotionValue(key, _a) {
  var layout = _a.layout, layoutId = _a.layoutId;
  return isTransformProp(key) || isTransformOriginProp(key) || (layout || layoutId !== void 0) && !!valueScaleCorrection[key];
}
function useMotionValues(visualElement, props) {
  var prev = useConstant(empty);
  for (var key in prev) {
    var isForced = isForcedMotionValue(key, props);
    var existsAsProp = props[key] !== void 0;
    var existsAsStyle = props.style && props.style[key] !== void 0;
    var propIsMotionValue = existsAsProp && isMotionValue(props[key]);
    var styleIsMotionValue = existsAsStyle && isMotionValue(props.style[key]);
    var transformRemoved = isForced && !existsAsProp && !existsAsStyle;
    var motionValueRemoved = !isForced && !propIsMotionValue && !styleIsMotionValue;
    if (transformRemoved || motionValueRemoved) {
      visualElement.removeValue(key);
      delete prev[key];
    }
  }
  addMotionValues(visualElement, prev, props, false, props);
  if (props.style)
    addMotionValues(visualElement, prev, props.style, true, props);
  if (props.transformValues) {
    visualElement.reactStyle = props.transformValues(visualElement.reactStyle);
  }
}
function addMotionValues(visualElement, prev, source, isStyle, props) {
  if (isStyle === void 0) {
    isStyle = false;
  }
  if (isStyle)
    visualElement.reactStyle = {};
  for (var key in source) {
    var value = source[key];
    var foundMotionValue = false;
    if (isMotionValue(value)) {
      if (!reservedNames.has(key)) {
        visualElement.addValue(key, value);
        foundMotionValue = true;
      }
    } else if (isForcedMotionValue(key, props)) {
      if (!visualElement.hasValue(key)) {
        visualElement.addValue(key, motionValue(value));
      } else if (value !== prev[key]) {
        if (isMotionValue(prev[key])) {
          visualElement.addValue(key, motionValue(value));
        } else {
          var motion2 = visualElement.getValue(key);
          motion2.set(value);
        }
      }
      foundMotionValue = true;
    } else if (isStyle) {
      visualElement.reactStyle[key] = value;
    }
    if (foundMotionValue)
      prev[key] = value;
  }
}
var reservedNames = /* @__PURE__ */ new Set([]);
var empty = function() {
  return {};
};
var MotionConfigContext = (0, import_react.createContext)({
  transformPagePoint: function(p) {
    return p;
  },
  features: [],
  isStatic: false
});
function MotionConfig(_a) {
  var children = _a.children, _b = _a.features, features = _b === void 0 ? [] : _b, props = __rest(_a, ["children", "features"]);
  var pluginContext = (0, import_react.useContext)(MotionConfigContext);
  var loadedFeatures = __spread(pluginContext.features, features);
  var value = (0, import_react.useMemo)(function() {
    return { features: loadedFeatures };
  }, [
    loadedFeatures.length
  ]);
  for (var key in props) {
    value[key] = props[key];
  }
  return (0, import_react.createElement)(MotionConfigContext.Provider, { value }, children);
}
function checkShouldInheritVariant(_a) {
  var animate3 = _a.animate, variants = _a.variants, inherit = _a.inherit;
  return inherit === void 0 ? !!variants && !animate3 : inherit;
}
function useFeatures(defaultFeatures, isStatic, visualElement, props) {
  var plugins = (0, import_react.useContext)(MotionConfigContext);
  if (isStatic || typeof window === "undefined")
    return null;
  var allFeatures = __spread(defaultFeatures, plugins.features);
  var numFeatures = allFeatures.length;
  var features = [];
  for (var i = 0; i < numFeatures; i++) {
    var _a = allFeatures[i], shouldRender = _a.shouldRender, key = _a.key, getComponent = _a.getComponent;
    if (shouldRender(props)) {
      var Component2 = getComponent(props);
      Component2 && features.push((0, import_react.createElement)(Component2, __assign({ key }, props, { visualElement, inherit: checkShouldInheritVariant(props) })));
    }
  }
  return features;
}
var Presence;
(function(Presence2) {
  Presence2[Presence2["Entering"] = 0] = "Entering";
  Presence2[Presence2["Present"] = 1] = "Present";
  Presence2[Presence2["Exiting"] = 2] = "Exiting";
})(Presence || (Presence = {}));
var VisibilityAction;
(function(VisibilityAction2) {
  VisibilityAction2[VisibilityAction2["Hide"] = 0] = "Hide";
  VisibilityAction2[VisibilityAction2["Show"] = 1] = "Show";
})(VisibilityAction || (VisibilityAction = {}));
var defaultHandler = {
  measureLayout: function(child) {
    return child.measureLayout();
  },
  layoutReady: function(child) {
    return child.layoutReady();
  }
};
var sortByDepth = function(a2, b2) {
  return a2.depth - b2.depth;
};
function createBatcher() {
  var queue = /* @__PURE__ */ new Set();
  var add = function(child) {
    return queue.add(child);
  };
  var flush = function(_a) {
    var _b = _a === void 0 ? defaultHandler : _a, measureLayout = _b.measureLayout, layoutReady = _b.layoutReady;
    var order2 = Array.from(queue).sort(sortByDepth);
    order2.forEach(function(child) {
      return child.resetTransform();
    });
    order2.forEach(measureLayout);
    order2.forEach(layoutReady);
    order2.forEach(function(child) {
      if (child.isPresent)
        child.presence = Presence.Present;
    });
    queue.clear();
  };
  return { add, flush };
}
function isSharedLayout(context) {
  return !!context.forceUpdate;
}
var SharedLayoutContext = (0, import_react.createContext)(createBatcher());
var FramerTreeLayoutContext = (0, import_react.createContext)(createBatcher());
var isBrowser = typeof window !== "undefined";
var useIsomorphicLayoutEffect = isBrowser ? import_react.useLayoutEffect : import_react.useEffect;
function useSnapshotOnUnmount(visualElement) {
  var syncLayout = (0, import_react.useContext)(SharedLayoutContext);
  var framerSyncLayout = (0, import_react.useContext)(FramerTreeLayoutContext);
  useIsomorphicLayoutEffect(function() {
    return function() {
      if (isSharedLayout(syncLayout)) {
        syncLayout.remove(visualElement);
      }
      if (isSharedLayout(framerSyncLayout)) {
        framerSyncLayout.remove(visualElement);
      }
    };
  }, []);
}
function usePresence() {
  var context = (0, import_react.useContext)(PresenceContext);
  if (context === null)
    return [true, null];
  var isPresent2 = context.isPresent, onExitComplete = context.onExitComplete, register = context.register;
  var id = useUniqueId();
  (0, import_react.useEffect)(function() {
    return register(id);
  }, []);
  var safeToRemove = function() {
    return onExitComplete === null || onExitComplete === void 0 ? void 0 : onExitComplete(id);
  };
  return !isPresent2 && onExitComplete ? [false, safeToRemove] : [true];
}
function useIsPresent() {
  return isPresent((0, import_react.useContext)(PresenceContext));
}
function isPresent(context) {
  return context === null ? true : context.isPresent;
}
var counter = 0;
var incrementId = function() {
  return counter++;
};
var useUniqueId = function() {
  return useConstant(incrementId);
};
function useInitialOrEveryRender(callback, isInitialOnly) {
  if (isInitialOnly === void 0) {
    isInitialOnly = false;
  }
  var isInitialRender = (0, import_react.useRef)(true);
  if (!isInitialOnly || isInitialOnly && isInitialRender.current) {
    callback();
  }
  isInitialRender.current = false;
}
function useVariants(visualElement, _a, isStatic) {
  var _b, _c;
  var variants = _a.variants, initial = _a.initial, animate3 = _a.animate, whileTap = _a.whileTap, whileHover = _a.whileHover;
  var _d = useVariantContext(), parent = _d.parent, parentInitial = _d.initial, parentAnimate = _d.animate;
  var presenceContext = (0, import_react.useContext)(PresenceContext);
  var controlsVariants = isVariantLabel$1(animate3) || isVariantLabel$1(whileTap) || isVariantLabel$1(whileHover) || isAnimationControls(animate3);
  var isVariantNode = variants || controlsVariants;
  initial = (_b = presenceContext === null || presenceContext === void 0 ? void 0 : presenceContext.initial) !== null && _b !== void 0 ? _b : initial;
  if (initial === false && !isAnimationControls(animate3)) {
    initial = animate3;
  }
  var context = (0, import_react.useMemo)(
    function() {
      return {
        parent: isVariantNode ? visualElement : parent,
        initial: isVariantLabel$1(initial) ? initial : parentInitial,
        animate: isVariantLabel$1(animate3) ? animate3 : parentAnimate
      };
    },
    [isStatic ? initial : null]
  );
  useInitialOrEveryRender(function() {
    var initialToApply = initial || parentInitial;
    initialToApply && setValues(visualElement, initialToApply);
  }, !isStatic);
  isVariantNode && !controlsVariants && (parent === null || parent === void 0 ? void 0 : parent.addVariantChild(visualElement));
  isPresent(presenceContext) && ((_c = visualElement.variantChildrenOrder) === null || _c === void 0 ? void 0 : _c.clear());
  (0, import_react.useEffect)(function() {
    isVariantNode && (parent === null || parent === void 0 ? void 0 : parent.addVariantChildOrder(visualElement));
  });
  (0, import_react.useEffect)(function() {
    visualElement.isMounted = true;
    return function() {
      var _a2;
      visualElement.isMounted = false;
      (_a2 = parent === null || parent === void 0 ? void 0 : parent.variantChildren) === null || _a2 === void 0 ? void 0 : _a2.delete(visualElement);
    };
  }, []);
  useInitialOrEveryRender(function() {
    visualElement.forEachValue(function(value, key) {
      visualElement.baseTarget[key] = value.get();
    });
  }, true);
  return context;
}
function isVariantLabel$1(v) {
  return typeof v === "string" || Array.isArray(v);
}
function isAnimationControls(v) {
  return typeof v === "object" && typeof v.start === "function";
}
function createMotionComponent(Component2, _a) {
  var defaultFeatures = _a.defaultFeatures, useVisualElement = _a.useVisualElement, render2 = _a.render;
  function MotionComponent(props, externalRef) {
    var isStatic = (0, import_react.useContext)(MotionConfigContext).isStatic;
    var visualElement = useVisualElement(Component2, props, isStatic, externalRef);
    useMotionValues(visualElement, props);
    var variantContext = useVariants(visualElement, props, isStatic);
    var features = useFeatures(defaultFeatures, isStatic, visualElement, props);
    var context = (0, import_react.useMemo)(function() {
      return { visualElement, variantContext };
    }, [
      visualElement,
      variantContext
    ]);
    var component = render2(Component2, props, visualElement);
    useSnapshotOnUnmount(visualElement);
    return (0, import_react.createElement)(
      import_react.Fragment,
      null,
      (0, import_react.createElement)(MotionContext.Provider, { value: context }, component),
      features
    );
  }
  return (0, import_react.forwardRef)(MotionComponent);
}
function createLock(name) {
  var lock = null;
  return function() {
    var openLock = function() {
      lock = null;
    };
    if (lock === null) {
      lock = name;
      return openLock;
    }
    return false;
  };
}
var globalHorizontalLock = createLock("dragHorizontal");
var globalVerticalLock = createLock("dragVertical");
function getGlobalLock(drag) {
  var lock = false;
  if (drag === "y") {
    lock = globalVerticalLock();
  } else if (drag === "x") {
    lock = globalHorizontalLock();
  } else {
    var openHorizontal_1 = globalHorizontalLock();
    var openVertical_1 = globalVerticalLock();
    if (openHorizontal_1 && openVertical_1) {
      lock = function() {
        openHorizontal_1();
        openVertical_1();
      };
    } else {
      if (openHorizontal_1)
        openHorizontal_1();
      if (openVertical_1)
        openVertical_1();
    }
  }
  return lock;
}
function addDomEvent(target2, eventName, handler, options) {
  target2.addEventListener(eventName, handler, options);
  return function() {
    return target2.removeEventListener(eventName, handler, options);
  };
}
function useDomEvent(ref, eventName, handler, options) {
  (0, import_react.useEffect)(function() {
    var element = ref.current;
    if (handler && element) {
      return addDomEvent(element, eventName, handler, options);
    }
  }, [ref, eventName, handler, options]);
}
function isMouseEvent(event) {
  if (typeof PointerEvent !== "undefined" && event instanceof PointerEvent) {
    return !!(event.pointerType === "mouse");
  }
  return event instanceof MouseEvent;
}
function isTouchEvent(event) {
  var hasTouches = !!event.touches;
  return hasTouches;
}
function filterPrimaryPointer(eventHandler) {
  return function(event) {
    var isMouseEvent2 = event instanceof MouseEvent;
    var isPrimaryPointer = !isMouseEvent2 || isMouseEvent2 && event.button === 0;
    if (isPrimaryPointer) {
      eventHandler(event);
    }
  };
}
var defaultPagePoint = { pageX: 0, pageY: 0 };
function pointFromTouch(e, pointType) {
  if (pointType === void 0) {
    pointType = "page";
  }
  var primaryTouch = e.touches[0] || e.changedTouches[0];
  var point = primaryTouch || defaultPagePoint;
  return {
    x: point[pointType + "X"],
    y: point[pointType + "Y"]
  };
}
function pointFromMouse(point, pointType) {
  if (pointType === void 0) {
    pointType = "page";
  }
  return {
    x: point[pointType + "X"],
    y: point[pointType + "Y"]
  };
}
function extractEventInfo(event, pointType) {
  if (pointType === void 0) {
    pointType = "page";
  }
  return {
    point: isTouchEvent(event) ? pointFromTouch(event, pointType) : pointFromMouse(event, pointType)
  };
}
function getViewportPointFromEvent(event) {
  return extractEventInfo(event, "client");
}
var wrapHandler = function(handler, shouldFilterPrimaryPointer) {
  if (shouldFilterPrimaryPointer === void 0) {
    shouldFilterPrimaryPointer = false;
  }
  var listener = function(event) {
    return handler(event, extractEventInfo(event));
  };
  return shouldFilterPrimaryPointer ? filterPrimaryPointer(listener) : listener;
};
var isBrowser$1 = typeof window !== "undefined";
var supportsPointerEvents = function() {
  return isBrowser$1 && window.onpointerdown === null;
};
var supportsTouchEvents = function() {
  return isBrowser$1 && window.ontouchstart === null;
};
var supportsMouseEvents = function() {
  return isBrowser$1 && window.onmousedown === null;
};
var mouseEventNames = {
  pointerdown: "mousedown",
  pointermove: "mousemove",
  pointerup: "mouseup",
  pointercancel: "mousecancel",
  pointerover: "mouseover",
  pointerout: "mouseout",
  pointerenter: "mouseenter",
  pointerleave: "mouseleave"
};
var touchEventNames = {
  pointerdown: "touchstart",
  pointermove: "touchmove",
  pointerup: "touchend",
  pointercancel: "touchcancel"
};
function getPointerEventName(name) {
  if (supportsPointerEvents()) {
    return name;
  } else if (supportsTouchEvents()) {
    return touchEventNames[name];
  } else if (supportsMouseEvents()) {
    return mouseEventNames[name];
  }
  return name;
}
function addPointerEvent(target2, eventName, handler, options) {
  return addDomEvent(target2, getPointerEventName(eventName), wrapHandler(handler, eventName === "pointerdown"), options);
}
function usePointerEvent(ref, eventName, handler, options) {
  return useDomEvent(ref, getPointerEventName(eventName), handler && wrapHandler(handler, eventName === "pointerdown"), options);
}
var PanSession = function() {
  function PanSession2(event, handlers, _a) {
    var _this = this;
    var transformPagePoint = (_a === void 0 ? {} : _a).transformPagePoint;
    this.startEvent = null;
    this.lastMoveEvent = null;
    this.lastMoveEventInfo = null;
    this.handlers = {};
    this.updatePoint = function() {
      if (!(_this.lastMoveEvent && _this.lastMoveEventInfo))
        return;
      var info2 = getPanInfo(_this.lastMoveEventInfo, _this.history);
      var isPanStarted = _this.startEvent !== null;
      var isDistancePastThreshold = distance(info2.offset, { x: 0, y: 0 }) >= 3;
      if (!isPanStarted && !isDistancePastThreshold)
        return;
      var point2 = info2.point;
      var timestamp2 = getFrameData().timestamp;
      _this.history.push(__assign(__assign({}, point2), { timestamp: timestamp2 }));
      var _a2 = _this.handlers, onStart = _a2.onStart, onMove = _a2.onMove;
      if (!isPanStarted) {
        onStart && onStart(_this.lastMoveEvent, info2);
        _this.startEvent = _this.lastMoveEvent;
      }
      onMove && onMove(_this.lastMoveEvent, info2);
    };
    this.handlePointerMove = function(event2, info2) {
      _this.lastMoveEvent = event2;
      _this.lastMoveEventInfo = transformPoint(info2, _this.transformPagePoint);
      if (isMouseEvent(event2) && event2.buttons === 0) {
        _this.handlePointerUp(event2, info2);
        return;
      }
      framesync_es_default.update(_this.updatePoint, true);
    };
    this.handlePointerUp = function(event2, info2) {
      _this.end();
      var onEnd = _this.handlers.onEnd;
      if (!onEnd)
        return;
      var panInfo = getPanInfo(transformPoint(info2, _this.transformPagePoint), _this.history);
      onEnd && onEnd(event2, panInfo);
    };
    if (isTouchEvent(event) && event.touches.length > 1)
      return;
    this.handlers = handlers;
    this.transformPagePoint = transformPagePoint;
    var info = extractEventInfo(event);
    var initialInfo = transformPoint(info, this.transformPagePoint);
    var point = initialInfo.point;
    var timestamp = getFrameData().timestamp;
    this.history = [__assign(__assign({}, point), { timestamp })];
    var onSessionStart = handlers.onSessionStart;
    onSessionStart && onSessionStart(event, getPanInfo(initialInfo, this.history));
    this.removeListeners = pipe(addPointerEvent(window, "pointermove", this.handlePointerMove), addPointerEvent(window, "pointerup", this.handlePointerUp), addPointerEvent(window, "pointercancel", this.handlePointerUp));
  }
  PanSession2.prototype.updateHandlers = function(handlers) {
    this.handlers = handlers;
  };
  PanSession2.prototype.end = function() {
    this.removeListeners && this.removeListeners();
    cancelSync.update(this.updatePoint);
  };
  return PanSession2;
}();
function transformPoint(info, transformPagePoint) {
  return transformPagePoint ? { point: transformPagePoint(info.point) } : info;
}
function subtractPoint(a2, b2) {
  return { x: a2.x - b2.x, y: a2.y - b2.y };
}
function getPanInfo(_a, history) {
  var point = _a.point;
  return {
    point,
    delta: subtractPoint(point, lastDevicePoint(history)),
    offset: subtractPoint(point, startDevicePoint(history)),
    velocity: getVelocity$1(history, 0.1)
  };
}
function startDevicePoint(history) {
  return history[0];
}
function lastDevicePoint(history) {
  return history[history.length - 1];
}
function getVelocity$1(history, timeDelta) {
  if (history.length < 2) {
    return { x: 0, y: 0 };
  }
  var i = history.length - 1;
  var timestampedPoint = null;
  var lastPoint = lastDevicePoint(history);
  while (i >= 0) {
    timestampedPoint = history[i];
    if (lastPoint.timestamp - timestampedPoint.timestamp > secondsToMilliseconds(timeDelta)) {
      break;
    }
    i--;
  }
  if (!timestampedPoint) {
    return { x: 0, y: 0 };
  }
  var time = (lastPoint.timestamp - timestampedPoint.timestamp) / 1e3;
  if (time === 0) {
    return { x: 0, y: 0 };
  }
  var currentVelocity = {
    x: (lastPoint.x - timestampedPoint.x) / time,
    y: (lastPoint.y - timestampedPoint.y) / time
  };
  if (currentVelocity.x === Infinity) {
    currentVelocity.x = 0;
  }
  if (currentVelocity.y === Infinity) {
    currentVelocity.y = 0;
  }
  return currentVelocity;
}
function applyConstraints(point, _a, elastic) {
  var min = _a.min, max = _a.max;
  if (min !== void 0 && point < min) {
    point = elastic ? mix(min, point, elastic) : Math.max(point, min);
  } else if (max !== void 0 && point > max) {
    point = elastic ? mix(max, point, elastic) : Math.min(point, max);
  }
  return point;
}
function calcConstrainedMinPoint(point, length, progress2, constraints, elastic) {
  var min = point - length * progress2;
  return constraints ? applyConstraints(min, constraints, elastic) : min;
}
function calcRelativeAxisConstraints(axis, min, max) {
  return {
    min: min !== void 0 ? axis.min + min : void 0,
    max: max !== void 0 ? axis.max + max - (axis.max - axis.min) : void 0
  };
}
function calcRelativeConstraints(layoutBox, _a) {
  var top = _a.top, left = _a.left, bottom = _a.bottom, right = _a.right;
  return {
    x: calcRelativeAxisConstraints(layoutBox.x, left, right),
    y: calcRelativeAxisConstraints(layoutBox.y, top, bottom)
  };
}
function calcViewportAxisConstraints(layoutAxis, constraintsAxis) {
  var _a;
  var min = constraintsAxis.min - layoutAxis.min;
  var max = constraintsAxis.max - layoutAxis.max;
  if (constraintsAxis.max - constraintsAxis.min < layoutAxis.max - layoutAxis.min) {
    _a = __read([max, min], 2), min = _a[0], max = _a[1];
  }
  return {
    min: layoutAxis.min + min,
    max: layoutAxis.min + max
  };
}
function calcViewportConstraints(layoutBox, constraintsBox) {
  return {
    x: calcViewportAxisConstraints(layoutBox.x, constraintsBox.x),
    y: calcViewportAxisConstraints(layoutBox.y, constraintsBox.y)
  };
}
function calcPositionFromProgress(axis, constraints, progress2) {
  var axisLength = axis.max - axis.min;
  var min = mix(constraints.min, constraints.max - axisLength, progress2);
  return { min, max: min + axisLength };
}
function rebaseAxisConstraints(layout, constraints) {
  var relativeConstraints = {};
  if (constraints.min !== void 0) {
    relativeConstraints.min = constraints.min - layout.min;
  }
  if (constraints.max !== void 0) {
    relativeConstraints.max = constraints.max - layout.min;
  }
  return relativeConstraints;
}
var elementDragControls = /* @__PURE__ */ new WeakMap();
var lastPointerEvent;
var VisualElementDragControls = function() {
  function VisualElementDragControls2(_a) {
    var visualElement = _a.visualElement;
    this.isDragging = false;
    this.currentDirection = null;
    this.constraints = false;
    this.props = {};
    this.hasMutatedConstraints = false;
    this.cursorProgress = {
      x: 0.5,
      y: 0.5
    };
    this.originPoint = {};
    this.openGlobalLock = null;
    this.panSession = null;
    this.visualElement = visualElement;
    this.visualElement.enableLayoutProjection();
    elementDragControls.set(visualElement, this);
  }
  VisualElementDragControls2.prototype.start = function(originEvent, _a) {
    var _this = this;
    var _b = _a === void 0 ? {} : _a, _c = _b.snapToCursor, snapToCursor = _c === void 0 ? false : _c, cursorProgress = _b.cursorProgress;
    snapToCursor && this.snapToCursor(originEvent);
    var onSessionStart = function() {
      _this.stopMotion();
    };
    var onStart = function(event, info) {
      var _a2, _b2;
      var _c2 = _this.props, drag = _c2.drag, dragPropagation = _c2.dragPropagation;
      if (drag && !dragPropagation) {
        if (_this.openGlobalLock)
          _this.openGlobalLock();
        _this.openGlobalLock = getGlobalLock(drag);
        if (!_this.openGlobalLock)
          return;
      }
      _this.prepareBoundingBox();
      _this.visualElement.lockTargetBox();
      _this.resolveDragConstraints();
      var point = getViewportPointFromEvent(event).point;
      eachAxis(function(axis) {
        var _a3 = _this.visualElement.targetBox[axis], min = _a3.min, max = _a3.max;
        _this.cursorProgress[axis] = cursorProgress ? cursorProgress[axis] : progress(min, max, point[axis]);
        var axisValue = _this.getAxisMotionValue(axis);
        if (axisValue) {
          _this.originPoint[axis] = axisValue.get();
        }
      });
      _this.isDragging = true;
      _this.currentDirection = null;
      (_b2 = (_a2 = _this.props).onDragStart) === null || _b2 === void 0 ? void 0 : _b2.call(_a2, event, info);
    };
    var onMove = function(event, info) {
      var _a2, _b2, _c2, _d;
      var _e = _this.props, dragPropagation = _e.dragPropagation, dragDirectionLock = _e.dragDirectionLock;
      if (!dragPropagation && !_this.openGlobalLock)
        return;
      var offset = info.offset;
      if (dragDirectionLock && _this.currentDirection === null) {
        _this.currentDirection = getCurrentDirection(offset);
        if (_this.currentDirection !== null) {
          (_b2 = (_a2 = _this.props).onDirectionLock) === null || _b2 === void 0 ? void 0 : _b2.call(_a2, _this.currentDirection);
        }
        return;
      }
      _this.updateAxis("x", event, offset);
      _this.updateAxis("y", event, offset);
      (_d = (_c2 = _this.props).onDrag) === null || _d === void 0 ? void 0 : _d.call(_c2, event, info);
      lastPointerEvent = event;
    };
    var onEnd = function(event, info) {
      return _this.stop(event, info);
    };
    var transformPagePoint = this.props.transformPagePoint;
    this.panSession = new PanSession(originEvent, {
      onSessionStart,
      onStart,
      onMove,
      onEnd
    }, { transformPagePoint });
  };
  VisualElementDragControls2.prototype.prepareBoundingBox = function() {
    var element = this.visualElement.getInstance();
    var transform2 = element.style.transform;
    this.visualElement.resetTransform();
    this.visualElement.measureLayout();
    element.style.transform = transform2;
    this.visualElement.rebaseTargetBox(true, this.visualElement.getBoundingBoxWithoutTransforms());
  };
  VisualElementDragControls2.prototype.resolveDragConstraints = function() {
    var _this = this;
    var dragConstraints = this.props.dragConstraints;
    if (dragConstraints) {
      this.constraints = isRefObject(dragConstraints) ? this.resolveRefConstraints(this.visualElement.box, dragConstraints) : calcRelativeConstraints(this.visualElement.box, dragConstraints);
    } else {
      this.constraints = false;
    }
    if (this.constraints && !this.hasMutatedConstraints) {
      eachAxis(function(axis) {
        if (_this.getAxisMotionValue(axis)) {
          _this.constraints[axis] = rebaseAxisConstraints(_this.visualElement.box[axis], _this.constraints[axis]);
        }
      });
    }
  };
  VisualElementDragControls2.prototype.resolveRefConstraints = function(layoutBox, constraints) {
    var _a = this.props, onMeasureDragConstraints = _a.onMeasureDragConstraints, transformPagePoint = _a.transformPagePoint;
    var constraintsElement = constraints.current;
    invariant(constraintsElement !== null, "If `dragConstraints` is set as a React ref, that ref must be passed to another component's `ref` prop.");
    this.constraintsBox = getBoundingBox(constraintsElement, transformPagePoint);
    var measuredConstraints = calcViewportConstraints(layoutBox, this.constraintsBox);
    if (onMeasureDragConstraints) {
      var userConstraints = onMeasureDragConstraints(convertAxisBoxToBoundingBox(measuredConstraints));
      this.hasMutatedConstraints = !!userConstraints;
      if (userConstraints) {
        measuredConstraints = convertBoundingBoxToAxisBox(userConstraints);
      }
    }
    return measuredConstraints;
  };
  VisualElementDragControls2.prototype.cancelDrag = function() {
    this.isDragging = false;
    this.panSession && this.panSession.end();
    this.panSession = null;
    if (!this.props.dragPropagation && this.openGlobalLock) {
      this.openGlobalLock();
      this.openGlobalLock = null;
    }
  };
  VisualElementDragControls2.prototype.stop = function(event, info) {
    var _a;
    this.visualElement.unlockTargetBox();
    (_a = this.panSession) === null || _a === void 0 ? void 0 : _a.end();
    this.panSession = null;
    var isDragging = this.isDragging;
    this.cancelDrag();
    if (!isDragging)
      return;
    var _b = this.props, dragMomentum = _b.dragMomentum, dragElastic = _b.dragElastic, onDragEnd = _b.onDragEnd;
    if (dragMomentum || dragElastic) {
      var velocity = info.velocity;
      this.animateDragEnd(velocity);
    }
    onDragEnd === null || onDragEnd === void 0 ? void 0 : onDragEnd(event, info);
  };
  VisualElementDragControls2.prototype.snapToCursor = function(event) {
    var _this = this;
    this.prepareBoundingBox();
    eachAxis(function(axis) {
      var axisValue = _this.getAxisMotionValue(axis);
      if (axisValue) {
        var point = getViewportPointFromEvent(event).point;
        var box = _this.visualElement.box;
        var length_1 = box[axis].max - box[axis].min;
        var center = box[axis].min + length_1 / 2;
        var offset = point[axis] - center;
        _this.originPoint[axis] = point[axis];
        axisValue.set(offset);
      } else {
        _this.cursorProgress[axis] = 0.5;
        _this.updateVisualElementAxis(axis, event);
      }
    });
  };
  VisualElementDragControls2.prototype.updateAxis = function(axis, event, offset) {
    var drag = this.props.drag;
    if (!shouldDrag(axis, drag, this.currentDirection))
      return;
    return this.getAxisMotionValue(axis) ? this.updateAxisMotionValue(axis, offset) : this.updateVisualElementAxis(axis, event);
  };
  VisualElementDragControls2.prototype.updateAxisMotionValue = function(axis, offset) {
    var axisValue = this.getAxisMotionValue(axis);
    if (!offset || !axisValue)
      return;
    var dragElastic = this.props.dragElastic;
    var nextValue = this.originPoint[axis] + offset[axis];
    var update = this.constraints ? applyConstraints(nextValue, this.constraints[axis], dragElastic) : nextValue;
    axisValue.set(update);
  };
  VisualElementDragControls2.prototype.updateVisualElementAxis = function(axis, event) {
    var _a;
    var dragElastic = this.props.dragElastic;
    var axisLayout = this.visualElement.box[axis];
    var axisLength = axisLayout.max - axisLayout.min;
    var axisProgress = this.cursorProgress[axis];
    var point = getViewportPointFromEvent(event).point;
    var min = calcConstrainedMinPoint(point[axis], axisLength, axisProgress, (_a = this.constraints) === null || _a === void 0 ? void 0 : _a[axis], dragElastic);
    this.visualElement.setAxisTarget(axis, min, min + axisLength);
  };
  VisualElementDragControls2.prototype.updateProps = function(_a) {
    var _b = _a.drag, drag = _b === void 0 ? false : _b, _c = _a.dragDirectionLock, dragDirectionLock = _c === void 0 ? false : _c, _d = _a.dragPropagation, dragPropagation = _d === void 0 ? false : _d, _e = _a.dragConstraints, dragConstraints = _e === void 0 ? false : _e, _f = _a.dragElastic, dragElastic = _f === void 0 ? 0.35 : _f, _g = _a.dragMomentum, dragMomentum = _g === void 0 ? true : _g, remainingProps = __rest(_a, ["drag", "dragDirectionLock", "dragPropagation", "dragConstraints", "dragElastic", "dragMomentum"]);
    this.props = __assign({
      drag,
      dragDirectionLock,
      dragPropagation,
      dragConstraints,
      dragElastic,
      dragMomentum
    }, remainingProps);
  };
  VisualElementDragControls2.prototype.getAxisMotionValue = function(axis) {
    var _a = this.props, layout = _a.layout, layoutId = _a.layoutId;
    var dragKey = "_drag" + axis.toUpperCase();
    if (this.props[dragKey]) {
      return this.props[dragKey];
    } else if (!layout && layoutId === void 0) {
      return this.visualElement.getValue(axis, 0);
    }
  };
  VisualElementDragControls2.prototype.animateDragEnd = function(velocity) {
    var _this = this;
    var _a = this.props, drag = _a.drag, dragMomentum = _a.dragMomentum, dragElastic = _a.dragElastic, dragTransition = _a.dragTransition;
    var momentumAnimations = eachAxis(function(axis) {
      if (!shouldDrag(axis, drag, _this.currentDirection)) {
        return;
      }
      var transition = _this.constraints ? _this.constraints[axis] : {};
      var bounceStiffness = dragElastic ? 200 : 1e6;
      var bounceDamping = dragElastic ? 40 : 1e7;
      var inertia2 = __assign(__assign({
        type: "inertia",
        velocity: dragMomentum ? velocity[axis] : 0,
        bounceStiffness,
        bounceDamping,
        timeConstant: 750,
        restDelta: 1,
        restSpeed: 10
      }, dragTransition), transition);
      return _this.getAxisMotionValue(axis) ? _this.startAxisValueAnimation(axis, inertia2) : _this.visualElement.startLayoutAxisAnimation(axis, inertia2);
    });
    return Promise.all(momentumAnimations).then(function() {
      var _a2, _b;
      (_b = (_a2 = _this.props).onDragTransitionEnd) === null || _b === void 0 ? void 0 : _b.call(_a2);
    });
  };
  VisualElementDragControls2.prototype.stopMotion = function() {
    var _this = this;
    eachAxis(function(axis) {
      var axisValue = _this.getAxisMotionValue(axis);
      axisValue ? axisValue.stop() : _this.visualElement.stopLayoutAnimation();
    });
  };
  VisualElementDragControls2.prototype.startAxisValueAnimation = function(axis, transition) {
    var axisValue = this.getAxisMotionValue(axis);
    if (!axisValue)
      return;
    var currentValue = axisValue.get();
    axisValue.set(currentValue);
    axisValue.set(currentValue);
    return startAnimation(axis, axisValue, 0, transition);
  };
  VisualElementDragControls2.prototype.scalePoint = function() {
    var _this = this;
    var _a = this.props, drag = _a.drag, dragConstraints = _a.dragConstraints;
    if (!isRefObject(dragConstraints) || !this.constraintsBox)
      return;
    this.stopMotion();
    var boxProgress = { x: 0, y: 0 };
    eachAxis(function(axis) {
      boxProgress[axis] = calcOrigin(_this.visualElement.targetBox[axis], _this.constraintsBox[axis]);
    });
    this.prepareBoundingBox();
    this.resolveDragConstraints();
    eachAxis(function(axis) {
      if (!shouldDrag(axis, drag, null))
        return;
      var _a2 = calcPositionFromProgress(_this.visualElement.targetBox[axis], _this.constraintsBox[axis], boxProgress[axis]), min = _a2.min, max = _a2.max;
      _this.visualElement.setAxisTarget(axis, min, max);
    });
  };
  VisualElementDragControls2.prototype.mount = function(visualElement) {
    var _this = this;
    var element = visualElement.getInstance();
    var stopPointerListener = addPointerEvent(element, "pointerdown", function(event) {
      var _a = _this.props, drag = _a.drag, _b = _a.dragListener, dragListener = _b === void 0 ? true : _b;
      drag && dragListener && _this.start(event);
    });
    var stopResizeListener = addDomEvent(window, "resize", function() {
      _this.scalePoint();
    });
    var stopLayoutUpdateListener = visualElement.onLayoutUpdate(function() {
      if (_this.isDragging)
        _this.resolveDragConstraints();
    });
    var prevSnapshot = visualElement.prevSnapshot;
    (prevSnapshot === null || prevSnapshot === void 0 ? void 0 : prevSnapshot.isDragging) && this.start(lastPointerEvent, {
      cursorProgress: prevSnapshot.cursorProgress
    });
    return function() {
      stopPointerListener === null || stopPointerListener === void 0 ? void 0 : stopPointerListener();
      stopResizeListener === null || stopResizeListener === void 0 ? void 0 : stopResizeListener();
      stopLayoutUpdateListener === null || stopLayoutUpdateListener === void 0 ? void 0 : stopLayoutUpdateListener();
      _this.cancelDrag();
    };
  };
  return VisualElementDragControls2;
}();
function shouldDrag(direction, drag, currentDirection) {
  return (drag === true || drag === direction) && (currentDirection === null || currentDirection === direction);
}
function getCurrentDirection(offset, lockThreshold) {
  if (lockThreshold === void 0) {
    lockThreshold = 10;
  }
  var direction = null;
  if (Math.abs(offset.y) > lockThreshold) {
    direction = "y";
  } else if (Math.abs(offset.x) > lockThreshold) {
    direction = "x";
  }
  return direction;
}
function useDrag(props, visualElement) {
  var groupDragControls = props.dragControls;
  var transformPagePoint = (0, import_react.useContext)(MotionConfigContext).transformPagePoint;
  var dragControls = useConstant(function() {
    return new VisualElementDragControls({
      visualElement
    });
  });
  dragControls.updateProps(__assign(__assign({}, props), { transformPagePoint }));
  (0, import_react.useEffect)(function() {
    return groupDragControls && groupDragControls.subscribe(dragControls);
  }, [dragControls]);
  (0, import_react.useEffect)(function() {
    return dragControls.mount(visualElement);
  }, []);
}
var makeRenderlessComponent = function(hook) {
  return function(props) {
    hook(props);
    return null;
  };
};
var Component = makeRenderlessComponent(function(_a) {
  var visualElement = _a.visualElement, props = __rest(_a, ["visualElement"]);
  return useDrag(props, visualElement);
});
var Drag = {
  key: "drag",
  shouldRender: function(props) {
    return !!props.drag || !!props.dragControls;
  },
  getComponent: function() {
    return Component;
  }
};
function useUnmountEffect(callback) {
  return (0, import_react.useEffect)(function() {
    return function() {
      return callback();
    };
  }, []);
}
function usePanGesture(_a, ref) {
  var onPan = _a.onPan, onPanStart = _a.onPanStart, onPanEnd = _a.onPanEnd, onPanSessionStart = _a.onPanSessionStart;
  var hasPanEvents = onPan || onPanStart || onPanEnd || onPanSessionStart;
  var panSession = (0, import_react.useRef)(null);
  var transformPagePoint = (0, import_react.useContext)(MotionConfigContext).transformPagePoint;
  var handlers = {
    onSessionStart: onPanSessionStart,
    onStart: onPanStart,
    onMove: onPan,
    onEnd: function(event, info) {
      panSession.current = null;
      onPanEnd && onPanEnd(event, info);
    }
  };
  (0, import_react.useEffect)(function() {
    if (panSession.current !== null) {
      panSession.current.updateHandlers(handlers);
    }
  });
  function onPointerDown(event) {
    panSession.current = new PanSession(event, handlers, {
      transformPagePoint
    });
  }
  usePointerEvent(ref, "pointerdown", hasPanEvents && onPointerDown);
  useUnmountEffect(function() {
    return panSession.current && panSession.current.end();
  });
}
var isNodeOrChild = function(parent, child) {
  if (!child) {
    return false;
  } else if (parent === child) {
    return true;
  } else {
    return isNodeOrChild(parent, child.parentElement);
  }
};
var order$1 = ["whileHover", "whileTap", "whileDrag"];
var getGesturePriority = function(gesture) {
  return order$1.indexOf(gesture) + 1;
};
var tapGesturePriority = getGesturePriority("whileTap");
function useTapGesture(_a, visualElement) {
  var onTap = _a.onTap, onTapStart = _a.onTapStart, onTapCancel = _a.onTapCancel, whileTap = _a.whileTap;
  var hasTapListeners = onTap || onTapStart || onTapCancel || whileTap;
  var isTapping = (0, import_react.useRef)(false);
  var cancelPointerEventListener = (0, import_react.useRef)(null);
  function removePointerUp() {
    var _a2;
    (_a2 = cancelPointerEventListener.current) === null || _a2 === void 0 ? void 0 : _a2.call(cancelPointerEventListener);
    cancelPointerEventListener.current = null;
  }
  whileTap && setOverride(visualElement, whileTap, tapGesturePriority);
  var onPointerUp = (0, import_react.useRef)(null);
  onPointerUp.current = function(event, info) {
    var element = visualElement.getInstance();
    removePointerUp();
    if (!isTapping.current || !element)
      return;
    isTapping.current = false;
    whileTap && clearOverride(visualElement, tapGesturePriority);
    var openGestureLock = getGlobalLock(true);
    if (!openGestureLock)
      return;
    openGestureLock();
    if (!isNodeOrChild(element, event.target)) {
      onTapCancel === null || onTapCancel === void 0 ? void 0 : onTapCancel(event, info);
    } else {
      onTap === null || onTap === void 0 ? void 0 : onTap(event, info);
    }
  };
  function onPointerDown(event, info) {
    removePointerUp();
    cancelPointerEventListener.current = pipe(addPointerEvent(window, "pointerup", function(event2, info2) {
      var _a2;
      return (_a2 = onPointerUp.current) === null || _a2 === void 0 ? void 0 : _a2.call(onPointerUp, event2, info2);
    }), addPointerEvent(window, "pointercancel", function(event2, info2) {
      var _a2;
      return (_a2 = onPointerUp.current) === null || _a2 === void 0 ? void 0 : _a2.call(onPointerUp, event2, info2);
    }));
    var element = visualElement.getInstance();
    if (!element || isTapping.current)
      return;
    isTapping.current = true;
    onTapStart === null || onTapStart === void 0 ? void 0 : onTapStart(event, info);
    whileTap && startOverride(visualElement, tapGesturePriority);
  }
  usePointerEvent(visualElement, "pointerdown", hasTapListeners ? onPointerDown : void 0);
  useUnmountEffect(removePointerUp);
}
var hoverPriority = getGesturePriority("whileHover");
var filterTouch = function(listener) {
  return function(event, info) {
    if (isMouseEvent(event))
      listener(event, info);
  };
};
function useHoverGesture(_a, visualElement) {
  var whileHover = _a.whileHover, onHoverStart = _a.onHoverStart, onHoverEnd = _a.onHoverEnd;
  if (whileHover) {
    setOverride(visualElement, whileHover, hoverPriority);
  }
  usePointerEvent(visualElement, "pointerenter", filterTouch(function(event, info) {
    onHoverStart === null || onHoverStart === void 0 ? void 0 : onHoverStart(event, info);
    whileHover && startOverride(visualElement, hoverPriority);
  }));
  usePointerEvent(visualElement, "pointerleave", filterTouch(function(event, info) {
    onHoverEnd === null || onHoverEnd === void 0 ? void 0 : onHoverEnd(event, info);
    whileHover && clearOverride(visualElement, hoverPriority);
  }));
}
function useGestures(props, visualElement) {
  usePanGesture(props, visualElement);
  useTapGesture(props, visualElement);
  useHoverGesture(props, visualElement);
}
var gestureProps = [
  "onPan",
  "onPanStart",
  "onPanEnd",
  "onPanSessionStart",
  "onTap",
  "onTapStart",
  "onTapCancel",
  "whileTap",
  "whileHover",
  "onHoverStart",
  "onHoverEnd"
];
var GestureComponent = makeRenderlessComponent(function(_a) {
  var visualElement = _a.visualElement, props = __rest(_a, ["visualElement"]);
  useGestures(props, visualElement);
});
var Gestures = {
  key: "gestures",
  shouldRender: function(props) {
    return gestureProps.some(function(key) {
      return props.hasOwnProperty(key);
    });
  },
  getComponent: function() {
    return GestureComponent;
  }
};
var AnimationControls = function() {
  function AnimationControls2() {
    this.hasMounted = false;
    this.pendingAnimations = [];
    this.subscribers = /* @__PURE__ */ new Set();
  }
  AnimationControls2.prototype.subscribe = function(visualElement) {
    var _this = this;
    this.subscribers.add(visualElement);
    return function() {
      return _this.subscribers.delete(visualElement);
    };
  };
  AnimationControls2.prototype.start = function(definition, transitionOverride) {
    var _this = this;
    if (this.hasMounted) {
      var animations_1 = [];
      this.subscribers.forEach(function(visualElement) {
        var animation = startVisualElementAnimation(visualElement, definition, { transitionOverride });
        animations_1.push(animation);
      });
      return Promise.all(animations_1);
    } else {
      return new Promise(function(resolve) {
        _this.pendingAnimations.push({
          animation: [definition, transitionOverride],
          resolve
        });
      });
    }
  };
  AnimationControls2.prototype.set = function(definition) {
    invariant(this.hasMounted, "controls.set() should only be called after a component has mounted. Consider calling within a useEffect hook.");
    return this.subscribers.forEach(function(visualElement) {
      setValues(visualElement, definition);
    });
  };
  AnimationControls2.prototype.stop = function() {
    this.subscribers.forEach(function(visualElement) {
      stopAnimation(visualElement);
    });
  };
  AnimationControls2.prototype.mount = function() {
    var _this = this;
    this.hasMounted = true;
    this.pendingAnimations.forEach(function(_a) {
      var animation = _a.animation, resolve = _a.resolve;
      _this.start.apply(_this, __spread(animation)).then(resolve);
    });
  };
  AnimationControls2.prototype.unmount = function() {
    this.hasMounted = false;
    this.stop();
  };
  return AnimationControls2;
}();
var animationControls = function() {
  return new AnimationControls();
};
var ExitComponent = makeRenderlessComponent(function(props) {
  var animate3 = props.animate, exit = props.exit, visualElement = props.visualElement;
  var _a = __read(usePresence(), 2), isPresent2 = _a[0], onExitComplete = _a[1];
  var presenceContext = (0, import_react.useContext)(PresenceContext);
  var isPlayingExitAnimation = (0, import_react.useRef)(false);
  var custom = (presenceContext === null || presenceContext === void 0 ? void 0 : presenceContext.custom) !== void 0 ? presenceContext.custom : props.custom;
  (0, import_react.useEffect)(function() {
    if (!isPresent2) {
      if (!isPlayingExitAnimation.current && exit) {
        startVisualElementAnimation(visualElement, exit, {
          custom
        }).then(onExitComplete);
      }
      isPlayingExitAnimation.current = true;
    } else if (isPlayingExitAnimation.current && animate3 && typeof animate3 !== "boolean" && !(animate3 instanceof AnimationControls)) {
      startVisualElementAnimation(visualElement, animate3);
    }
    if (isPresent2) {
      isPlayingExitAnimation.current = false;
    }
  }, [animate3, custom, exit, isPresent2, onExitComplete, props]);
});
var Exit = {
  key: "exit",
  shouldRender: function(props) {
    return !!props.exit && !checkShouldInheritVariant(props);
  },
  getComponent: function() {
    return ExitComponent;
  }
};
function shallowCompare(next, prev) {
  if (prev === null)
    return false;
  var prevLength = prev.length;
  if (prevLength !== next.length)
    return false;
  for (var i = 0; i < prevLength; i++) {
    if (prev[i] !== next[i])
      return false;
  }
  return true;
}
var hasUpdated = function(prev, next) {
  return next !== void 0 && (Array.isArray(prev) && Array.isArray(next) ? !shallowCompare(next, prev) : prev !== next);
};
function targetWithoutTransition(_a, mergeTransitionEnd) {
  if (mergeTransitionEnd === void 0) {
    mergeTransitionEnd = false;
  }
  var transition = _a.transition, transitionEnd = _a.transitionEnd, target2 = __rest(_a, ["transition", "transitionEnd"]);
  return mergeTransitionEnd ? __assign(__assign({}, target2), transitionEnd) : target2;
}
function useAnimateProp(visualElement, targetAndTransition, defaultTransition2) {
  var isInitialRender = (0, import_react.useRef)(true);
  var prevValues = (0, import_react.useRef)(null);
  if (!prevValues.current) {
    prevValues.current = targetWithoutTransition(targetAndTransition, true);
  }
  (0, import_react.useEffect)(function() {
    var targetToAnimate = {};
    var animatingTarget = targetWithoutTransition(targetAndTransition);
    var finalTarget = targetWithoutTransition(targetAndTransition, true);
    for (var key in animatingTarget) {
      var shouldAnimateOnMount = isInitialRender.current && (!visualElement.hasValue(key) || visualElement.getValue(key).get() !== finalTarget[key]);
      var isValidValue = finalTarget[key] !== null;
      var valueHasUpdated = hasUpdated(prevValues.current[key], finalTarget[key]);
      if (isValidValue && (valueHasUpdated || shouldAnimateOnMount)) {
        targetToAnimate[key] = animatingTarget[key];
      }
    }
    isInitialRender.current = false;
    prevValues.current = __assign(__assign({}, prevValues.current), finalTarget);
    if (Object.keys(targetToAnimate).length) {
      startVisualElementAnimation(visualElement, __assign(__assign({}, targetToAnimate), { transition: targetAndTransition.transition || defaultTransition2, transitionEnd: targetAndTransition.transitionEnd }));
    }
  }, [targetAndTransition]);
}
var labelsToArray = function(label) {
  if (!label) {
    return [];
  }
  if (Array.isArray(label)) {
    return label;
  }
  return [label];
};
var resolveVariantLabels = function(variant2) {
  var unresolvedVariant = variant2 instanceof MotionValue ? variant2.get() : variant2;
  return Array.from(new Set(labelsToArray(unresolvedVariant)));
};
var asDependencyList = function(list) {
  return [
    list.join(",")
  ];
};
var hasVariantChanged = function(oldVariant, newVariant) {
  return oldVariant.join(",") !== newVariant.join(",");
};
function useVariantAnimations(visualElement, initial, animate3, inherit) {
  var _a;
  var targetVariants = resolveVariantLabels(animate3);
  var context = useVariantContext();
  var parentAlreadyMounted = (_a = context.parent) === null || _a === void 0 ? void 0 : _a.isMounted;
  var hasMounted = (0, import_react.useRef)(false);
  (0, import_react.useEffect)(function() {
    var shouldAnimate = false;
    if (inherit) {
      shouldAnimate = !!parentAlreadyMounted;
      targetVariants = resolveVariantLabels(context.animate);
    } else {
      shouldAnimate = hasMounted.current || hasVariantChanged(resolveVariantLabels(initial), targetVariants);
    }
    shouldAnimate && startVisualElementAnimation(visualElement, targetVariants);
    hasMounted.current = true;
  }, asDependencyList(targetVariants));
}
function useAnimationGroupSubscription(visualElement, animation) {
  var unsubscribe = (0, import_react.useMemo)(function() {
    return animation.subscribe(visualElement);
  }, [
    animation
  ]);
  useUnmountEffect(function() {
    return unsubscribe === null || unsubscribe === void 0 ? void 0 : unsubscribe();
  });
}
var target = {
  shouldRender: function(props) {
    return props.animate !== void 0 && !isVariantLabel(props.animate) && !isAnimationControls(props.animate);
  },
  Component: makeRenderlessComponent(function(_a) {
    var animate3 = _a.animate, visualElement = _a.visualElement, transition = _a.transition;
    return useAnimateProp(visualElement, animate3, transition);
  })
};
var variant = {
  shouldRender: function(props) {
    return props.variants && !isAnimationControls(props.animate) || isVariantLabel(props.animate);
  },
  Component: makeRenderlessComponent(function(_a) {
    var animate3 = _a.animate, _b = _a.inherit, inherit = _b === void 0 ? true : _b, visualElement = _a.visualElement, initial = _a.initial;
    return useVariantAnimations(visualElement, initial, animate3, inherit);
  })
};
var controls = {
  shouldRender: function(props) {
    return isAnimationControls(props.animate);
  },
  Component: makeRenderlessComponent(function(_a) {
    var animate3 = _a.animate, visualElement = _a.visualElement;
    return useAnimationGroupSubscription(visualElement, animate3);
  })
};
var getAnimationComponent = function(props) {
  if (target.shouldRender(props)) {
    return target.Component;
  } else if (variant.shouldRender(props)) {
    return variant.Component;
  } else if (controls.shouldRender(props)) {
    return controls.Component;
  }
};
var Animation = {
  key: "animation",
  shouldRender: function() {
    return true;
  },
  getComponent: getAnimationComponent
};
function tweenAxis(target2, prev, next, p) {
  target2.min = mix(prev.min, next.min, p);
  target2.max = mix(prev.max, next.max, p);
}
var progressTarget = 1e3;
var Animate = function(_super) {
  __extends(Animate2, _super);
  function Animate2() {
    var _this = _super !== null && _super.apply(this, arguments) || this;
    _this.frameTarget = {
      x: { min: 0, max: 0 },
      y: { min: 0, max: 0 }
    };
    _this.stopAxisAnimation = {
      x: void 0,
      y: void 0
    };
    _this.animate = function(target2, origin, _a) {
      if (_a === void 0) {
        _a = {};
      }
      var originBox = _a.originBox, targetBox = _a.targetBox, visibilityAction = _a.visibilityAction, shouldStackAnimate = _a.shouldStackAnimate, config = __rest(_a, ["originBox", "targetBox", "visibilityAction", "shouldStackAnimate"]);
      var _b = _this.props, visualElement = _b.visualElement, layout = _b.layout;
      if (shouldStackAnimate === false)
        return _this.safeToRemove();
      origin = originBox || origin;
      target2 = targetBox || target2;
      var boxHasMoved = hasMoved(origin, target2);
      var animations = eachAxis(function(axis) {
        if (layout === "position") {
          var targetLength = target2[axis].max - target2[axis].min;
          origin[axis].max = origin[axis].min + targetLength;
        }
        if (visualElement.isTargetBoxLocked) {
          return;
        } else if (visibilityAction !== void 0) {
          visibilityAction === VisibilityAction.Hide ? visualElement.hide() : visualElement.show();
        } else if (boxHasMoved) {
          return _this.animateAxis(axis, target2[axis], origin[axis], config);
        } else {
          return visualElement.setAxisTarget(axis, target2[axis].min, target2[axis].max);
        }
      });
      visualElement.render();
      return Promise.all(animations).then(function() {
        var _a2, _b2;
        (_b2 = (_a2 = _this.props).onLayoutAnimationComplete) === null || _b2 === void 0 ? void 0 : _b2.call(_a2);
        if (visualElement.isPresent) {
          visualElement.presence = Presence.Present;
        } else {
          _this.safeToRemove();
        }
      });
    };
    return _this;
  }
  Animate2.prototype.componentDidMount = function() {
    var _this = this;
    var visualElement = this.props.visualElement;
    visualElement.animateMotionValue = startAnimation;
    visualElement.enableLayoutProjection();
    this.unsubLayoutReady = visualElement.onLayoutUpdate(this.animate);
    visualElement.updateConfig(__assign(__assign({}, visualElement.config), { safeToRemove: function() {
      return _this.safeToRemove();
    } }));
  };
  Animate2.prototype.componentWillUnmount = function() {
    var _this = this;
    this.unsubLayoutReady();
    eachAxis(function(axis) {
      var _a, _b;
      return (_b = (_a = _this.stopAxisAnimation)[axis]) === null || _b === void 0 ? void 0 : _b.call(_a);
    });
  };
  Animate2.prototype.animateAxis = function(axis, target2, origin, _a) {
    var _b, _c;
    var _d = _a === void 0 ? {} : _a, transition = _d.transition, crossfadeOpacity = _d.crossfadeOpacity;
    (_c = (_b = this.stopAxisAnimation)[axis]) === null || _c === void 0 ? void 0 : _c.call(_b);
    var visualElement = this.props.visualElement;
    var frameTarget = this.frameTarget[axis];
    var layoutProgress = visualElement.axisProgress[axis];
    layoutProgress.clearListeners();
    layoutProgress.set(0);
    layoutProgress.set(0);
    var crossfade;
    if (crossfadeOpacity) {
      crossfade = this.createCrossfadeAnimation(crossfadeOpacity);
      visualElement.show();
    }
    var frame2 = function() {
      var p = layoutProgress.get() / progressTarget;
      tweenAxis(frameTarget, origin, target2, p);
      visualElement.setAxisTarget(axis, frameTarget.min, frameTarget.max);
      crossfade === null || crossfade === void 0 ? void 0 : crossfade(p);
    };
    frame2();
    visualElement.updateLayoutDelta();
    var unsubscribeProgress = layoutProgress.onChange(frame2);
    var animation = startAnimation(axis === "x" ? "layoutX" : "layoutY", layoutProgress, progressTarget, transition || this.props.transition || defaultTransition).then(unsubscribeProgress);
    this.stopAxisAnimation[axis] = function() {
      layoutProgress.stop();
      unsubscribeProgress();
    };
    return animation;
  };
  Animate2.prototype.createCrossfadeAnimation = function(crossfadeOpacity) {
    var visualElement = this.props.visualElement;
    var opacity = visualElement.getValue("opacity", 0);
    return function(p) {
      opacity.set(easeCrossfadeIn(mix(0, 1, p)));
      crossfadeOpacity.set(easeCrossfadeOut(mix(1, 0, p)));
    };
  };
  Animate2.prototype.safeToRemove = function() {
    var _a, _b;
    (_b = (_a = this.props).safeToRemove) === null || _b === void 0 ? void 0 : _b.call(_a);
  };
  Animate2.prototype.render = function() {
    return null;
  };
  return Animate2;
}(import_react.Component);
function AnimateLayoutContextProvider(props) {
  var _a = __read(usePresence(), 2), safeToRemove = _a[1];
  return (0, import_react.createElement)(Animate, __assign({}, props, { safeToRemove }));
}
function hasMoved(a2, b2) {
  return hasAxisMoved(a2.x, b2.x) || hasAxisMoved(a2.y, b2.y);
}
function hasAxisMoved(a2, b2) {
  return a2.min !== b2.min || a2.max !== b2.max;
}
var defaultTransition = {
  duration: 0.45,
  ease: [0.4, 0, 0.1, 1]
};
function compress(min, max, easing) {
  return function(p) {
    if (p < min)
      return 0;
    if (p > max)
      return 1;
    return easing(progress(min, max, p));
  };
}
var easeCrossfadeIn = compress(0, 0.5, circOut);
var easeCrossfadeOut = compress(0.5, 0.95, linear);
var AnimateLayout = {
  key: "animate-layout",
  shouldRender: function(props) {
    return !!props.layout || !!props.layoutId;
  },
  getComponent: function() {
    return AnimateLayoutContextProvider;
  }
};
var Measure = function(_super) {
  __extends(Measure2, _super);
  function Measure2() {
    return _super !== null && _super.apply(this, arguments) || this;
  }
  Measure2.prototype.componentDidMount = function() {
    var _a = this.props, syncLayout = _a.syncLayout, framerSyncLayout = _a.framerSyncLayout, visualElement = _a.visualElement;
    isSharedLayout(syncLayout) && syncLayout.register(visualElement);
    isSharedLayout(framerSyncLayout) && framerSyncLayout.register(visualElement);
  };
  Measure2.prototype.getSnapshotBeforeUpdate = function() {
    var _a = this.props, syncLayout = _a.syncLayout, visualElement = _a.visualElement;
    if (isSharedLayout(syncLayout)) {
      syncLayout.syncUpdate();
    } else {
      visualElement.snapshotBoundingBox();
      syncLayout.add(visualElement);
    }
    return null;
  };
  Measure2.prototype.componentDidUpdate = function() {
    var _a = this.props, syncLayout = _a.syncLayout, visualElement = _a.visualElement;
    if (!isSharedLayout(syncLayout))
      syncLayout.flush();
    visualElement.rebaseTargetBox();
  };
  Measure2.prototype.render = function() {
    return null;
  };
  return Measure2;
}(import_react.default.Component);
function MeasureContextProvider(props) {
  var syncLayout = (0, import_react.useContext)(SharedLayoutContext);
  var framerSyncLayout = (0, import_react.useContext)(FramerTreeLayoutContext);
  return import_react.default.createElement(Measure, __assign({}, props, { syncLayout, framerSyncLayout }));
}
var MeasureLayout = {
  key: "measure-layout",
  shouldRender: function(props) {
    return !!props.drag || !!props.layout || !!props.layoutId;
  },
  getComponent: function() {
    return MeasureContextProvider;
  }
};
var allMotionFeatures = [
  MeasureLayout,
  Animation,
  Drag,
  Gestures,
  Exit,
  AnimateLayout
];
var domBaseConfig = {
  useVisualElement: useDomVisualElement,
  render
};
function createMotionProxy(defaultFeatures) {
  var config = __assign(__assign({}, domBaseConfig), { defaultFeatures });
  function custom(Component2) {
    return createMotionComponent(Component2, config);
  }
  var componentCache = /* @__PURE__ */ new Map();
  function get(target2, key) {
    if (key === "custom")
      return target2.custom;
    if (!componentCache.has(key)) {
      componentCache.set(key, createMotionComponent(key, config));
    }
    return componentCache.get(key);
  }
  return new Proxy({ custom }, { get });
}
var motion = createMotionProxy(allMotionFeatures);
function createDomMotionComponent(key) {
  return createMotionComponent(key, __assign(__assign({}, domBaseConfig), { defaultFeatures: allMotionFeatures }));
}
var m = createMotionProxy([MeasureLayout]);
function useForceUpdate() {
  var unloadingRef = (0, import_react.useRef)(false);
  var _a = __read((0, import_react.useState)(0), 2), forcedRenderCount = _a[0], setForcedRenderCount = _a[1];
  useUnmountEffect(function() {
    return unloadingRef.current = true;
  });
  return (0, import_react.useCallback)(function() {
    !unloadingRef.current && setForcedRenderCount(forcedRenderCount + 1);
  }, [forcedRenderCount]);
}
var presenceId = 0;
function getPresenceId() {
  var id = presenceId;
  presenceId++;
  return id;
}
var PresenceChild = function(_a) {
  var children = _a.children, initial = _a.initial, isPresent2 = _a.isPresent, onExitComplete = _a.onExitComplete, custom = _a.custom, presenceAffectsLayout = _a.presenceAffectsLayout;
  var presenceChildren = useConstant(newChildrenMap);
  var id = useConstant(getPresenceId);
  var context = (0, import_react.useMemo)(
    function() {
      return {
        id,
        initial,
        isPresent: isPresent2,
        custom,
        onExitComplete: function(childId) {
          presenceChildren.set(childId, true);
          var allComplete = true;
          presenceChildren.forEach(function(isComplete) {
            if (!isComplete)
              allComplete = false;
          });
          allComplete && (onExitComplete === null || onExitComplete === void 0 ? void 0 : onExitComplete());
        },
        register: function(childId) {
          presenceChildren.set(childId, false);
          return function() {
            return presenceChildren.delete(childId);
          };
        }
      };
    },
    presenceAffectsLayout ? void 0 : [isPresent2]
  );
  (0, import_react.useMemo)(function() {
    presenceChildren.forEach(function(_, key) {
      return presenceChildren.set(key, false);
    });
  }, [isPresent2]);
  return (0, import_react.createElement)(PresenceContext.Provider, { value: context }, children);
};
function newChildrenMap() {
  return /* @__PURE__ */ new Map();
}
function getChildKey(child) {
  return child.key || "";
}
function updateChildLookup(children, allChildren) {
  var seenChildren = true ? /* @__PURE__ */ new Set() : null;
  children.forEach(function(child) {
    var key = getChildKey(child);
    if (seenChildren) {
      if (seenChildren.has(key)) {
        console.warn('Children of AnimatePresence require unique keys. "' + key + '" is a duplicate.');
      }
      seenChildren.add(key);
    }
    allChildren.set(key, child);
  });
}
function onlyElements(children) {
  var filtered = [];
  import_react.Children.forEach(children, function(child) {
    if ((0, import_react.isValidElement)(child))
      filtered.push(child);
  });
  return filtered;
}
var AnimatePresence = function(_a) {
  var children = _a.children, custom = _a.custom, _b = _a.initial, initial = _b === void 0 ? true : _b, onExitComplete = _a.onExitComplete, exitBeforeEnter = _a.exitBeforeEnter, _c = _a.presenceAffectsLayout, presenceAffectsLayout = _c === void 0 ? true : _c;
  var forceRender = useForceUpdate();
  var layoutContext = (0, import_react.useContext)(SharedLayoutContext);
  if (isSharedLayout(layoutContext)) {
    forceRender = layoutContext.forceUpdate;
  }
  var isInitialRender = (0, import_react.useRef)(true);
  var filteredChildren = onlyElements(children);
  var presentChildren = (0, import_react.useRef)(filteredChildren);
  var allChildren = (0, import_react.useRef)(/* @__PURE__ */ new Map()).current;
  var exiting = (0, import_react.useRef)(/* @__PURE__ */ new Set()).current;
  updateChildLookup(filteredChildren, allChildren);
  if (isInitialRender.current) {
    isInitialRender.current = false;
    return (0, import_react.createElement)(import_react.Fragment, null, filteredChildren.map(function(child) {
      return (0, import_react.createElement)(PresenceChild, { key: getChildKey(child), isPresent: true, initial: initial ? void 0 : false, presenceAffectsLayout }, child);
    }));
  }
  var childrenToRender = __spread(filteredChildren);
  var presentKeys = presentChildren.current.map(getChildKey);
  var targetKeys = filteredChildren.map(getChildKey);
  var numPresent = presentKeys.length;
  for (var i = 0; i < numPresent; i++) {
    var key = presentKeys[i];
    if (targetKeys.indexOf(key) === -1) {
      exiting.add(key);
    } else {
      exiting.delete(key);
    }
  }
  if (exitBeforeEnter && exiting.size) {
    childrenToRender = [];
  }
  exiting.forEach(function(key2) {
    if (targetKeys.indexOf(key2) !== -1)
      return;
    var child = allChildren.get(key2);
    if (!child)
      return;
    var insertionIndex = presentKeys.indexOf(key2);
    var onExit = function() {
      allChildren.delete(key2);
      exiting.delete(key2);
      var removeIndex = presentChildren.current.findIndex(function(presentChild) {
        return presentChild.key === key2;
      });
      presentChildren.current.splice(removeIndex, 1);
      if (!exiting.size) {
        presentChildren.current = filteredChildren;
        forceRender();
        onExitComplete && onExitComplete();
      }
    };
    childrenToRender.splice(insertionIndex, 0, (0, import_react.createElement)(PresenceChild, { key: getChildKey(child), isPresent: false, onExitComplete: onExit, custom, presenceAffectsLayout }, child));
  });
  childrenToRender = childrenToRender.map(function(child) {
    var key2 = child.key;
    return exiting.has(key2) ? child : (0, import_react.createElement)(PresenceChild, { key: getChildKey(child), isPresent: true, presenceAffectsLayout }, child);
  });
  presentChildren.current = childrenToRender;
  if (exitBeforeEnter && childrenToRender.length > 1) {
    console.warn("You're attempting to animate multiple children within AnimatePresence, but its exitBeforeEnter prop is set to true. This will lead to odd visual behaviour.");
  }
  return (0, import_react.createElement)(import_react.Fragment, null, exiting.size ? childrenToRender : childrenToRender.map(function(child) {
    return (0, import_react.cloneElement)(child);
  }));
};
function createSwitchAnimation(child, stack) {
  if (stack && child !== stack.lead) {
    return { visibilityAction: VisibilityAction.Hide };
  } else if (stack && child.presence !== Presence.Entering && child === stack.lead && stack.lead !== stack.prevLead) {
    return { visibilityAction: VisibilityAction.Show };
  }
  var originBox;
  var targetBox;
  if (child.presence === Presence.Entering) {
    originBox = stack === null || stack === void 0 ? void 0 : stack.getFollowOrigin();
  } else if (child.presence === Presence.Exiting) {
    targetBox = stack === null || stack === void 0 ? void 0 : stack.getFollowTarget();
  }
  return { originBox, targetBox };
}
function createCrossfadeAnimation(child, stack) {
  var _a, _b, _c;
  var config = {};
  var stackLead = stack && stack.lead;
  var stackLeadPresence = stackLead === null || stackLead === void 0 ? void 0 : stackLead.presence;
  if (stack && child === stackLead) {
    if (child.presence === Presence.Entering) {
      config.originBox = stack.getFollowOrigin();
    } else if (child.presence === Presence.Exiting) {
      config.targetBox = stack.getFollowTarget();
    }
  } else if (stack && child === stack.follow) {
    config.transition = stack.getLeadTransition();
    if (stackLeadPresence === Presence.Entering) {
      config.targetBox = stack.getLeadTarget();
    } else if (stackLeadPresence === Presence.Exiting) {
      config.originBox = stack.getLeadOrigin();
    }
  }
  if (!((_a = stack === null || stack === void 0 ? void 0 : stack.follow) === null || _a === void 0 ? void 0 : _a.isPresenceRoot) && !(stackLead === null || stackLead === void 0 ? void 0 : stackLead.isPresenceRoot)) {
    return config;
  }
  if (!stack || child === stackLead) {
    if (child.presence === Presence.Entering) {
      config.crossfadeOpacity = (_b = stack === null || stack === void 0 ? void 0 : stack.follow) === null || _b === void 0 ? void 0 : _b.getValue("opacity", 0);
    }
  } else if (stack && child === stack.follow) {
    if (!stackLead || stackLeadPresence === Presence.Entering)
      ;
    else if (stackLeadPresence === Presence.Exiting) {
      config.crossfadeOpacity = (_c = stack === null || stack === void 0 ? void 0 : stack.lead) === null || _c === void 0 ? void 0 : _c.getValue("opacity", 1);
    }
  } else {
    config.visibilityAction = VisibilityAction.Hide;
  }
  return config;
}
function findLeadAndFollow(stack, _a) {
  var _b = __read(_a, 2), prevLead = _b[0], prevFollow = _b[1];
  var lead = void 0;
  var leadIndex = 0;
  var follow = void 0;
  var numInStack = stack.length;
  var lastIsPresent = false;
  for (var i = numInStack - 1; i >= 0; i--) {
    var child = stack[i];
    var isLastInStack = i === numInStack - 1;
    if (isLastInStack)
      lastIsPresent = child.isPresent;
    if (lastIsPresent) {
      lead = child;
    } else {
      var prev = stack[i - 1];
      if (prev && prev.isPresent)
        lead = child;
    }
    if (lead) {
      leadIndex = i;
      break;
    }
  }
  if (!lead)
    lead = stack[0];
  follow = stack[leadIndex - 1];
  if (lead) {
    for (var i = leadIndex - 1; i >= 0; i--) {
      var child = stack[i];
      if (child.isPresent) {
        follow = child;
        break;
      }
    }
  }
  if (lead !== prevLead && !lastIsPresent && follow === prevFollow && stack.find(function(stackChild) {
    return stackChild === prevLead;
  })) {
    lead = prevLead;
  }
  return [lead, follow];
}
var LayoutStack = function() {
  function LayoutStack2() {
    this.order = [];
    this.hasChildren = false;
  }
  LayoutStack2.prototype.add = function(child) {
    var _a;
    this.order.push(child);
    if (this.snapshot) {
      child.prevSnapshot = this.snapshot;
      child.prevViewportBox = this.snapshot.boundingBox;
      var latest = this.snapshot.latestMotionValues;
      for (var key in latest) {
        if (!child.hasValue(key)) {
          child.addValue(key, motionValue(latest[key]));
        } else {
          (_a = child.getValue(key)) === null || _a === void 0 ? void 0 : _a.set(latest[key]);
        }
      }
    }
    this.hasChildren = true;
  };
  LayoutStack2.prototype.remove = function(child) {
    var index2 = this.order.findIndex(function(stackChild) {
      return child === stackChild;
    });
    if (index2 !== -1)
      this.order.splice(index2, 1);
  };
  LayoutStack2.prototype.updateLeadAndFollow = function() {
    this.prevLead = this.lead;
    this.prevFollow = this.follow;
    var _a = __read(findLeadAndFollow(this.order, [
      this.lead,
      this.follow
    ]), 2), lead = _a[0], follow = _a[1];
    this.lead = lead;
    this.follow = follow;
  };
  LayoutStack2.prototype.updateSnapshot = function() {
    if (!this.lead)
      return;
    var snapshot = {
      boundingBox: this.lead.prevViewportBox,
      latestMotionValues: {}
    };
    this.lead.forEachValue(function(value, key) {
      var latest = value.get();
      if (!isTransformProp(latest)) {
        snapshot.latestMotionValues[key] = latest;
      }
    });
    var dragControls = elementDragControls.get(this.lead);
    if (dragControls && dragControls.isDragging) {
      snapshot.isDragging = true;
      snapshot.cursorProgress = dragControls.cursorProgress;
    }
    this.snapshot = snapshot;
  };
  LayoutStack2.prototype.isLeadPresent = function() {
    var _a;
    return this.lead && ((_a = this.lead) === null || _a === void 0 ? void 0 : _a.presence) !== Presence.Exiting;
  };
  LayoutStack2.prototype.getFollowOrigin = function() {
    var _a;
    return this.follow ? this.follow.prevViewportBox : (_a = this.snapshot) === null || _a === void 0 ? void 0 : _a.boundingBox;
  };
  LayoutStack2.prototype.getFollowTarget = function() {
    var _a;
    return (_a = this.follow) === null || _a === void 0 ? void 0 : _a.box;
  };
  LayoutStack2.prototype.getLeadOrigin = function() {
    var _a;
    return (_a = this.lead) === null || _a === void 0 ? void 0 : _a.prevViewportBox;
  };
  LayoutStack2.prototype.getLeadTarget = function() {
    var _a;
    return (_a = this.lead) === null || _a === void 0 ? void 0 : _a.box;
  };
  LayoutStack2.prototype.getLeadTransition = function() {
    var _a;
    return (_a = this.lead) === null || _a === void 0 ? void 0 : _a.config.transition;
  };
  return LayoutStack2;
}();
var AnimateSharedLayout = function(_super) {
  __extends(AnimateSharedLayout2, _super);
  function AnimateSharedLayout2() {
    var _this = _super !== null && _super.apply(this, arguments) || this;
    _this.children = /* @__PURE__ */ new Set();
    _this.stacks = /* @__PURE__ */ new Map();
    _this.hasMounted = false;
    _this.updateScheduled = false;
    _this.renderScheduled = false;
    _this.syncContext = __assign(__assign({}, createBatcher()), { syncUpdate: function(force) {
      return _this.scheduleUpdate(force);
    }, forceUpdate: function() {
      _this.syncContext = __assign({}, _this.syncContext);
      _this.scheduleUpdate(true);
    }, register: function(child) {
      return _this.addChild(child);
    }, remove: function(child) {
      return _this.removeChild(child);
    } });
    return _this;
  }
  AnimateSharedLayout2.prototype.componentDidMount = function() {
    this.hasMounted = true;
    this.updateStacks();
  };
  AnimateSharedLayout2.prototype.componentDidUpdate = function() {
    this.startLayoutAnimation();
  };
  AnimateSharedLayout2.prototype.shouldComponentUpdate = function() {
    this.renderScheduled = true;
    return true;
  };
  AnimateSharedLayout2.prototype.startLayoutAnimation = function() {
    var _this = this;
    this.renderScheduled = this.updateScheduled = false;
    var type = this.props.type;
    this.children.forEach(function(child) {
      if (!child.isPresent) {
        child.presence = Presence.Exiting;
      } else if (child.presence !== Presence.Entering) {
        child.presence = child.presence === Presence.Exiting ? Presence.Entering : Presence.Present;
      }
    });
    this.updateStacks();
    var createAnimation = type === "crossfade" ? createCrossfadeAnimation : createSwitchAnimation;
    var handler = {
      measureLayout: function(child) {
        return child.measureLayout();
      },
      layoutReady: function(child) {
        var layoutId = child.layoutId;
        child.layoutReady(createAnimation(child, _this.getStack(layoutId)));
      }
    };
    this.children.forEach(function(child) {
      return _this.syncContext.add(child);
    });
    this.syncContext.flush(handler);
    this.stacks.forEach(function(stack) {
      return stack.snapshot = void 0;
    });
  };
  AnimateSharedLayout2.prototype.updateStacks = function() {
    this.stacks.forEach(function(stack) {
      return stack.updateLeadAndFollow();
    });
  };
  AnimateSharedLayout2.prototype.scheduleUpdate = function(force) {
    if (force === void 0) {
      force = false;
    }
    if (!(force || !this.updateScheduled))
      return;
    this.updateScheduled = true;
    this.children.forEach(function(child) {
      return child.snapshotBoundingBox();
    });
    this.stacks.forEach(function(stack) {
      return stack.updateSnapshot();
    });
    if (force || !this.renderScheduled) {
      this.renderScheduled = true;
      this.forceUpdate();
    }
  };
  AnimateSharedLayout2.prototype.addChild = function(child) {
    this.children.add(child);
    this.addToStack(child);
    child.presence = this.hasMounted ? Presence.Entering : Presence.Present;
  };
  AnimateSharedLayout2.prototype.removeChild = function(child) {
    this.scheduleUpdate();
    this.children.delete(child);
    this.removeFromStack(child);
  };
  AnimateSharedLayout2.prototype.addToStack = function(child) {
    var stack = this.getStack(child.layoutId);
    stack === null || stack === void 0 ? void 0 : stack.add(child);
  };
  AnimateSharedLayout2.prototype.removeFromStack = function(child) {
    var stack = this.getStack(child.layoutId);
    stack === null || stack === void 0 ? void 0 : stack.remove(child);
  };
  AnimateSharedLayout2.prototype.getStack = function(id) {
    if (id === void 0)
      return;
    !this.stacks.has(id) && this.stacks.set(id, new LayoutStack());
    return this.stacks.get(id);
  };
  AnimateSharedLayout2.prototype.render = function() {
    return (0, import_react.createElement)(SharedLayoutContext.Provider, { value: this.syncContext }, this.props.children);
  };
  return AnimateSharedLayout2;
}(import_react.Component);
function useMotionValue(initial) {
  return useConstant(function() {
    return motionValue(initial);
  });
}
function useOnChange(value, callback) {
  (0, import_react.useEffect)(function() {
    return isMotionValue(value) ? value.onChange(callback) : void 0;
  });
}
function useMultiOnChange(values, handler) {
  (0, import_react.useEffect)(function() {
    var subscriptions = values.map(function(value) {
      return value.onChange(handler);
    });
    return function() {
      return subscriptions.forEach(function(unsubscribe) {
        return unsubscribe();
      });
    };
  });
}
function useCombineMotionValues(values, combineValues) {
  var value = useMotionValue(combineValues());
  var updateValue = function() {
    return value.set(combineValues());
  };
  updateValue();
  useMultiOnChange(values, function() {
    return framesync_es_default.update(updateValue, false, true);
  });
  return value;
}
function useMotionTemplate(fragments) {
  var values = [];
  for (var _i = 1; _i < arguments.length; _i++) {
    values[_i - 1] = arguments[_i];
  }
  var numFragments = fragments.length;
  function buildValue() {
    var output = "";
    for (var i = 0; i < numFragments; i++) {
      output += fragments[i];
      var value = values[i];
      if (value)
        output += values[i].get();
    }
    return output;
  }
  return useCombineMotionValues(values, buildValue);
}
function resolveMotionValue(value) {
  var unwrappedValue = value instanceof MotionValue ? value.get() : value;
  return isCustomValue(unwrappedValue) ? unwrappedValue.toValue() : unwrappedValue;
}
var isCustomValueType = function(v) {
  return typeof v === "object" && v.mix;
};
var getMixer2 = function(v) {
  return isCustomValueType(v) ? v.mix : void 0;
};
function transform() {
  var args = [];
  for (var _i = 0; _i < arguments.length; _i++) {
    args[_i] = arguments[_i];
  }
  var useImmediate = !Array.isArray(args[0]);
  var argOffset = useImmediate ? 0 : -1;
  var inputValue = args[0 + argOffset];
  var inputRange = args[1 + argOffset];
  var outputRange = args[2 + argOffset];
  var options = args[3 + argOffset];
  var interpolator = interpolate(inputRange, outputRange, __assign({ mixer: getMixer2(outputRange[0]) }, options));
  return useImmediate ? interpolator(inputValue) : interpolator;
}
function useTransform(input, inputRangeOrTransformer, outputRange, options) {
  var transformer = typeof inputRangeOrTransformer === "function" ? inputRangeOrTransformer : transform(inputRangeOrTransformer, outputRange, options);
  return Array.isArray(input) ? useListTransform(input, transformer) : useListTransform([input], function(_a) {
    var _b = __read(_a, 1), latest = _b[0];
    return transformer(latest);
  });
}
function useListTransform(values, transformer) {
  var latest = useConstant(function() {
    return [];
  });
  return useCombineMotionValues(values, function() {
    latest.length = 0;
    var numValues = values.length;
    for (var i = 0; i < numValues; i++) {
      latest[i] = values[i].get();
    }
    return transformer(latest);
  });
}
var maxScale = 1e5;
var invertScale = function(scale2) {
  return scale2 > 1e-3 ? 1 / scale2 : maxScale;
};
var hasWarned = false;
function useInvertedScale(scale2) {
  var parentScaleX = useMotionValue(1);
  var parentScaleY = useMotionValue(1);
  var visualElement = useVisualElementContext();
  invariant(!!(scale2 || visualElement), "If no scale values are provided, useInvertedScale must be used within a child of another motion component.");
  warning(hasWarned, "useInvertedScale is deprecated and will be removed in 3.0. Use the layout prop instead.");
  hasWarned = true;
  if (scale2) {
    parentScaleX = scale2.scaleX || parentScaleX;
    parentScaleY = scale2.scaleY || parentScaleY;
  } else if (visualElement) {
    parentScaleX = visualElement.getValue("scaleX", 1);
    parentScaleY = visualElement.getValue("scaleY", 1);
  }
  var scaleX = useTransform(parentScaleX, invertScale);
  var scaleY = useTransform(parentScaleY, invertScale);
  return { scaleX, scaleY };
}
function useSpring(source, config) {
  if (config === void 0) {
    config = {};
  }
  var activeSpringAnimation = (0, import_react.useRef)(null);
  var value = useMotionValue(isMotionValue(source) ? source.get() : source);
  (0, import_react.useMemo)(function() {
    return value.attach(function(v, set) {
      if (activeSpringAnimation.current) {
        activeSpringAnimation.current.stop();
      }
      activeSpringAnimation.current = animate(__assign(__assign({ from: value.get(), to: v, velocity: value.getVelocity() }, config), { onUpdate: set }));
      return value.get();
    });
  }, Object.values(config));
  useOnChange(source, function(v) {
    return value.set(parseFloat(v));
  });
  return value;
}
function createScrollMotionValues() {
  return {
    scrollX: motionValue(0),
    scrollY: motionValue(0),
    scrollXProgress: motionValue(0),
    scrollYProgress: motionValue(0)
  };
}
function setProgress(offset, maxOffset, value) {
  value.set(!offset || !maxOffset ? 0 : offset / maxOffset);
}
function createScrollUpdater(values, getOffsets) {
  var update = function() {
    var _a = getOffsets(), xOffset = _a.xOffset, yOffset = _a.yOffset, xMaxOffset = _a.xMaxOffset, yMaxOffset = _a.yMaxOffset;
    values.scrollX.set(xOffset);
    values.scrollY.set(yOffset);
    setProgress(xOffset, xMaxOffset, values.scrollXProgress);
    setProgress(yOffset, yMaxOffset, values.scrollYProgress);
  };
  update();
  return update;
}
var getElementScrollOffsets = function(element) {
  return function() {
    return {
      xOffset: element.scrollLeft,
      yOffset: element.scrollTop,
      xMaxOffset: element.scrollWidth - element.offsetWidth,
      yMaxOffset: element.scrollHeight - element.offsetHeight
    };
  };
};
function useElementScroll(ref) {
  var values = useConstant(createScrollMotionValues);
  useIsomorphicLayoutEffect(function() {
    var element = ref.current;
    invariant(!!element, "ref provided to useScroll must be passed into a HTML element.");
    if (!element)
      return;
    var updateScrollValues = createScrollUpdater(values, getElementScrollOffsets(element));
    var scrollListener = addDomEvent(element, "scroll", updateScrollValues, { passive: true });
    var resizeListener = addDomEvent(element, "resize", updateScrollValues);
    return function() {
      scrollListener && scrollListener();
      resizeListener && resizeListener();
    };
  }, []);
  return values;
}
var viewportScrollValues = createScrollMotionValues();
function getViewportScrollOffsets() {
  return {
    xOffset: window.pageXOffset,
    yOffset: window.pageYOffset,
    xMaxOffset: document.body.clientWidth - window.innerWidth,
    yMaxOffset: document.body.clientHeight - window.innerHeight
  };
}
var hasListeners = false;
function addEventListeners() {
  hasListeners = true;
  if (typeof window === "undefined")
    return;
  var updateScrollValues = createScrollUpdater(viewportScrollValues, getViewportScrollOffsets);
  addDomEvent(window, "scroll", updateScrollValues, { passive: true });
  addDomEvent(window, "resize", updateScrollValues);
}
function useViewportScroll() {
  useIsomorphicLayoutEffect(function() {
    !hasListeners && addEventListeners();
  }, []);
  return viewportScrollValues;
}
var prefersReducedMotion = motionValue(null);
if (typeof window !== "undefined") {
  if (window.matchMedia) {
    motionMediaQuery_1 = window.matchMedia("(prefers-reduced-motion)");
    setReducedMotionPreferences = function() {
      return prefersReducedMotion.set(motionMediaQuery_1.matches);
    };
    motionMediaQuery_1.addListener(setReducedMotionPreferences);
    setReducedMotionPreferences();
  } else {
    prefersReducedMotion.set(false);
  }
}
var motionMediaQuery_1;
var setReducedMotionPreferences;
function useReducedMotion() {
  var _a = __read((0, import_react.useState)(prefersReducedMotion.get()), 2), shouldReduceMotion = _a[0], setShouldReduceMotion = _a[1];
  useOnChange(prefersReducedMotion, setShouldReduceMotion);
  return shouldReduceMotion;
}
function useAnimation() {
  var animationControls2 = useConstant(function() {
    return new AnimationControls();
  });
  (0, import_react.useEffect)(function() {
    animationControls2.mount();
    return function() {
      return animationControls2.unmount();
    };
  }, []);
  return animationControls2;
}
function animate2(from, to, transition) {
  if (transition === void 0) {
    transition = {};
  }
  var value = isMotionValue(from) ? from : motionValue(from);
  startAnimation("", value, to, transition);
  return {
    stop: function() {
      return value.stop();
    }
  };
}
function useCycle() {
  var items = [];
  for (var _i = 0; _i < arguments.length; _i++) {
    items[_i] = arguments[_i];
  }
  warning(items.length > 1, "useCycle syntax has changed. `useCycle([0, 1, 2])` becomes `useCycle(0, 1, 2)`");
  var index2 = (0, import_react.useRef)(0);
  var _a = __read((0, import_react.useState)(items[index2.current]), 2), item = _a[0], setItem = _a[1];
  return [
    item,
    function(next) {
      index2.current = typeof next !== "number" ? wrap(0, items.length, index2.current + 1) : next;
      setItem(items[index2.current]);
    }
  ];
}
var DragControls = function() {
  function DragControls2() {
    this.componentControls = /* @__PURE__ */ new Set();
  }
  DragControls2.prototype.subscribe = function(controls2) {
    var _this = this;
    this.componentControls.add(controls2);
    return function() {
      return _this.componentControls.delete(controls2);
    };
  };
  DragControls2.prototype.start = function(event, options) {
    this.componentControls.forEach(function(controls2) {
      controls2.start(event.nativeEvent || event, options);
    });
  };
  DragControls2.prototype.updateConstraints = function() {
    this.componentControls.forEach(function(controls2) {
      controls2.prepareBoundingBox();
      controls2.resolveDragConstraints();
    });
  };
  return DragControls2;
}();
var createDragControls = function() {
  return new DragControls();
};
function useDragControls() {
  return useConstant(createDragControls);
}
function useExternalRef(externalRef) {
  var ref = !externalRef || typeof externalRef === "function" ? (0, import_react.useRef)(null) : externalRef;
  if (externalRef && typeof externalRef === "function") {
    (0, import_react.useEffect)(function() {
      externalRef(ref.current);
      return function() {
        return externalRef(null);
      };
    }, []);
  }
  return ref;
}
var StateVisualElement = function(_super) {
  __extends(StateVisualElement2, _super);
  function StateVisualElement2() {
    var _this = _super !== null && _super.apply(this, arguments) || this;
    _this.initialState = {};
    return _this;
  }
  StateVisualElement2.prototype.updateLayoutDelta = function() {
  };
  StateVisualElement2.prototype.build = function() {
  };
  StateVisualElement2.prototype.clean = function() {
  };
  StateVisualElement2.prototype.makeTargetAnimatable = function(_a) {
    var transition = _a.transition, transitionEnd = _a.transitionEnd, target2 = __rest(_a, ["transition", "transitionEnd"]);
    var origin = getOrigin(target2, transition || {}, this);
    checkTargetForNewValues(this, target2, origin);
    return __assign({ transition, transitionEnd }, target2);
  };
  StateVisualElement2.prototype.getBoundingBox = function() {
    return { x: { min: 0, max: 0 }, y: { min: 0, max: 0 } };
  };
  StateVisualElement2.prototype.readNativeValue = function(key) {
    return this.initialState[key] || 0;
  };
  StateVisualElement2.prototype.render = function() {
    this.build();
  };
  return StateVisualElement2;
}(VisualElement);
function useAnimatedState(initialState) {
  var _a = __read((0, import_react.useState)(initialState), 2), animationState = _a[0], setAnimationState = _a[1];
  var visualElement = useConstant(function() {
    return new StateVisualElement();
  });
  visualElement.updateConfig({
    onUpdate: function(v) {
      return setAnimationState(__assign({}, v));
    }
  });
  visualElement.initialState = initialState;
  (0, import_react.useEffect)(function() {
    visualElement.mount({});
    return function() {
      return visualElement.unmount();
    };
  }, []);
  var startAnimation2 = useConstant(function() {
    return function(animationDefinition) {
      return startVisualElementAnimation(visualElement, animationDefinition);
    };
  });
  return [animationState, startAnimation2];
}
export {
  AnimateLayout as AnimateLayoutFeature,
  AnimatePresence,
  AnimateSharedLayout,
  AnimationControls,
  Animation as AnimationFeature,
  DragControls,
  Drag as DragFeature,
  Exit as ExitFeature,
  FramerTreeLayoutContext,
  Gestures as GesturesFeature,
  HTMLVisualElement,
  MotionConfig,
  MotionConfigContext,
  MotionValue,
  PresenceContext,
  SharedLayoutContext,
  VisibilityAction,
  addScaleCorrection,
  animate2 as animate,
  animationControls,
  createBatcher,
  createDomMotionComponent,
  createMotionComponent,
  isValidMotionProp,
  m,
  motion,
  motionValue,
  resolveMotionValue,
  startAnimation,
  startVisualElementAnimation,
  transform,
  useAnimatedState,
  useAnimation,
  useCycle,
  useDomEvent,
  useDragControls,
  useElementScroll,
  useExternalRef,
  useGestures,
  useInvertedScale,
  useIsPresent,
  useMotionTemplate,
  useMotionValue,
  usePanGesture,
  usePresence,
  useReducedMotion,
  useSpring,
  useTapGesture,
  useTransform,
  useViewportScroll
};
/*! *****************************************************************************
Copyright (c) Microsoft Corporation.

Permission to use, copy, modify, and/or distribute this software for any
purpose with or without fee is hereby granted.

THE SOFTWARE IS PROVIDED "AS IS" AND THE AUTHOR DISCLAIMS ALL WARRANTIES WITH
REGARD TO THIS SOFTWARE INCLUDING ALL IMPLIED WARRANTIES OF MERCHANTABILITY
AND FITNESS. IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR ANY SPECIAL, DIRECT,
INDIRECT, OR CONSEQUENTIAL DAMAGES OR ANY DAMAGES WHATSOEVER RESULTING FROM
LOSS OF USE, DATA OR PROFITS, WHETHER IN AN ACTION OF CONTRACT, NEGLIGENCE OR
OTHER TORTIOUS ACTION, ARISING OUT OF OR IN CONNECTION WITH THE USE OR
PERFORMANCE OF THIS SOFTWARE.
***************************************************************************** */
//# sourceMappingURL=framer-motion.js.map
