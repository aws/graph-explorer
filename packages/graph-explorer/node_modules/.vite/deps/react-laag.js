import {
  require_react_dom
} from "./chunk-4OZ5FRL3.js";
import {
  require_react
} from "./chunk-57SFASAQ.js";
import {
  __toESM
} from "./chunk-S5KM4IGW.js";

// ../../node_modules/.pnpm/react-laag@2.0.4_react-dom@17.0.2_react@17.0.2/node_modules/react-laag/dist/react-laag.esm.js
var import_react = __toESM(require_react());
var import_react_dom = __toESM(require_react_dom());

// ../../node_modules/.pnpm/tiny-warning@1.0.3/node_modules/tiny-warning/dist/tiny-warning.esm.js
var isProduction = false;
function warning(condition, message) {
  if (!isProduction) {
    if (condition) {
      return;
    }
    var text = "Warning: " + message;
    if (typeof console !== "undefined") {
      console.warn(text);
    }
    try {
      throw Error(text);
    } catch (x) {
    }
  }
}
var tiny_warning_esm_default = warning;

// ../../node_modules/.pnpm/react-laag@2.0.4_react-dom@17.0.2_react@17.0.2/node_modules/react-laag/dist/react-laag.esm.js
function _defineProperties(target, props) {
  for (var i = 0; i < props.length; i++) {
    var descriptor = props[i];
    descriptor.enumerable = descriptor.enumerable || false;
    descriptor.configurable = true;
    if ("value" in descriptor)
      descriptor.writable = true;
    Object.defineProperty(target, descriptor.key, descriptor);
  }
}
function _createClass(Constructor, protoProps, staticProps) {
  if (protoProps)
    _defineProperties(Constructor.prototype, protoProps);
  if (staticProps)
    _defineProperties(Constructor, staticProps);
  return Constructor;
}
function _extends() {
  _extends = Object.assign || function(target) {
    for (var i = 1; i < arguments.length; i++) {
      var source = arguments[i];
      for (var key in source) {
        if (Object.prototype.hasOwnProperty.call(source, key)) {
          target[key] = source[key];
        }
      }
    }
    return target;
  };
  return _extends.apply(this, arguments);
}
function _inheritsLoose(subClass, superClass) {
  subClass.prototype = Object.create(superClass.prototype);
  subClass.prototype.constructor = subClass;
  _setPrototypeOf(subClass, superClass);
}
function _setPrototypeOf(o, p) {
  _setPrototypeOf = Object.setPrototypeOf || function _setPrototypeOf2(o2, p2) {
    o2.__proto__ = p2;
    return o2;
  };
  return _setPrototypeOf(o, p);
}
function _objectWithoutPropertiesLoose(source, excluded) {
  if (source == null)
    return {};
  var target = {};
  var sourceKeys = Object.keys(source);
  var key, i;
  for (i = 0; i < sourceKeys.length; i++) {
    key = sourceKeys[i];
    if (excluded.indexOf(key) >= 0)
      continue;
    target[key] = source[key];
  }
  return target;
}
function _unsupportedIterableToArray(o, minLen) {
  if (!o)
    return;
  if (typeof o === "string")
    return _arrayLikeToArray(o, minLen);
  var n = Object.prototype.toString.call(o).slice(8, -1);
  if (n === "Object" && o.constructor)
    n = o.constructor.name;
  if (n === "Map" || n === "Set")
    return Array.from(o);
  if (n === "Arguments" || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(n))
    return _arrayLikeToArray(o, minLen);
}
function _arrayLikeToArray(arr, len) {
  if (len == null || len > arr.length)
    len = arr.length;
  for (var i = 0, arr2 = new Array(len); i < len; i++)
    arr2[i] = arr[i];
  return arr2;
}
function _createForOfIteratorHelperLoose(o, allowArrayLike) {
  var it = typeof Symbol !== "undefined" && o[Symbol.iterator] || o["@@iterator"];
  if (it)
    return (it = it.call(o)).next.bind(it);
  if (Array.isArray(o) || (it = _unsupportedIterableToArray(o)) || allowArrayLike && o && typeof o.length === "number") {
    if (it)
      o = it;
    var i = 0;
    return function() {
      if (i >= o.length)
        return {
          done: true
        };
      return {
        done: false,
        value: o[i++]
      };
    };
  }
  throw new TypeError("Invalid attempt to iterate non-iterable instance.\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method.");
}
function useTrackRef(onRefChange) {
  var storedReference = (0, import_react.useRef)(null);
  function setter(element) {
    if (!element || element === storedReference.current) {
      return;
    }
    storedReference.current = element;
    onRefChange(element);
  }
  return setter;
}
function useMutableStore(initialState) {
  var state = (0, import_react.useRef)(initialState);
  return (0, import_react.useMemo)(function() {
    function set(setter) {
      if (typeof setter === "function") {
        state.current = setter(state.current);
      } else {
        state.current = setter;
      }
    }
    function get() {
      return state.current;
    }
    return [get, set];
  }, []);
}
function useEventSubscriptions() {
  var subscriptions = (0, import_react.useRef)([]);
  return (0, import_react.useMemo)(function() {
    function hasEventSubscriptions() {
      return subscriptions.current.length > 0;
    }
    function removeAllEventSubscriptions() {
      for (var _iterator = _createForOfIteratorHelperLoose(subscriptions.current), _step; !(_step = _iterator()).done; ) {
        var unsubscribe = _step.value;
        unsubscribe();
      }
      subscriptions.current = [];
    }
    function addEventSubscription(unsubscriber) {
      subscriptions.current.push(unsubscriber);
    }
    return {
      hasEventSubscriptions,
      removeAllEventSubscriptions,
      addEventSubscription
    };
  }, []);
}
var useIsomorphicLayoutEffect = typeof window !== "undefined" ? import_react.useLayoutEffect : import_react.useEffect;
function useLastState(currentState, enabled) {
  var lastState = (0, import_react.useRef)(currentState);
  if (!enabled) {
    lastState.current = null;
    return lastState;
  }
  lastState.current = currentState;
  return lastState;
}
var EMPTY_BOUNDS = {
  top: 0,
  left: 0,
  right: 1,
  bottom: 1,
  width: 1,
  height: 1
};
function useMousePositionAsTrigger(_temp) {
  var _ref = _temp === void 0 ? {} : _temp, _ref$enabled = _ref.enabled, enabled = _ref$enabled === void 0 ? true : _ref$enabled, _ref$preventDefault = _ref.preventDefault, preventDefault = _ref$preventDefault === void 0 ? true : _ref$preventDefault;
  var parentRef = (0, import_react.useRef)(null);
  var _useState = (0, import_react.useState)(EMPTY_BOUNDS), mouseBounds = _useState[0], setMouseBounds = _useState[1];
  function resetMousePosition() {
    setMouseBounds(EMPTY_BOUNDS);
  }
  var hasMousePosition = mouseBounds !== EMPTY_BOUNDS;
  function handleMouseEvent(evt) {
    if (!enabled) {
      return;
    }
    if (preventDefault) {
      evt.preventDefault();
    }
    var left = evt.clientX, top = evt.clientY;
    setMouseBounds({
      top,
      left,
      width: 1,
      height: 1,
      right: left + 1,
      bottom: top + 1
    });
  }
  return {
    hasMousePosition,
    resetMousePosition,
    handleMouseEvent,
    trigger: {
      getBounds: function getBounds() {
        return mouseBounds;
      },
      getParent: parentRef.current ? function() {
        return parentRef.current;
      } : void 0
    },
    parentRef
  };
}
function getPixelValue(value) {
  return parseFloat(value.replace("px", ""));
}
function limit(value, min, max) {
  return value < min ? min : value > max ? max : value;
}
function isSet(value) {
  return value === null || value === void 0 ? false : true;
}
function mergeRefs() {
  for (var _len = arguments.length, refs = new Array(_len), _key = 0; _key < _len; _key++) {
    refs[_key] = arguments[_key];
  }
  return function(element) {
    for (var _iterator = _createForOfIteratorHelperLoose(refs), _step; !(_step = _iterator()).done; ) {
      var ref = _step.value;
      if (!ref) {
        continue;
      }
      if (typeof ref === "function") {
        ref(element);
      } else {
        ref.current = element;
      }
    }
  };
}
function getResizeObserver(environment, polyfill) {
  if (typeof environment === "undefined") {
    return void 0;
  }
  return polyfill || environment.ResizeObserver;
}
function findScrollContainers(element, environment) {
  var result = [];
  if (!element || !environment || element === document.body) {
    return result;
  }
  var _environment$getCompu = environment.getComputedStyle(element), overflow = _environment$getCompu.overflow, overflowX = _environment$getCompu.overflowX, overflowY = _environment$getCompu.overflowY;
  if ([overflow, overflowX, overflowY].some(function(prop) {
    return ["auto", "scroll"].includes(prop);
  })) {
    result.push(element);
  }
  return [].concat(result, findScrollContainers(element.parentElement, environment));
}
function createReferenceError(subject) {
  return "react-laag: Could not find a valid reference for the " + subject + " element. There might be 2 causes:\n   - Make sure that the 'ref' is set correctly on the " + subject + ' element when isOpen: true. Also make sure your component forwards the ref with "forwardRef()".\n   - Make sure that you are actually rendering the ' + subject + " when the isOpen prop is set to true";
}
function useTrackElements(_ref) {
  var enabled = _ref.enabled, onChange = _ref.onChange, environment = _ref.environment, ResizeObserverPolyfill = _ref.ResizeObserverPolyfill, overflowContainer = _ref.overflowContainer, triggerOption = _ref.triggerOption;
  var ResizeObserver = getResizeObserver(environment, ResizeObserverPolyfill);
  (0, import_react.useEffect)(function() {
    true ? tiny_warning_esm_default(ResizeObserver, "This browser does not support ResizeObserver out of the box. We recommend to add a polyfill in order to utilize the full capabilities of react-laag. See: https://github.com/everweij/react-laag#resize-observer") : void 0;
  }, [ResizeObserver]);
  var arrowRef = (0, import_react.useRef)(null);
  var hasTriggerOption = Boolean(triggerOption);
  var _useMutableStore = useMutableStore({
    scrollContainers: [],
    trigger: null,
    layer: null
  }), get = _useMutableStore[0], set = _useMutableStore[1];
  var _useEventSubscription = useEventSubscriptions(), hasEventSubscriptions = _useEventSubscription.hasEventSubscriptions, addEventSubscription = _useEventSubscription.addEventSubscription, removeAllEventSubscriptions = _useEventSubscription.removeAllEventSubscriptions;
  var handleChange = (0, import_react.useCallback)(function handleChange2() {
    var _get = get(), layer = _get.layer, trigger = _get.trigger, scrollContainers = _get.scrollContainers;
    var closestScrollContainer = scrollContainers[0];
    if (!layer) {
      throw new Error(createReferenceError("layer"));
    }
    if (!trigger && !hasTriggerOption) {
      throw new Error(createReferenceError("trigger"));
    }
    var scrollOffsets = {
      top: 0,
      left: 0
    };
    if (closestScrollContainer) {
      var scrollLeft = closestScrollContainer.scrollLeft, scrollTop = closestScrollContainer.scrollTop;
      scrollOffsets = {
        top: scrollTop,
        left: scrollLeft
      };
    } else {
      var scrollX = environment.scrollX, scrollY = environment.scrollY;
      scrollOffsets = {
        top: scrollY,
        left: scrollX
      };
    }
    var borderOffsets = {
      left: 0,
      top: 0
    };
    if (closestScrollContainer) {
      var _environment$getCompu2 = environment.getComputedStyle(closestScrollContainer), borderLeftWidth = _environment$getCompu2.borderLeftWidth, borderTopWidth = _environment$getCompu2.borderTopWidth;
      borderOffsets = {
        left: getPixelValue(borderLeftWidth) || 0,
        top: getPixelValue(borderTopWidth) || 0
      };
    }
    onChange({
      layer,
      trigger,
      scrollContainers,
      arrow: arrowRef.current
    }, scrollOffsets, borderOffsets);
  }, [get, onChange, environment, arrowRef, hasTriggerOption]);
  var addEventListeners = (0, import_react.useCallback)(function addEventListeners2() {
    var _get2 = get(), trigger = _get2.trigger, layer = _get2.layer, scrollContainers = _get2.scrollContainers;
    if (!layer) {
      throw new Error(createReferenceError("layer"));
    }
    if (!trigger && !hasTriggerOption) {
      throw new Error(createReferenceError("trigger"));
    }
    if (ResizeObserver) {
      var ignoredInitialCall = false;
      var observerCallback = function observerCallback2() {
        if (!ignoredInitialCall) {
          ignoredInitialCall = true;
          return;
        }
        handleChange();
      };
      var observer = new ResizeObserver(observerCallback);
      for (var _i = 0, _arr = [trigger, layer, document.body]; _i < _arr.length; _i++) {
        var element = _arr[_i];
        if (element)
          observer.observe(element);
      }
      addEventSubscription(function() {
        for (var _i2 = 0, _arr2 = [trigger, layer, document.body]; _i2 < _arr2.length; _i2++) {
          var _element = _arr2[_i2];
          if (_element)
            observer.unobserve(_element);
        }
        observer.disconnect();
      });
    }
    var listenForScrollElements = [environment].concat(scrollContainers);
    var _loop = function _loop2() {
      var element2 = _step.value;
      element2.addEventListener("scroll", handleChange);
      addEventSubscription(function() {
        return element2.removeEventListener("scroll", handleChange);
      });
    };
    for (var _iterator = _createForOfIteratorHelperLoose(listenForScrollElements), _step; !(_step = _iterator()).done; ) {
      _loop();
    }
  }, [get, addEventSubscription, handleChange, environment, ResizeObserver, hasTriggerOption]);
  var resetWhenReferenceChangedWhileTracking = (0, import_react.useCallback)(function(previous, next) {
    if (enabled && previous && previous !== next) {
      removeAllEventSubscriptions();
      addEventListeners();
      handleChange();
    }
  }, [removeAllEventSubscriptions, addEventListeners, handleChange, enabled]);
  var layerRef = useTrackRef((0, import_react.useCallback)(function(layer) {
    var _get3 = get(), previousLayer = _get3.layer;
    set(function(state) {
      return _extends({}, state, {
        layer
      });
    });
    resetWhenReferenceChangedWhileTracking(previousLayer, layer);
  }, [get, set, resetWhenReferenceChangedWhileTracking]));
  var getScrollContainers = (0, import_react.useCallback)(function handleScrollContainers(element) {
    var scrollContainers = findScrollContainers(element, environment);
    var closestScrollContainer = scrollContainers[0];
    if (closestScrollContainer) {
      var position = environment.getComputedStyle(closestScrollContainer).position;
      var closestScrollContainerHasCorrectStyling = ["relative", "absolute", "fixed"].includes(position) || overflowContainer;
      if (!closestScrollContainerHasCorrectStyling) {
        closestScrollContainer.style.position = "relative";
      }
      true ? tiny_warning_esm_default(closestScrollContainerHasCorrectStyling, `react-laag: Set the 'position' style of the nearest scroll-container to 'relative', 'absolute' or 'fixed', or set the 'overflowContainer' prop to true. This is needed in order to position the layer properly. Currently the scroll-container is positioned: "` + position + '". For now, "position: relative;" is added for you, but this behavior might be removed in the future. Visit https://react-laag.com/docs/#position-relative for more info.') : void 0;
    }
    return scrollContainers;
  }, [environment, overflowContainer]);
  var triggerRef = useTrackRef((0, import_react.useCallback)(function(trigger) {
    var scrollContainers = getScrollContainers(trigger);
    var _get4 = get(), previousTrigger = _get4.trigger;
    set(function(state) {
      return _extends({}, state, {
        trigger,
        scrollContainers
      });
    });
    resetWhenReferenceChangedWhileTracking(previousTrigger, trigger);
  }, [get, set, resetWhenReferenceChangedWhileTracking, getScrollContainers]));
  var triggerOptionParent = triggerOption == null ? void 0 : triggerOption.getParent == null ? void 0 : triggerOption.getParent();
  useIsomorphicLayoutEffect(function() {
    if (!triggerOptionParent) {
      return;
    }
    set(function(state) {
      return _extends({}, state, {
        scrollContainers: getScrollContainers(triggerOptionParent)
      });
    });
  }, [triggerOptionParent, set, getScrollContainers]);
  useIsomorphicLayoutEffect(function() {
    if (enabled) {
      if (!hasEventSubscriptions()) {
        addEventListeners();
      }
    }
    return function() {
      if (hasEventSubscriptions()) {
        removeAllEventSubscriptions();
      }
    };
  }, [enabled, hasEventSubscriptions, addEventListeners, removeAllEventSubscriptions]);
  useIsomorphicLayoutEffect(function() {
    if (enabled) {
      handleChange();
    }
  });
  return {
    triggerRef,
    layerRef,
    arrowRef,
    closestScrollContainer: get().scrollContainers[0] || null
  };
}
var GroupContext = (0, import_react.createContext)({});
function GroupProvider(_ref) {
  var children = _ref.children, registrations = _ref.registrations;
  var handleRegister = (0, import_react.useCallback)(function register(registration) {
    registrations.current.add(registration);
    return function() {
      return registrations.current.delete(registration);
    };
  }, [registrations]);
  return (0, import_react.createElement)(GroupContext.Provider, {
    value: handleRegister
  }, children);
}
function getShouldCloseAccordingToChildren(registrations, event) {
  for (var _iterator = _createForOfIteratorHelperLoose(registrations), _step; !(_step = _iterator()).done; ) {
    var shouldCloseWhenClickedOutside = _step.value.shouldCloseWhenClickedOutside;
    if (!shouldCloseWhenClickedOutside(event)) {
      return false;
    }
  }
  return true;
}
function useGroup(_ref2) {
  var isOpen = _ref2.isOpen, onOutsideClick = _ref2.onOutsideClick, onParentClose = _ref2.onParentClose;
  var trigger = (0, import_react.useRef)(null);
  var layer = (0, import_react.useRef)(null);
  var registrations = (0, import_react.useRef)(/* @__PURE__ */ new Set());
  var possibleRegisterFn = (0, import_react.useContext)(GroupContext);
  var shouldCloseWhenClickedOutside = (0, import_react.useCallback)(function shouldCloseWhenClickedOutside2(event) {
    var target = event.target;
    var clickedOnTrigger = trigger.current && trigger.current.contains(target);
    var clickedOnLayer = layer.current && layer.current.contains(target);
    var shouldCloseAccordingToChildren = getShouldCloseAccordingToChildren(registrations.current, event);
    if (clickedOnLayer && shouldCloseAccordingToChildren) {
      registrations.current.forEach(function(_ref3) {
        var closeChild = _ref3.closeChild;
        return closeChild();
      });
    }
    return !clickedOnTrigger && !clickedOnLayer && shouldCloseAccordingToChildren;
  }, [trigger, layer, registrations]);
  (0, import_react.useEffect)(function() {
    if (typeof possibleRegisterFn !== "function") {
      return;
    }
    return possibleRegisterFn({
      shouldCloseWhenClickedOutside,
      closeChild: function closeChild() {
        true ? tiny_warning_esm_default(onParentClose, "react-laag: You are using useLayer() in a nested setting but forgot to set the 'onParentClose()' callback in the options. This could lead to unexpected behavior.") : void 0;
        if (onParentClose) {
          onParentClose();
        }
      }
    });
  }, [possibleRegisterFn, shouldCloseWhenClickedOutside, onParentClose, registrations]);
  (0, import_react.useEffect)(function() {
    var isChild = typeof possibleRegisterFn === "function";
    var shouldNotListen = !isOpen || !onOutsideClick || isChild;
    if (shouldNotListen) {
      return;
    }
    function handleClick(event) {
      if (shouldCloseWhenClickedOutside(event)) {
        onOutsideClick();
      }
    }
    document.addEventListener("click", handleClick, true);
    return function() {
      return document.removeEventListener("click", handleClick, true);
    };
  }, [isOpen, onOutsideClick, shouldCloseWhenClickedOutside, possibleRegisterFn]);
  (0, import_react.useEffect)(function() {
    if (!isOpen) {
      registrations.current.forEach(function(_ref4) {
        var closeChild = _ref4.closeChild;
        return closeChild();
      });
    }
  }, [isOpen]);
  return {
    closeOnOutsideClickRefs: {
      trigger,
      layer
    },
    registrations
  };
}
var PLACEMENT_TYPES = ["bottom-start", "bottom-end", "bottom-center", "top-start", "top-center", "top-end", "left-end", "left-center", "left-start", "right-end", "right-center", "right-start", "center"];
var OPPOSITES = {
  top: "bottom",
  left: "right",
  bottom: "top",
  right: "left",
  center: "center"
};
var SideBase = function() {
  function SideBase2(prop, opposite, isHorizontal, sizeProp, oppositeSizeProp, cssProp, oppositeCssProp, isCenter, isPush) {
    this.prop = void 0;
    this.opposite = void 0;
    this.isHorizontal = void 0;
    this.sizeProp = void 0;
    this.oppositeSizeProp = void 0;
    this.cssProp = void 0;
    this.oppositeCssProp = void 0;
    this.isCenter = void 0;
    this.isPush = void 0;
    this.prop = prop;
    this.opposite = opposite;
    this.isHorizontal = isHorizontal;
    this.sizeProp = sizeProp;
    this.oppositeSizeProp = oppositeSizeProp;
    this.cssProp = cssProp;
    this.oppositeCssProp = oppositeCssProp;
    this.isCenter = isCenter;
    this.isPush = isPush;
  }
  var _proto = SideBase2.prototype;
  _proto.factor = function factor(value) {
    return value * (this.isPush ? 1 : -1);
  };
  _proto.isOppositeDirection = function isOppositeDirection(side) {
    return this.isHorizontal !== side.isHorizontal;
  };
  return SideBase2;
}();
function createSide(prop, recursive) {
  if (recursive === void 0) {
    recursive = true;
  }
  var isHorizontal = ["left", "right"].includes(prop);
  return new SideBase(prop, recursive ? createSide(OPPOSITES[prop], false) : null, isHorizontal, isHorizontal ? "width" : "height", isHorizontal ? "height" : "width", isHorizontal ? "left" : "top", isHorizontal ? "top" : "left", prop === "center", !["right", "bottom"].includes(prop));
}
var BoundSide = {
  top: createSide("top"),
  bottom: createSide("bottom"),
  left: createSide("left"),
  right: createSide("right")
};
var Side = _extends({}, BoundSide, {
  center: createSide("center")
});
var SIDES = ["top", "left", "bottom", "right"];
var BoundsOffsets = function() {
  function BoundsOffsets2(offsets) {
    this.top = void 0;
    this.left = void 0;
    this.right = void 0;
    this.bottom = void 0;
    return Object.assign(this, offsets);
  }
  BoundsOffsets2.mergeSmallestSides = function mergeSmallestSides(boundsOffsets) {
    var first = boundsOffsets[0], rest = boundsOffsets.slice(1);
    if (!first) {
      throw new Error("Please provide at least 1 bounds objects in order to merge");
    }
    var result = Object.fromEntries(SIDES.map(function(side2) {
      return [side2, first[side2]];
    }));
    for (var _iterator = _createForOfIteratorHelperLoose(rest), _step; !(_step = _iterator()).done; ) {
      var boundsOffset = _step.value;
      for (var _iterator2 = _createForOfIteratorHelperLoose(SIDES), _step2; !(_step2 = _iterator2()).done; ) {
        var side = _step2.value;
        result[side] = Math.min(result[side], boundsOffset[side]);
      }
    }
    return new BoundsOffsets2(result);
  };
  _createClass(BoundsOffsets2, [{
    key: "allSidesArePositive",
    get: function get() {
      var _this = this;
      return SIDES.every(function(side) {
        return _this[side] >= 0;
      });
    }
  }, {
    key: "negativeSides",
    get: function get() {
      var _this2 = this;
      return Object.fromEntries(SIDES.filter(function(side) {
        return _this2[side] < 0;
      }).map(function(side) {
        return [side, _this2[side]];
      }));
    }
  }]);
  return BoundsOffsets2;
}();
function sumOfPropertyValues() {
  for (var _len = arguments.length, propertyValues = new Array(_len), _key = 0; _key < _len; _key++) {
    propertyValues[_key] = arguments[_key];
  }
  return propertyValues.reduce(function(sum, propertyValue) {
    return sum + (propertyValue ? getPixelValue(propertyValue) : 0);
  }, 0);
}
function boundsToObject(_ref) {
  var top = _ref.top, left = _ref.left, right = _ref.right, bottom = _ref.bottom, width = _ref.width, height = _ref.height;
  return {
    top,
    left,
    right,
    bottom,
    width,
    height
  };
}
var EMPTY = {
  top: 0,
  left: 0,
  right: 0,
  bottom: 0,
  width: 0,
  height: 0
};
var Bounds = function() {
  Bounds2.create = function create(bounds) {
    return new Bounds2(bounds);
  };
  Bounds2.fromElement = function fromElement(element, options) {
    if (options === void 0) {
      options = {};
    }
    var _options = options, _options$withTransfor = _options.withTransform, withTransform = _options$withTransfor === void 0 ? true : _options$withTransfor, _options$environment = _options.environment, environment = _options$environment === void 0 ? window : _options$environment, _options$withScrollba = _options.withScrollbars, withScrollbars = _options$withScrollba === void 0 ? true : _options$withScrollba;
    var plain = boundsToObject(element.getBoundingClientRect());
    var bounds = new Bounds2(plain);
    if (!withTransform) {
      var _environment$getCompu = environment.getComputedStyle(element), width = _environment$getCompu.width, height = _environment$getCompu.height, boxSizing = _environment$getCompu.boxSizing, borderLeft = _environment$getCompu.borderLeft, borderRight = _environment$getCompu.borderRight, borderTop = _environment$getCompu.borderTop, borderBottom = _environment$getCompu.borderBottom, paddingLeft = _environment$getCompu.paddingLeft, paddingRight = _environment$getCompu.paddingRight, paddingTop = _environment$getCompu.paddingTop, paddingBottom = _environment$getCompu.paddingBottom;
      var boxWidth = boxSizing === "border-box" ? getPixelValue(width) : sumOfPropertyValues(width, borderLeft, borderRight, paddingLeft, paddingRight);
      var boxHeight = boxSizing === "border-box" ? getPixelValue(height) : sumOfPropertyValues(height, borderTop, borderBottom, paddingTop, paddingBottom);
      bounds = new Bounds2(_extends({}, bounds, {
        width: boxWidth,
        height: boxHeight
      }));
    }
    if (!withScrollbars) {
      var scrollbarWidth = bounds.width - element.clientWidth;
      var scrollbarHeight = bounds.height - element.clientHeight;
      return bounds.substract({
        right: scrollbarWidth,
        bottom: scrollbarHeight
      });
    }
    return bounds;
  };
  Bounds2.empty = function empty() {
    return new Bounds2();
  };
  Bounds2.fromWindow = function fromWindow(environment) {
    var _environment$document;
    var scrollingElement = (_environment$document = environment == null ? void 0 : environment.document.scrollingElement) != null ? _environment$document : environment == null ? void 0 : environment.document.documentElement;
    var _ref2 = scrollingElement != null ? scrollingElement : {}, _ref2$clientWidth = _ref2.clientWidth, width = _ref2$clientWidth === void 0 ? 0 : _ref2$clientWidth, _ref2$clientHeight = _ref2.clientHeight, height = _ref2$clientHeight === void 0 ? 0 : _ref2$clientHeight;
    return new Bounds2({
      width,
      height,
      right: width,
      bottom: height
    });
  };
  function Bounds2(bounds) {
    if (bounds === void 0) {
      bounds = {};
    }
    this.top = void 0;
    this.left = void 0;
    this.right = void 0;
    this.bottom = void 0;
    this.width = void 0;
    this.height = void 0;
    return Object.assign(this, EMPTY, bounds);
  }
  var _proto = Bounds2.prototype;
  _proto.toObject = function toObject() {
    return boundsToObject(this);
  };
  _proto.merge = function merge(partialBoundsOrMergeFn) {
    var current = this.toObject();
    return new Bounds2(_extends({}, current, typeof partialBoundsOrMergeFn === "function" ? partialBoundsOrMergeFn(current) : partialBoundsOrMergeFn));
  };
  _proto.substract = function substract(bounds) {
    var result = this.toObject();
    var entries = Object.entries(bounds);
    for (var _i = 0, _entries = entries; _i < _entries.length; _i++) {
      var _entries$_i = _entries[_i], prop = _entries$_i[0], value = _entries$_i[1];
      if (prop in BoundSide) {
        var boundSide = BoundSide[prop];
        result[prop] += boundSide.factor(value);
        result[boundSide.isHorizontal ? "width" : "height"] -= value;
      } else {
        result[prop] -= value || 0;
      }
    }
    return new Bounds2(result);
  };
  _proto.offsetsTo = function offsetsTo(child) {
    return new BoundsOffsets({
      top: child.top - this.top,
      bottom: this.bottom - child.bottom,
      left: child.left - this.left,
      right: this.right - child.right
    });
  };
  _proto.mapSides = function mapSides(mapper) {
    var result = this.toObject();
    var boundSides = Object.values(BoundSide);
    for (var _i2 = 0, _boundSides = boundSides; _i2 < _boundSides.length; _i2++) {
      var boundSide = _boundSides[_i2];
      result[boundSide.prop] = mapper(boundSide, result[boundSide.prop]);
    }
    return new Bounds2(result);
  };
  _createClass(Bounds2, [{
    key: "surface",
    get: function get() {
      return this.width * this.height;
    }
  }]);
  return Bounds2;
}();
var Placement = function() {
  function Placement2(primary, secondary, subjectBounds, layerDimensions, offsets) {
    this.primary = void 0;
    this.secondary = void 0;
    this.offsets = void 0;
    this.subjectsBounds = void 0;
    this._cachedLayerBounds = null;
    this._cachedContainerOffsets = null;
    this.primary = primary;
    this.secondary = secondary;
    this.offsets = offsets;
    this.setSubjectsBounds(subjectBounds, layerDimensions);
  }
  var _proto = Placement2.prototype;
  _proto.setSubjectsBounds = function setSubjectsBounds(subjectBounds, layerDimensions) {
    if (!layerDimensions) {
      this.subjectsBounds = subjectBounds;
      return;
    }
    var dimensions = typeof layerDimensions === "function" ? layerDimensions(this.primary.prop) : layerDimensions;
    this.subjectsBounds = subjectBounds.merge({
      layer: _extends({}, subjectBounds.layer, dimensions)
    });
  };
  _proto.getLayerBounds = function getLayerBounds(secondaryOffset) {
    if (secondaryOffset === void 0) {
      secondaryOffset = 0;
    }
    if (this._cachedLayerBounds && secondaryOffset === 0) {
      return this._cachedLayerBounds;
    }
    var primary = this.primary, secondary = this.secondary, subjectsBounds = this.subjectsBounds;
    var trigger = subjectsBounds.trigger, layer = subjectsBounds.layer, arrow = subjectsBounds.arrow;
    var isHorizontal = primary.isHorizontal, oppositeCssProp = primary.oppositeCssProp, oppositeSizeProp = primary.oppositeSizeProp, prop = primary.prop, opposite = primary.opposite;
    var result = Bounds.empty();
    result[opposite.prop] = trigger[prop] - primary.factor(this.offsets.trigger);
    result[prop] = result[opposite.prop] - primary.factor(layer[primary.sizeProp]);
    var arrowOffsetBase = this.offsets.arrow * 2;
    var limitMin = trigger[oppositeCssProp] - (layer[oppositeSizeProp] - arrow[oppositeSizeProp]) + arrowOffsetBase;
    var limitMax = trigger[oppositeCssProp] + (trigger[oppositeSizeProp] - arrow[oppositeSizeProp]) - arrowOffsetBase;
    if (!secondary.isPush) {
      limitMin += layer[oppositeSizeProp];
      limitMax += layer[oppositeSizeProp];
    }
    if (secondary.isCenter) {
      var propertyA = (isHorizontal ? BoundSide.top : BoundSide.left).prop;
      var propertyB = (isHorizontal ? BoundSide.bottom : BoundSide.right).prop;
      result[propertyA] = limit(trigger[propertyA] + trigger[oppositeSizeProp] / 2 - layer[oppositeSizeProp] / 2 + secondaryOffset, limitMin, limitMax);
      result[propertyB] = result[propertyA] + layer[oppositeSizeProp];
    } else {
      var sec = secondary;
      var triggerValue = trigger[sec.prop];
      var arrowCompensation = triggerValue < limitMin ? limitMin - triggerValue : triggerValue > limitMax ? limitMax - triggerValue : 0;
      result[sec.prop] = limit(triggerValue + secondaryOffset + arrowCompensation, limitMin, limitMax);
      result[sec.opposite.prop] = result[sec.prop] + secondary.factor(layer[oppositeSizeProp]);
    }
    result.width = result.right - result.left;
    result.height = result.bottom - result.top;
    var layerBounds = Bounds.create(result);
    if (secondaryOffset === 0) {
      this._cachedLayerBounds = layerBounds;
    }
    return layerBounds;
  };
  _proto.getLayerCollisionBounds = function getLayerCollisionBounds() {
    var container = this.offsets.container;
    return this.getLayerBounds().mapSides(function(side, value) {
      return value -= side.factor(container);
    }).merge(function(_ref) {
      var width = _ref.width, height = _ref.height;
      return {
        width: width + container * 2,
        height: height + container * 2
      };
    });
  };
  _proto.getContainerOffsets = function getContainerOffsets(layerBounds) {
    if (this._cachedContainerOffsets && !layerBounds) {
      return this._cachedContainerOffsets;
    }
    var subjectBounds = this.subjectsBounds.merge({
      layer: layerBounds || this.getLayerCollisionBounds()
    });
    var offsets = BoundsOffsets.mergeSmallestSides(subjectBounds.layerOffsetsToScrollContainers);
    if (!layerBounds) {
      this._cachedContainerOffsets = offsets;
    }
    return offsets;
  };
  _createClass(Placement2, [{
    key: "type",
    get: function get() {
      return this.primary.prop + "-" + (this.secondary.prop === "center" ? "center" : ["bottom", "right"].includes(this.secondary.prop) ? "end" : "start");
    }
  }, {
    key: "triggerIsBigger",
    get: function get() {
      var isHorizontal = this.secondary.isHorizontal;
      var _this$subjectsBounds = this.subjectsBounds, triggerHasBiggerWidth = _this$subjectsBounds.triggerHasBiggerWidth, triggerHasBiggerHeight = _this$subjectsBounds.triggerHasBiggerHeight;
      return isHorizontal && triggerHasBiggerWidth || !isHorizontal && triggerHasBiggerHeight;
    }
  }, {
    key: "fitsContainer",
    get: function get() {
      return this.getContainerOffsets().allSidesArePositive;
    }
  }, {
    key: "visibleSurface",
    get: function get() {
      var layerBounds = this.getLayerBounds();
      var containerOffsets = this.getContainerOffsets(layerBounds);
      var substract = containerOffsets.negativeSides;
      for (var side in substract) {
        substract[side] = -substract[side];
      }
      return layerBounds.substract(substract).surface;
    }
  }, {
    key: "secondaryOffsetSide",
    get: function get() {
      var _Object$entries$map$f, _Object$entries$map$f2, _this = this;
      var containerOffsets = this.getContainerOffsets();
      var _ref2 = (_Object$entries$map$f = (_Object$entries$map$f2 = Object.entries(containerOffsets.negativeSides).map(function(_ref3) {
        var side = _ref3[0], value = _ref3[1];
        return [BoundSide[side], value];
      }).filter(function(_ref4) {
        var side = _ref4[0];
        return _this.primary.isOppositeDirection(side);
      }).sort(function(_ref5, _ref6) {
        var a = _ref5[1];
        var b = _ref6[1];
        return b - a;
      })) == null ? void 0 : _Object$entries$map$f2[0]) != null ? _Object$entries$map$f : [], mostNegativeSide = _ref2[0];
      return mostNegativeSide || null;
    }
  }]);
  return Placement2;
}();
var PlacementCenter = function(_Placement) {
  _inheritsLoose(PlacementCenter2, _Placement);
  function PlacementCenter2() {
    return _Placement.apply(this, arguments) || this;
  }
  var _proto2 = PlacementCenter2.prototype;
  _proto2.getLayerBounds = function getLayerBounds() {
    var _this$subjectsBounds2 = this.subjectsBounds, trigger = _this$subjectsBounds2.trigger, layer = _this$subjectsBounds2.layer;
    var result = Bounds.empty();
    result.top = trigger.top + trigger.height / 2 - layer.height / 2;
    result.bottom = result.top + layer.height;
    result.left = trigger.left + trigger.width / 2 - layer.width / 2;
    result.right = result.left + layer.width;
    result.width = result.right - result.left;
    result.height = result.bottom - result.top;
    return result;
  };
  return PlacementCenter2;
}(Placement);
function getNegativeOffsetBetweenLayerCenterAndTrigger(subjectsBounds, placement, arrowOffset) {
  var layer = subjectsBounds.layer, trigger = subjectsBounds.trigger, arrow = subjectsBounds.arrow;
  var sizeProperty = placement.primary.oppositeSizeProp;
  var _ref = !placement.primary.isHorizontal ? ["left", "right"] : ["top", "bottom"], sideA = _ref[0], sideB = _ref[1];
  var offsetA = layer[sideA] + layer[sizeProperty] / 2 - trigger[sideA] - arrow[sizeProperty] / 2 - arrowOffset;
  var offsetB = layer[sideB] - layer[sizeProperty] / 2 - trigger[sideB] + arrow[sizeProperty] / 2 + arrowOffset;
  return (offsetA < 0 ? -offsetA : 0) + (offsetB > 0 ? -offsetB : 0);
}
var STYLE_BASE = {
  position: "absolute",
  willChange: "top, left",
  left: null,
  right: null,
  top: null,
  bottom: null
};
function getArrowStyle(subjectsBounds, placement, arrowOffset) {
  var _extends2;
  if (placement.primary.isCenter) {
    return STYLE_BASE;
  }
  var layer = subjectsBounds.layer, trigger = subjectsBounds.trigger, arrow = subjectsBounds.arrow;
  var sizeProperty = placement.primary.oppositeSizeProp;
  var triggerIsBigger = trigger[sizeProperty] > layer[sizeProperty];
  var min = arrowOffset + arrow[sizeProperty] / 2;
  var max = layer[sizeProperty] - arrow[sizeProperty] / 2 - arrowOffset;
  var negativeOffset = getNegativeOffsetBetweenLayerCenterAndTrigger(subjectsBounds, placement, arrowOffset);
  var primarySide = placement.primary.prop;
  var secondarySide = placement.primary.oppositeCssProp;
  var secondaryValue = triggerIsBigger ? layer[sizeProperty] / 2 + negativeOffset : trigger[secondarySide] + trigger[sizeProperty] / 2 - layer[secondarySide];
  return _extends({}, STYLE_BASE, (_extends2 = {}, _extends2[primarySide] = "100%", _extends2[secondarySide] = limit(secondaryValue, min, max), _extends2));
}
var Placements = function() {
  function Placements2(placements, config, subjectsBounds) {
    this.placements = void 0;
    this.config = void 0;
    this.subjectsBounds = void 0;
    this.placements = placements;
    this.config = config;
    this.subjectsBounds = subjectsBounds;
  }
  Placements2.getSidesFromPlacementType = function getSidesFromPlacementType(type) {
    var _type$split = type.split("-"), a = _type$split[0], b = _type$split[1];
    var primary = BoundSide[a];
    var secondary;
    if (b === "center") {
      secondary = Side.center;
    } else if (primary.isHorizontal) {
      secondary = b === "start" ? Side.top : Side.bottom;
    } else {
      secondary = b === "start" ? Side.left : Side.right;
    }
    return [primary, secondary];
  };
  Placements2.create = function create(subjectsBounds, config) {
    var offsets = {
      arrow: config.arrowOffset,
      container: config.containerOffset,
      trigger: config.triggerOffset
    };
    function getListOfPlacements(preferedPlacement) {
      if (preferedPlacement === void 0) {
        preferedPlacement = config.placement;
      }
      var _Placements$getSidesF = Placements2.getSidesFromPlacementType(preferedPlacement), primary = _Placements$getSidesF[0], secondary = _Placements$getSidesF[1];
      var preferredSide = BoundSide[primary.isHorizontal ? config.preferY : config.preferX];
      var triggerIsBigger = !primary.isHorizontal && subjectsBounds.triggerHasBiggerWidth || primary.isHorizontal && subjectsBounds.triggerHasBiggerHeight;
      function placementFrom(primary2, secondary2) {
        return new Placement(primary2, secondary2, subjectsBounds, config.layerDimensions, offsets);
      }
      var list = [];
      list[0] = placementFrom(primary, secondary);
      list[1] = placementFrom(primary, secondary.isCenter ? preferredSide : Side.center);
      list[2] = placementFrom(primary, Side[(secondary.opposite.isCenter ? preferredSide.opposite : secondary.opposite).prop]);
      list[3] = placementFrom(preferredSide, triggerIsBigger ? primary : Side[primary.opposite.prop]);
      list[4] = placementFrom(preferredSide, Side.center);
      list[5] = placementFrom(preferredSide, triggerIsBigger ? Side[primary.opposite.prop] : primary);
      list[6] = placementFrom(BoundSide[preferredSide.opposite.prop], triggerIsBigger ? primary : Side[primary.opposite.prop]);
      list[7] = placementFrom(BoundSide[preferredSide.opposite.prop], Side.center);
      list[8] = placementFrom(BoundSide[preferredSide.opposite.prop], triggerIsBigger ? Side[primary.opposite.prop] : primary);
      list[9] = placementFrom(BoundSide[primary.opposite.prop], secondary);
      list[10] = placementFrom(BoundSide[primary.opposite.prop], secondary.isCenter ? preferredSide : Side.center);
      list[11] = placementFrom(BoundSide[primary.opposite.prop], Side[(secondary.opposite.isCenter ? preferredSide.opposite : secondary.opposite).prop]);
      list = list.filter(function(placement) {
        return placement.type === config.placement || config.possiblePlacements.includes(placement.type);
      });
      return list;
    }
    if (config.placement === "center") {
      return new Placements2([new PlacementCenter(Side.center, Side.center, subjectsBounds, config.layerDimensions, offsets)].concat(getListOfPlacements(config.preferY + "-" + config.preferX)), config, subjectsBounds);
    }
    return new Placements2(getListOfPlacements(), config, subjectsBounds);
  };
  var _proto = Placements2.prototype;
  _proto.filterPlacementsBySide = function filterPlacementsBySide(side) {
    return this.placements.filter(function(placement) {
      return placement.primary === side;
    });
  };
  _proto.findFirstPlacementThatFits = function findFirstPlacementThatFits() {
    return this.placements.find(function(placement) {
      return placement.fitsContainer;
    });
  };
  _proto.placementWithBiggestVisibleSurface = function placementWithBiggestVisibleSurface() {
    var _this$placements$map$ = this.placements.map(function(placement) {
      return {
        placement,
        surface: placement.visibleSurface
      };
    }).sort(function(a, b) {
      return b.surface - a.surface;
    }), placementWithBiggestSurface = _this$placements$map$[0].placement;
    return placementWithBiggestSurface;
  };
  _proto.findSuitablePlacement = function findSuitablePlacement() {
    if (!this.config.auto) {
      return this.placements[0];
    }
    return this.findFirstPlacementThatFits() || this.placementWithBiggestVisibleSurface();
  };
  _proto.getSecondaryOffset = function getSecondaryOffset(placement) {
    var _this$config = this.config, auto = _this$config.auto, snap = _this$config.snap;
    if (!auto || snap || placement instanceof PlacementCenter) {
      return 0;
    }
    var placementsOnSameSide = this.filterPlacementsBySide(placement.primary);
    var currentPlacementHasHighestPriority = placementsOnSameSide.indexOf(placement) === 0;
    if (currentPlacementHasHighestPriority && placement.fitsContainer) {
      return 0;
    }
    var firstPlacementThatDoesNotFit = placementsOnSameSide.find(function(placement2) {
      return !placement2.fitsContainer;
    });
    if (!firstPlacementThatDoesNotFit) {
      return 0;
    }
    var secondaryOffsetSide = firstPlacementThatDoesNotFit.secondaryOffsetSide;
    if (!secondaryOffsetSide) {
      return 0;
    }
    var containerOffsets = placement.getContainerOffsets();
    var secondary = placement.secondary;
    var factor;
    if (placement.triggerIsBigger || firstPlacementThatDoesNotFit === placement) {
      factor = secondaryOffsetSide.isPush ? -1 : 1;
    } else {
      factor = secondary === Side.left || [Side.top, Side.center].includes(secondary) && secondaryOffsetSide.isPush ? -1 : 1;
    }
    var secondaryOffset = containerOffsets[secondaryOffsetSide.prop];
    return secondaryOffset * factor;
  };
  _proto.getStyles = function getStyles(layerBounds, placement, scrollOffsets, borderOffsets) {
    var layerStyleBase = {
      willChange: "top, left, width, height"
    };
    var arrow = getArrowStyle(this.subjectsBounds.merge({
      layer: layerBounds
    }), placement, this.config.arrowOffset);
    var layer = this.config.overflowContainer ? _extends({}, layerStyleBase, {
      position: "fixed",
      top: layerBounds.top,
      left: layerBounds.left
    }) : _extends({}, layerStyleBase, {
      position: "absolute",
      top: layerBounds.top - this.subjectsBounds.parent.top + scrollOffsets.top - borderOffsets.top,
      left: layerBounds.left - this.subjectsBounds.parent.left + scrollOffsets.left - borderOffsets.left
    });
    return {
      arrow,
      layer
    };
  };
  _proto.getHasDisappeared = function getHasDisappeared(layerBounds) {
    var subject = this.config.overflowContainer ? this.subjectsBounds.trigger : layerBounds;
    var containerOffsets = BoundsOffsets.mergeSmallestSides(this.subjectsBounds.offsetsToScrollContainers(subject, true));
    var entries = Object.entries(containerOffsets.negativeSides);
    var hasFullyDisappeared = entries.some(function(_ref) {
      var prop = _ref[0], value = _ref[1];
      var side = BoundSide[prop];
      return value <= -subject[side.sizeProp];
    });
    if (hasFullyDisappeared) {
      return "full";
    }
    if (!containerOffsets.allSidesArePositive) {
      return "partial";
    }
    return null;
  };
  _proto.result = function result(scrollOffsets, borderOffsets) {
    var suitablePlacement = this.findSuitablePlacement();
    var secondaryOffset = this.getSecondaryOffset(suitablePlacement);
    var layerBounds = suitablePlacement.getLayerBounds(secondaryOffset);
    var styles = this.getStyles(layerBounds, suitablePlacement, scrollOffsets, borderOffsets);
    var layerSide = suitablePlacement.primary.prop;
    return {
      styles,
      layerSide,
      placement: suitablePlacement,
      layerBounds,
      hasDisappeared: this.getHasDisappeared(layerBounds)
    };
  };
  return Placements2;
}();
var SubjectsBounds = function() {
  function SubjectsBounds2(subjectsBounds, overflowContainer) {
    this.overflowContainer = void 0;
    this.trigger = void 0;
    this.layer = void 0;
    this.arrow = void 0;
    this.parent = void 0;
    this.window = void 0;
    this.scrollContainers = void 0;
    this.overflowContainer = overflowContainer;
    Object.assign(this, subjectsBounds);
  }
  SubjectsBounds2.create = function create(environment, layer, trigger, parent, arrow, scrollContainers, overflowContainer, getTriggerBounds) {
    var window2 = Bounds.fromWindow(environment);
    return new SubjectsBounds2({
      layer: Bounds.fromElement(layer, {
        environment,
        withTransform: false
      }),
      trigger: getTriggerBounds ? Bounds.create(boundsToObject(getTriggerBounds())) : Bounds.fromElement(trigger),
      arrow: arrow ? Bounds.fromElement(arrow) : Bounds.empty(),
      parent: parent ? Bounds.fromElement(parent) : window2,
      window: window2,
      scrollContainers: [window2].concat(scrollContainers.map(function(container) {
        return Bounds.fromElement(container, {
          withScrollbars: false
        });
      }))
    }, overflowContainer);
  };
  var _proto = SubjectsBounds2.prototype;
  _proto.merge = function merge(subjectsBounds) {
    return new SubjectsBounds2(_extends({}, this, subjectsBounds), this.overflowContainer);
  };
  _proto.offsetsToScrollContainers = function offsetsToScrollContainers(subject, allContainers) {
    if (allContainers === void 0) {
      allContainers = false;
    }
    var scrollContainers = this.overflowContainer && !allContainers ? [this.window] : this.scrollContainers;
    return scrollContainers.map(function(scrollContainer) {
      return scrollContainer.offsetsTo(subject);
    });
  };
  _createClass(SubjectsBounds2, [{
    key: "layerOffsetsToScrollContainers",
    get: function get() {
      return this.offsetsToScrollContainers(this.layer);
    }
  }, {
    key: "triggerHasBiggerWidth",
    get: function get() {
      return this.trigger.width > this.layer.width;
    }
  }, {
    key: "triggerHasBiggerHeight",
    get: function get() {
      return this.trigger.height > this.layer.height;
    }
  }]);
  return SubjectsBounds2;
}();
var GLOBAL_CONTAINER = null;
function setGlobalContainer(container) {
  if (typeof document === "undefined") {
    return;
  }
  true ? tiny_warning_esm_default(!(GLOBAL_CONTAINER instanceof HTMLElement), "react-laag: You've called 'setGlobalContainer() previously'. It is recommended to only set the global container once, otherwise this may lead to unexpected behaviour.") : void 0;
  if (typeof container === "function") {
    GLOBAL_CONTAINER = container();
  } else if (typeof container === "string") {
    GLOBAL_CONTAINER = document.getElementById(container);
  } else {
    GLOBAL_CONTAINER = container;
  }
  true ? tiny_warning_esm_default(GLOBAL_CONTAINER instanceof HTMLElement, "react-laag: You've called 'setGlobalContainer()', but it didn't result in a valid html-element") : void 0;
}
var DEFAULT_OPTIONS = {
  auto: false,
  arrowOffset: 0,
  containerOffset: 10,
  triggerOffset: 0,
  overflowContainer: true,
  placement: "top-center",
  possiblePlacements: PLACEMENT_TYPES,
  preferX: "right",
  preferY: "bottom",
  snap: false,
  container: void 0,
  trigger: void 0
};
function useLayer(_ref) {
  var _triggerBoundsRef$cur;
  var _ref$isOpen = _ref.isOpen, isOpen = _ref$isOpen === void 0 ? false : _ref$isOpen, _ref$overflowContaine = _ref.overflowContainer, overflowContainer = _ref$overflowContaine === void 0 ? DEFAULT_OPTIONS.overflowContainer : _ref$overflowContaine, _ref$environment = _ref.environment, environment = _ref$environment === void 0 ? typeof window !== "undefined" ? window : void 0 : _ref$environment, ResizeObserverPolyfill = _ref.ResizeObserver, _ref$placement = _ref.placement, placement = _ref$placement === void 0 ? DEFAULT_OPTIONS.placement : _ref$placement, _ref$possiblePlacemen = _ref.possiblePlacements, possiblePlacements = _ref$possiblePlacemen === void 0 ? DEFAULT_OPTIONS.possiblePlacements : _ref$possiblePlacemen, _ref$preferX = _ref.preferX, preferX = _ref$preferX === void 0 ? DEFAULT_OPTIONS.preferX : _ref$preferX, _ref$preferY = _ref.preferY, preferY = _ref$preferY === void 0 ? DEFAULT_OPTIONS.preferY : _ref$preferY, _ref$auto = _ref.auto, auto = _ref$auto === void 0 ? DEFAULT_OPTIONS.auto : _ref$auto, _ref$snap = _ref.snap, snap = _ref$snap === void 0 ? DEFAULT_OPTIONS.snap : _ref$snap, _ref$triggerOffset = _ref.triggerOffset, triggerOffset = _ref$triggerOffset === void 0 ? DEFAULT_OPTIONS.triggerOffset : _ref$triggerOffset, _ref$containerOffset = _ref.containerOffset, containerOffset = _ref$containerOffset === void 0 ? DEFAULT_OPTIONS.containerOffset : _ref$containerOffset, _ref$arrowOffset = _ref.arrowOffset, arrowOffset = _ref$arrowOffset === void 0 ? DEFAULT_OPTIONS.arrowOffset : _ref$arrowOffset, _ref$container = _ref.container, container = _ref$container === void 0 ? DEFAULT_OPTIONS.container : _ref$container, _ref$layerDimensions = _ref.layerDimensions, layerDimensions = _ref$layerDimensions === void 0 ? null : _ref$layerDimensions, onDisappear = _ref.onDisappear, onOutsideClick = _ref.onOutsideClick, onParentClose = _ref.onParentClose, triggerOption = _ref.trigger;
  var _useState = (0, import_react.useState)(function() {
    return {
      layerSide: placement === "center" ? "center" : Placements.getSidesFromPlacementType(placement)[0].prop,
      styles: {
        layer: {
          position: overflowContainer ? "fixed" : "absolute",
          top: 0,
          left: 0
        },
        arrow: {
          position: "absolute",
          top: 0,
          left: 0
        }
      }
    };
  }), state = _useState[0], setState = _useState[1];
  var triggerBoundsRef = (0, import_react.useRef)(null);
  var lastState = useLastState(state, isOpen);
  var repositioningToken = (0, import_react.useRef)({
    cancelled: false
  });
  (0, import_react.useEffect)(function() {
    return function() {
      repositioningToken.current.cancelled = true;
    };
  }, []);
  var handlePositioning = (0, import_react.useCallback)(function handlePositioning2(_ref2, scrollOffsets, borderOffsets) {
    var arrow = _ref2.arrow, layer = _ref2.layer, scrollContainers = _ref2.scrollContainers, trigger = _ref2.trigger;
    var parent = scrollContainers[0];
    var subjectsBounds = SubjectsBounds.create(environment, layer, trigger, parent, arrow, scrollContainers, overflowContainer, triggerOption == null ? void 0 : triggerOption.getBounds);
    var config = {
      placement,
      possiblePlacements,
      auto,
      layerDimensions,
      arrowOffset,
      containerOffset,
      triggerOffset,
      preferX,
      preferY,
      snap,
      overflowContainer
    };
    var _Placements$create$re = Placements.create(subjectsBounds, config).result(scrollOffsets, borderOffsets), hasDisappeared = _Placements$create$re.hasDisappeared, layerSide = _Placements$create$re.layerSide, styles = _Placements$create$re.styles;
    var newState = {
      layerSide,
      styles
    };
    if (!lastState.current || didStateChange(lastState.current, newState)) {
      lastState.current = newState;
      repositioningToken.current.cancelled = true;
      var token = {
        cancelled: false
      };
      repositioningToken.current = token;
      Promise.resolve().then(function() {
        if (!token.cancelled) {
          setState(newState);
        }
      });
    }
    if (isSet(hasDisappeared) && isSet(onDisappear)) {
      onDisappear(hasDisappeared);
    }
  }, [arrowOffset, auto, containerOffset, environment, layerDimensions, onDisappear, overflowContainer, placement, possiblePlacements, preferX, preferY, snap, triggerOffset, lastState, triggerOption]);
  var _useTrackElements = useTrackElements({
    ResizeObserverPolyfill,
    environment,
    enabled: isOpen,
    overflowContainer,
    onChange: handlePositioning,
    triggerOption
  }), triggerRef = _useTrackElements.triggerRef, layerRef = _useTrackElements.layerRef, arrowRef = _useTrackElements.arrowRef, closestScrollContainer = _useTrackElements.closestScrollContainer;
  var _useGroup = useGroup({
    isOpen,
    onOutsideClick,
    onParentClose
  }), closeOnOutsideClickRefs = _useGroup.closeOnOutsideClickRefs, registrations = _useGroup.registrations;
  var props = {
    triggerProps: Boolean(triggerOption) ? {} : {
      ref: mergeRefs(triggerRef, closeOnOutsideClickRefs.trigger, triggerBoundsRef)
    },
    layerProps: {
      ref: mergeRefs(layerRef, closeOnOutsideClickRefs.layer),
      style: state.styles.layer
    },
    arrowProps: {
      ref: arrowRef,
      style: state.styles.arrow,
      layerSide: state.layerSide
    },
    layerSide: state.layerSide,
    triggerBounds: isOpen ? triggerOption ? triggerOption.getBounds() : (_triggerBoundsRef$cur = triggerBoundsRef.current) == null ? void 0 : _triggerBoundsRef$cur.getBoundingClientRect() : null,
    renderLayer: function renderLayer(children) {
      return typeof document !== "undefined" ? (0, import_react_dom.createPortal)((0, import_react.createElement)(GroupProvider, {
        registrations,
        children
      }), overflowContainer || !closestScrollContainer ? getContainerElement(container) : closestScrollContainer) : null;
    }
  };
  return props;
}
function didStateChange(previous, next) {
  if (previous.layerSide !== next.layerSide) {
    return true;
  }
  var styleProps = ["position", "top", "left", "right", "bottom"];
  for (var _i = 0, _styleProps = styleProps; _i < _styleProps.length; _i++) {
    var prop = _styleProps[_i];
    if (previous.styles.layer[prop] !== next.styles.layer[prop] || previous.styles.arrow[prop] !== next.styles.arrow[prop]) {
      return true;
    }
  }
  return false;
}
var DEFAULT_CONTAINER_ID = "layers";
function getContainerElement(container) {
  var element;
  if (typeof container === "function") {
    element = container();
    if (!element || !(element instanceof HTMLElement)) {
      throw new Error("react-laag: You've passed a function to the 'container' prop, but it returned no valid HTMLElement");
    }
  } else if (container instanceof HTMLElement) {
    element = container;
  } else if (typeof container === "string") {
    element = document.getElementById(container);
    if (!element) {
      throw new Error("react-laag: You've passed element with id '" + container + "' to the 'container' prop, but it returned no valid HTMLElement");
    }
  } else if (GLOBAL_CONTAINER instanceof HTMLElement) {
    return GLOBAL_CONTAINER;
  } else {
    element = document.getElementById(DEFAULT_CONTAINER_ID);
    if (!element) {
      element = document.createElement("div");
      element.id = DEFAULT_CONTAINER_ID;
      element.style.cssText = "\n        position: absolute;\n        top: 0px;\n        left: 0px;\n        right: 0px;\n      ";
      document.body.appendChild(element);
    }
  }
  return element;
}
var _excluded = ["size", "angle", "borderWidth", "borderColor", "roundness", "backgroundColor", "layerSide", "style"];
var LEFT = "left";
var TOP = "top";
var BOTTOM = "bottom";
var RIGHT = "right";
function getWidthBasedOnAngle(angle, size) {
  return Math.tan(angle * (Math.PI / 180)) * size;
}
function getViewBox(sizeA, sizeB, side, borderWidth) {
  var _map;
  var map = (_map = {}, _map[BOTTOM] = "0 " + -borderWidth + " " + sizeB + " " + sizeA, _map[TOP] = "0 0 " + sizeB + " " + (sizeA + borderWidth), _map[RIGHT] = -borderWidth + " 0 " + sizeA + " " + sizeB, _map[LEFT] = "0 0 " + (sizeA + borderWidth) + " " + sizeB, _map);
  return map[side.prop];
}
function getTrianglePath(sizeA, sizeB, side, roundness, angle) {
  var _BOTTOM$TOP$RIGHT$LEF, _BOTTOM$TOP$RIGHT$LEF2, _BOTTOM$TOP$RIGHT$LEF3;
  var relativeRoundness = roundness / 10 * sizeA * 2;
  var A = (_BOTTOM$TOP$RIGHT$LEF = {}, _BOTTOM$TOP$RIGHT$LEF[BOTTOM] = [0, sizeA], _BOTTOM$TOP$RIGHT$LEF[TOP] = [0, 0], _BOTTOM$TOP$RIGHT$LEF[RIGHT] = [sizeA, sizeB], _BOTTOM$TOP$RIGHT$LEF[LEFT] = [0, sizeB], _BOTTOM$TOP$RIGHT$LEF)[side.prop].join(" ");
  var B = side.isHorizontal ? "V 0" : "H " + sizeB;
  var cPoint = sizeB / 2;
  var c1A = sizeB / 2 + getWidthBasedOnAngle(angle, sizeA / 8);
  var c1B = sizeA / 8;
  var C = (_BOTTOM$TOP$RIGHT$LEF2 = {}, _BOTTOM$TOP$RIGHT$LEF2[BOTTOM] = ["C", c1A, c1B, cPoint + relativeRoundness, 0, cPoint, 0], _BOTTOM$TOP$RIGHT$LEF2[TOP] = ["C", c1A, sizeA - c1B, cPoint + relativeRoundness, sizeA, cPoint, sizeA], _BOTTOM$TOP$RIGHT$LEF2[RIGHT] = ["C", c1B, sizeB - c1A, 0, cPoint - relativeRoundness, 0, cPoint], _BOTTOM$TOP$RIGHT$LEF2[LEFT] = ["C", sizeA - c1B, sizeB - c1A, sizeA, cPoint - relativeRoundness, sizeA, cPoint], _BOTTOM$TOP$RIGHT$LEF2)[side.prop].join(" ");
  var d1A = sizeB / 2 - getWidthBasedOnAngle(angle, sizeA / 8);
  var d1B = sizeA / 8;
  var D = (_BOTTOM$TOP$RIGHT$LEF3 = {}, _BOTTOM$TOP$RIGHT$LEF3[BOTTOM] = ["C", cPoint - relativeRoundness, 0, d1A, d1B, A], _BOTTOM$TOP$RIGHT$LEF3[TOP] = ["C", cPoint - relativeRoundness, sizeA, d1A, sizeA - d1B, A], _BOTTOM$TOP$RIGHT$LEF3[RIGHT] = ["C", 0, cPoint + relativeRoundness, d1B, sizeB - d1A, A], _BOTTOM$TOP$RIGHT$LEF3[LEFT] = ["C", sizeA, cPoint + relativeRoundness, sizeA - d1B, sizeB - d1A, A], _BOTTOM$TOP$RIGHT$LEF3)[side.prop].join(" ");
  return ["M", A, B, C, D].join(" ");
}
function getBorderMaskPath(sizeA, sizeB, borderWidth, side, angle) {
  var borderOffset = getWidthBasedOnAngle(angle, borderWidth);
  var _ref = !side.isPush ? [sizeA, sizeA - borderWidth] : [0, borderWidth], A = _ref[0], B = _ref[1];
  if (side.isHorizontal) {
    return ["M", A, borderWidth, "V", sizeB - borderWidth, "L", B, sizeB - borderWidth - borderOffset, "V", borderOffset + borderWidth, "Z"].join(" ");
  }
  return ["M", borderWidth, A, "H", sizeB - borderWidth, "L", sizeB - borderWidth - borderOffset, B, "H", borderOffset + borderWidth, "Z"].join(" ");
}
var Arrow = (0, import_react.forwardRef)(function Arrow2(_ref2, ref) {
  var _ref2$size = _ref2.size, size = _ref2$size === void 0 ? 8 : _ref2$size, _ref2$angle = _ref2.angle, angle = _ref2$angle === void 0 ? 45 : _ref2$angle, _ref2$borderWidth = _ref2.borderWidth, borderWidth = _ref2$borderWidth === void 0 ? 0 : _ref2$borderWidth, _ref2$borderColor = _ref2.borderColor, borderColor = _ref2$borderColor === void 0 ? "black" : _ref2$borderColor, _ref2$roundness = _ref2.roundness, roundness = _ref2$roundness === void 0 ? 0 : _ref2$roundness, _ref2$backgroundColor = _ref2.backgroundColor, backgroundColor = _ref2$backgroundColor === void 0 ? "white" : _ref2$backgroundColor, _ref2$layerSide = _ref2.layerSide, layerSide = _ref2$layerSide === void 0 ? "top" : _ref2$layerSide, _ref2$style = _ref2.style, style = _ref2$style === void 0 ? {} : _ref2$style, rest = _objectWithoutPropertiesLoose(_ref2, _excluded);
  if (layerSide === "center") {
    return null;
  }
  var side = BoundSide[layerSide];
  var sizeA = size;
  var sizeB = getWidthBasedOnAngle(angle, size) * 2;
  var maxSize = Math.max(sizeA, sizeB);
  return (0, import_react.createElement)("svg", _extends({
    ref
  }, rest, {
    style: _extends({}, style, {
      transform: "translate" + (side.isHorizontal ? "Y" : "X") + "(-50%)"
    }),
    width: maxSize,
    height: maxSize,
    preserveAspectRatio: side.isPush ? "xMinYMin" : "xMaxYMax",
    viewBox: getViewBox(sizeA, sizeB, side, borderWidth)
  }), (0, import_react.createElement)("path", {
    fill: backgroundColor,
    strokeWidth: borderWidth,
    stroke: borderColor,
    d: getTrianglePath(sizeA, sizeB, side, roundness, angle)
  }), (0, import_react.createElement)("path", {
    fill: backgroundColor,
    d: getBorderMaskPath(sizeA, sizeB, borderWidth, side, angle)
  }));
});
var Status;
(function(Status2) {
  Status2[Status2["ENTERING"] = 0] = "ENTERING";
  Status2[Status2["LEAVING"] = 1] = "LEAVING";
  Status2[Status2["IDLE"] = 2] = "IDLE";
})(Status || (Status = {}));
function useHover(_temp) {
  var _ref = _temp === void 0 ? {} : _temp, _ref$delayEnter = _ref.delayEnter, delayEnter = _ref$delayEnter === void 0 ? 0 : _ref$delayEnter, _ref$delayLeave = _ref.delayLeave, delayLeave = _ref$delayLeave === void 0 ? 0 : _ref$delayLeave, _ref$hideOnScroll = _ref.hideOnScroll, hideOnScroll = _ref$hideOnScroll === void 0 ? true : _ref$hideOnScroll;
  var _useState = (0, import_react.useState)(false), show = _useState[0], setShow = _useState[1];
  var timeout = (0, import_react.useRef)(null);
  var status = (0, import_react.useRef)(Status.IDLE);
  var hasTouchMoved = (0, import_react.useRef)(false);
  var removeTimeout = (0, import_react.useCallback)(function removeTimeout2() {
    clearTimeout(timeout.current);
    timeout.current = null;
    status.current = Status.IDLE;
  }, []);
  function onMouseEnter() {
    if (status.current === Status.LEAVING && timeout.current) {
      removeTimeout();
    }
    if (show) {
      return;
    }
    status.current = Status.ENTERING;
    timeout.current = window.setTimeout(function() {
      setShow(true);
      timeout.current = null;
      status.current = Status.IDLE;
    }, delayEnter);
  }
  function onMouseLeave(_, immediate) {
    if (status.current === Status.ENTERING && timeout.current) {
      removeTimeout();
    }
    if (!show) {
      return;
    }
    if (immediate) {
      setShow(false);
      timeout.current = null;
      status.current = Status.IDLE;
      return;
    }
    status.current = Status.LEAVING;
    timeout.current = window.setTimeout(function() {
      setShow(false);
      timeout.current = null;
      status.current = Status.IDLE;
    }, delayLeave);
  }
  (0, import_react.useEffect)(function() {
    function onScroll() {
      if (show && hideOnScroll) {
        removeTimeout();
        setShow(false);
      }
    }
    window.addEventListener("scroll", onScroll, true);
    return function() {
      window.removeEventListener("scroll", onScroll, true);
      if (timeout.current) {
        clearTimeout(timeout.current);
      }
    };
  }, [show, hideOnScroll, removeTimeout]);
  var hoverProps = {
    onMouseEnter,
    onMouseLeave,
    onTouchStart: function onTouchStart() {
      hasTouchMoved.current = false;
    },
    onTouchMove: function onTouchMove() {
      hasTouchMoved.current = true;
    },
    onTouchEnd: function onTouchEnd() {
      if (!hasTouchMoved.current && !show) {
        setShow(true);
      }
      hasTouchMoved.current = false;
    }
  };
  return [show, hoverProps, function() {
    return onMouseLeave(null, true);
  }];
}
function Transition(_ref) {
  var isOpenExternal = _ref.isOpen, children = _ref.children;
  var _useState = (0, import_react.useState)({
    isOpenInternal: isOpenExternal,
    isLeaving: false
  }), state = _useState[0], setState = _useState[1];
  var didMount = (0, import_react.useRef)(false);
  (0, import_react.useEffect)(function() {
    if (isOpenExternal) {
      setState({
        isOpenInternal: true,
        isLeaving: false
      });
    } else if (didMount.current) {
      setState({
        isOpenInternal: false,
        isLeaving: true
      });
    }
  }, [isOpenExternal, setState]);
  (0, import_react.useEffect)(function() {
    true ? tiny_warning_esm_default(children, "react-laag: You are using 'Transition'. Note that this component is marked as deprecated and will be removed at future releases") : void 0;
  }, [children]);
  (0, import_react.useEffect)(function() {
    didMount.current = true;
  }, []);
  if (!isOpenExternal && !state.isOpenInternal && !state.isLeaving) {
    return null;
  }
  return children(state.isOpenInternal, function() {
    if (!state.isOpenInternal) {
      setState(function(s) {
        return _extends({}, s, {
          isLeaving: false
        });
      });
    }
  }, state.isLeaving);
}
export {
  Arrow,
  DEFAULT_OPTIONS,
  PLACEMENT_TYPES,
  Transition,
  mergeRefs,
  setGlobalContainer,
  useHover,
  useLayer,
  useMousePositionAsTrigger
};
//# sourceMappingURL=react-laag.js.map
