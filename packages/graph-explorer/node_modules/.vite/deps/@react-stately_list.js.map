{
  "version": 3,
  "sources": ["../../../../../node_modules/.pnpm/@react-stately+selection@3.11.0_react@17.0.2/node_modules/@react-stately/selection/dist/packages/@react-stately/selection/src/index.ts", "../../../../../node_modules/.pnpm/@react-stately+selection@3.11.0_react@17.0.2/node_modules/@react-stately/selection/dist/packages/@react-stately/selection/src/useMultipleSelectionState.ts", "../../../../../node_modules/.pnpm/@react-stately+selection@3.11.0_react@17.0.2/node_modules/@react-stately/selection/dist/packages/@react-stately/selection/src/Selection.ts", "../../../../../node_modules/.pnpm/@react-stately+selection@3.11.0_react@17.0.2/node_modules/@react-stately/selection/dist/packages/@react-stately/selection/src/SelectionManager.ts", "../../../../../node_modules/.pnpm/@react-stately+list@3.5.4_react@17.0.2/node_modules/@react-stately/list/dist/packages/@react-stately/list/src/index.ts", "../../../../../node_modules/.pnpm/@react-stately+list@3.5.4_react@17.0.2/node_modules/@react-stately/list/dist/packages/@react-stately/list/src/useListState.ts", "../../../../../node_modules/.pnpm/@react-stately+list@3.5.4_react@17.0.2/node_modules/@react-stately/list/dist/packages/@react-stately/list/src/ListCollection.ts", "../../../../../node_modules/.pnpm/@react-stately+list@3.5.4_react@17.0.2/node_modules/@react-stately/list/dist/packages/@react-stately/list/src/useSingleSelectListState.ts"],
  "sourcesContent": ["/*\n * Copyright 2020 Adobe. All rights reserved.\n * This file is licensed to you under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License. You may obtain a copy\n * of the License at http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software distributed under\n * the License is distributed on an \"AS IS\" BASIS, WITHOUT WARRANTIES OR REPRESENTATIONS\n * OF ANY KIND, either express or implied. See the License for the specific language\n * governing permissions and limitations under the License.\n */\n\nexport type {MultipleSelectionStateProps} from './useMultipleSelectionState';\nexport type {FocusState, SingleSelectionState, MultipleSelectionState, MultipleSelectionManager} from './types';\nexport {useMultipleSelectionState} from './useMultipleSelectionState';\nexport {SelectionManager} from './SelectionManager';\n", "/*\n * Copyright 2020 Adobe. All rights reserved.\n * This file is licensed to you under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License. You may obtain a copy\n * of the License at http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software distributed under\n * the License is distributed on an \"AS IS\" BASIS, WITHOUT WARRANTIES OR REPRESENTATIONS\n * OF ANY KIND, either express or implied. See the License for the specific language\n * governing permissions and limitations under the License.\n */\n\nimport {DisabledBehavior, MultipleSelection, SelectionBehavior, SelectionMode} from '@react-types/shared';\nimport {Key, useEffect, useMemo, useRef, useState} from 'react';\nimport {MultipleSelectionState} from './types';\nimport {Selection} from './Selection';\nimport {useControlledState} from '@react-stately/utils';\n\nfunction equalSets(setA, setB) {\n  if (setA.size !== setB.size) {\n    return false;\n  }\n\n  for (let item of setA) {\n    if (!setB.has(item)) {\n      return false;\n    }\n  }\n\n  return true;\n}\n\nexport interface MultipleSelectionStateProps extends MultipleSelection {\n  /** How multiple selection should behave in the collection. */\n  selectionBehavior?: SelectionBehavior,\n  /** Whether onSelectionChange should fire even if the new set of keys is the same as the last. */\n  allowDuplicateSelectionEvents?: boolean,\n  /** Whether `disabledKeys` applies to all interactions, or only selection. */\n  disabledBehavior?: DisabledBehavior\n}\n\n/**\n * Manages state for multiple selection and focus in a collection.\n */\nexport function useMultipleSelectionState(props: MultipleSelectionStateProps): MultipleSelectionState {\n  let {\n    selectionMode = 'none' as SelectionMode,\n    disallowEmptySelection,\n    allowDuplicateSelectionEvents,\n    selectionBehavior: selectionBehaviorProp = 'toggle',\n    disabledBehavior = 'all'\n  } = props;\n\n  // We want synchronous updates to `isFocused` and `focusedKey` after their setters are called.\n  // But we also need to trigger a react re-render. So, we have both a ref (sync) and state (async).\n  let isFocusedRef = useRef(false);\n  let [, setFocused] = useState(false);\n  let focusedKeyRef = useRef(null);\n  let childFocusStrategyRef = useRef(null);\n  let [, setFocusedKey] = useState(null);\n  let selectedKeysProp = useMemo(() => convertSelection(props.selectedKeys), [props.selectedKeys]);\n  let defaultSelectedKeys = useMemo(() => convertSelection(props.defaultSelectedKeys, new Selection()), [props.defaultSelectedKeys]);\n  let [selectedKeys, setSelectedKeys] = useControlledState(\n    selectedKeysProp,\n    defaultSelectedKeys,\n    props.onSelectionChange\n  );\n  let disabledKeysProp = useMemo(() =>\n    props.disabledKeys ? new Set(props.disabledKeys) : new Set<Key>()\n  , [props.disabledKeys]);\n  let [selectionBehavior, setSelectionBehavior] = useState(selectionBehaviorProp);\n\n  // If the selectionBehavior prop is set to replace, but the current state is toggle (e.g. due to long press\n  // to enter selection mode on touch), and the selection becomes empty, reset the selection behavior.\n  if (selectionBehaviorProp === 'replace' && selectionBehavior === 'toggle' && typeof selectedKeys === 'object' && selectedKeys.size === 0) {\n    setSelectionBehavior('replace');\n  }\n\n  // If the selectionBehavior prop changes, update the state as well.\n  let lastSelectionBehavior = useRef(selectionBehaviorProp);\n  useEffect(() => {\n    if (selectionBehaviorProp !== lastSelectionBehavior.current) {\n      setSelectionBehavior(selectionBehaviorProp);\n      lastSelectionBehavior.current = selectionBehaviorProp;\n    }\n  }, [selectionBehaviorProp]);\n\n  return {\n    selectionMode,\n    disallowEmptySelection,\n    selectionBehavior,\n    setSelectionBehavior,\n    get isFocused() {\n      return isFocusedRef.current;\n    },\n    setFocused(f) {\n      isFocusedRef.current = f;\n      setFocused(f);\n    },\n    get focusedKey() {\n      return focusedKeyRef.current;\n    },\n    get childFocusStrategy() {\n      return childFocusStrategyRef.current;\n    },\n    setFocusedKey(k, childFocusStrategy = 'first') {\n      focusedKeyRef.current = k;\n      childFocusStrategyRef.current = childFocusStrategy;\n      setFocusedKey(k);\n    },\n    selectedKeys,\n    setSelectedKeys(keys) {\n      if (allowDuplicateSelectionEvents || !equalSets(keys, selectedKeys)) {\n        setSelectedKeys(keys);\n      }\n    },\n    disabledKeys: disabledKeysProp,\n    disabledBehavior\n  };\n}\n\nfunction convertSelection(selection: 'all' | Iterable<Key>, defaultValue?: Selection): 'all' | Selection {\n  if (!selection) {\n    return defaultValue;\n  }\n\n  return selection === 'all'\n    ? 'all'\n    : new Selection(selection);\n}\n", "/*\n * Copyright 2020 Adobe. All rights reserved.\n * This file is licensed to you under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License. You may obtain a copy\n * of the License at http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software distributed under\n * the License is distributed on an \"AS IS\" BASIS, WITHOUT WARRANTIES OR REPRESENTATIONS\n * OF ANY KIND, either express or implied. See the License for the specific language\n * governing permissions and limitations under the License.\n */\n\nimport {Key} from 'react';\n\n/**\n * A Selection is a special Set containing Keys, which also has an anchor\n * and current selected key for use when range selecting.\n */\nexport class Selection extends Set<Key> {\n  anchorKey: Key;\n  currentKey: Key;\n\n  constructor(keys?: Iterable<Key> | Selection, anchorKey?: Key, currentKey?: Key) {\n    super(keys);\n    if (keys instanceof Selection) {\n      this.anchorKey = anchorKey || keys.anchorKey;\n      this.currentKey = currentKey || keys.currentKey;\n    } else {\n      this.anchorKey = anchorKey;\n      this.currentKey = currentKey;\n    }\n  }\n}\n", "/*\n * Copyright 2020 Adobe. All rights reserved.\n * This file is licensed to you under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License. You may obtain a copy\n * of the License at http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software distributed under\n * the License is distributed on an \"AS IS\" BASIS, WITHOUT WARRANTIES OR REPRESENTATIONS\n * OF ANY KIND, either express or implied. See the License for the specific language\n * governing permissions and limitations under the License.\n */\n\nimport {\n  Collection,\n  DisabledBehavior,\n  FocusStrategy,\n  Selection as ISelection,\n  LongPressEvent,\n  Node,\n  PressEvent,\n  SelectionBehavior,\n  SelectionMode\n} from '@react-types/shared';\nimport {Key} from 'react';\nimport {MultipleSelectionManager, MultipleSelectionState} from './types';\nimport {Selection} from './Selection';\n\ninterface SelectionManagerOptions {\n  allowsCellSelection?: boolean\n}\n\n/**\n * An interface for reading and updating multiple selection state.\n */\nexport class SelectionManager implements MultipleSelectionManager {\n  private collection: Collection<Node<unknown>>;\n  private state: MultipleSelectionState;\n  private allowsCellSelection: boolean;\n  private _isSelectAll: boolean;\n\n  constructor(collection: Collection<Node<unknown>>, state: MultipleSelectionState, options?: SelectionManagerOptions) {\n    this.collection = collection;\n    this.state = state;\n    this.allowsCellSelection = options?.allowsCellSelection ?? false;\n    this._isSelectAll = null;\n  }\n\n  /**\n   * The type of selection that is allowed in the collection.\n   */\n  get selectionMode(): SelectionMode {\n    return this.state.selectionMode;\n  }\n\n  /**\n   * Whether the collection allows empty selection.\n   */\n  get disallowEmptySelection(): boolean {\n    return this.state.disallowEmptySelection;\n  }\n\n  /**\n   * The selection behavior for the collection.\n   */\n  get selectionBehavior(): SelectionBehavior {\n    return this.state.selectionBehavior;\n  }\n\n  /**\n   * Sets the selection behavior for the collection.\n   */\n  setSelectionBehavior(selectionBehavior: SelectionBehavior) {\n    this.state.setSelectionBehavior(selectionBehavior);\n  }\n\n  /**\n   * Whether the collection is currently focused.\n   */\n  get isFocused(): boolean {\n    return this.state.isFocused;\n  }\n\n  /**\n   * Sets whether the collection is focused.\n   */\n  setFocused(isFocused: boolean) {\n    this.state.setFocused(isFocused);\n  }\n\n  /**\n   * The current focused key in the collection.\n   */\n  get focusedKey(): Key {\n    return this.state.focusedKey;\n  }\n\n  /** Whether the first or last child of the focused key should receive focus. */\n  get childFocusStrategy(): FocusStrategy {\n    return this.state.childFocusStrategy;\n  }\n\n  /**\n   * Sets the focused key.\n   */\n  setFocusedKey(key: Key, childFocusStrategy?: FocusStrategy) {\n    if (key == null || this.collection.getItem(key)) {\n      this.state.setFocusedKey(key, childFocusStrategy);\n    }\n  }\n\n  /**\n   * The currently selected keys in the collection.\n   */\n  get selectedKeys(): Set<Key> {\n    return this.state.selectedKeys === 'all'\n      ? new Set(this.getSelectAllKeys())\n      : this.state.selectedKeys;\n  }\n\n  /**\n   * The raw selection value for the collection.\n   * Either 'all' for select all, or a set of keys.\n   */\n  get rawSelection(): ISelection {\n    return this.state.selectedKeys;\n  }\n\n  /**\n   * Returns whether a key is selected.\n   */\n  isSelected(key: Key) {\n    if (this.state.selectionMode === 'none') {\n      return false;\n    }\n\n    key = this.getKey(key);\n    return this.state.selectedKeys === 'all'\n      ? this.canSelectItem(key)\n      : this.state.selectedKeys.has(key);\n  }\n\n  /**\n   * Whether the selection is empty.\n   */\n  get isEmpty(): boolean {\n    return this.state.selectedKeys !== 'all' && this.state.selectedKeys.size === 0;\n  }\n\n  /**\n   * Whether all items in the collection are selected.\n   */\n  get isSelectAll(): boolean {\n    if (this.isEmpty) {\n      return false;\n    }\n\n    if (this.state.selectedKeys === 'all') {\n      return true;\n    }\n\n    if (this._isSelectAll != null) {\n      return this._isSelectAll;\n    }\n\n    let allKeys = this.getSelectAllKeys();\n    let selectedKeys = this.state.selectedKeys;\n    this._isSelectAll = allKeys.every(k => selectedKeys.has(k));\n    return this._isSelectAll;\n  }\n\n  get firstSelectedKey(): Key | null {\n    let first: Node<unknown> | null = null;\n    for (let key of this.state.selectedKeys) {\n      let item = this.collection.getItem(key);\n      if (!first || item?.index < first.index) {\n        first = item;\n      }\n    }\n\n    return first?.key;\n  }\n\n  get lastSelectedKey(): Key | null {\n    let last: Node<unknown> | null = null;\n    for (let key of this.state.selectedKeys) {\n      let item = this.collection.getItem(key);\n      if (!last || item?.index > last.index) {\n        last = item;\n      }\n    }\n\n    return last?.key;\n  }\n\n  get disabledKeys(): Set<Key> {\n    return this.state.disabledKeys;\n  }\n\n  get disabledBehavior(): DisabledBehavior {\n    return this.state.disabledBehavior;\n  }\n\n  /**\n   * Extends the selection to the given key.\n   */\n  extendSelection(toKey: Key) {\n    if (this.selectionMode === 'none') {\n      return;\n    }\n\n    if (this.selectionMode === 'single') {\n      this.replaceSelection(toKey);\n      return;\n    }\n\n    toKey = this.getKey(toKey);\n\n    let selection: Selection;\n\n    // Only select the one key if coming from a select all.\n    if (this.state.selectedKeys === 'all') {\n      selection = new Selection([toKey], toKey, toKey);\n    } else {\n      let selectedKeys = this.state.selectedKeys as Selection;\n      let anchorKey = selectedKeys.anchorKey || toKey;\n      selection = new Selection(selectedKeys, anchorKey, toKey);\n      for (let key of this.getKeyRange(anchorKey, selectedKeys.currentKey || toKey)) {\n        selection.delete(key);\n      }\n\n      for (let key of this.getKeyRange(toKey, anchorKey)) {\n        if (this.canSelectItem(key)) {\n          selection.add(key);\n        }\n      }\n    }\n\n    this.state.setSelectedKeys(selection);\n  }\n\n  private getKeyRange(from: Key, to: Key) {\n    let fromItem = this.collection.getItem(from);\n    let toItem = this.collection.getItem(to);\n    if (fromItem && toItem) {\n      if (fromItem.index <= toItem.index) {\n        return this.getKeyRangeInternal(from, to);\n      }\n\n      return this.getKeyRangeInternal(to, from);\n    }\n\n    return [];\n  }\n\n  private getKeyRangeInternal(from: Key, to: Key) {\n    let keys: Key[] = [];\n    let key = from;\n    while (key) {\n      let item = this.collection.getItem(key);\n      if (item && item.type === 'item' || (item.type === 'cell' && this.allowsCellSelection)) {\n        keys.push(key);\n      }\n\n      if (key === to) {\n        return keys;\n      }\n\n      key = this.collection.getKeyAfter(key);\n    }\n\n    return [];\n  }\n\n  private getKey(key: Key) {\n    let item = this.collection.getItem(key);\n    if (!item) {\n      // \u00AF\\_(\u30C4)_/\u00AF\n      return key;\n    }\n\n    // If cell selection is allowed, just return the key.\n    if (item.type === 'cell' && this.allowsCellSelection) {\n      return key;\n    }\n\n    // Find a parent item to select\n    while (item.type !== 'item' && item.parentKey != null) {\n      item = this.collection.getItem(item.parentKey);\n    }\n\n    if (!item || item.type !== 'item') {\n      return null;\n    }\n\n    return item.key;\n  }\n\n  /**\n   * Toggles whether the given key is selected.\n   */\n  toggleSelection(key: Key) {\n    if (this.selectionMode === 'none') {\n      return;\n    }\n\n    if (this.selectionMode === 'single' && !this.isSelected(key)) {\n      this.replaceSelection(key);\n      return;\n    }\n\n    key = this.getKey(key);\n    if (key == null) {\n      return;\n    }\n\n    let keys = new Selection(this.state.selectedKeys === 'all' ? this.getSelectAllKeys() : this.state.selectedKeys);\n    if (keys.has(key)) {\n      keys.delete(key);\n      // TODO: move anchor to last selected key...\n      // Does `current` need to move here too?\n    } else if (this.canSelectItem(key)) {\n      keys.add(key);\n      keys.anchorKey = key;\n      keys.currentKey = key;\n    }\n\n    if (this.disallowEmptySelection && keys.size === 0) {\n      return;\n    }\n\n    this.state.setSelectedKeys(keys);\n  }\n\n  /**\n   * Replaces the selection with only the given key.\n   */\n  replaceSelection(key: Key) {\n    if (this.selectionMode === 'none') {\n      return;\n    }\n\n    key = this.getKey(key);\n    if (key == null) {\n      return;\n    }\n\n    let selection = this.canSelectItem(key)\n      ? new Selection([key], key, key)\n      : new Selection();\n\n    this.state.setSelectedKeys(selection);\n  }\n\n  /**\n   * Replaces the selection with the given keys.\n   */\n  setSelectedKeys(keys: Iterable<Key>) {\n    if (this.selectionMode === 'none') {\n      return;\n    }\n\n    let selection = new Selection();\n    for (let key of keys) {\n      key = this.getKey(key);\n      if (key != null) {\n        selection.add(key);\n        if (this.selectionMode === 'single') {\n          break;\n        }\n      }\n    }\n\n    this.state.setSelectedKeys(selection);\n  }\n\n  private getSelectAllKeys() {\n    let keys: Key[] = [];\n    let addKeys = (key: Key) => {\n      while (key) {\n        if (this.canSelectItem(key)) {\n          let item = this.collection.getItem(key);\n          if (item.type === 'item') {\n            keys.push(key);\n          }\n\n          // Add child keys. If cell selection is allowed, then include item children too.\n          if (item.hasChildNodes && (this.allowsCellSelection || item.type !== 'item')) {\n            addKeys([...item.childNodes][0].key);\n          }\n        }\n\n        key = this.collection.getKeyAfter(key);\n      }\n    };\n\n    addKeys(this.collection.getFirstKey());\n    return keys;\n  }\n\n  /**\n   * Selects all items in the collection.\n   */\n  selectAll() {\n    if (this.selectionMode === 'multiple') {\n      this.state.setSelectedKeys('all');\n    }\n  }\n\n  /**\n   * Removes all keys from the selection.\n   */\n  clearSelection() {\n    if (!this.disallowEmptySelection && (this.state.selectedKeys === 'all' || this.state.selectedKeys.size > 0)) {\n      this.state.setSelectedKeys(new Selection());\n    }\n  }\n\n  /**\n   * Toggles between select all and an empty selection.\n   */\n  toggleSelectAll() {\n    if (this.isSelectAll) {\n      this.clearSelection();\n    } else {\n      this.selectAll();\n    }\n  }\n\n  select(key: Key, e?: PressEvent | LongPressEvent | PointerEvent) {\n    if (this.selectionMode === 'none') {\n      return;\n    }\n\n    if (this.selectionMode === 'single') {\n      if (this.isSelected(key) && !this.disallowEmptySelection) {\n        this.toggleSelection(key);\n      } else {\n        this.replaceSelection(key);\n      }\n    } else if (this.selectionBehavior === 'toggle' || (e && (e.pointerType === 'touch' || e.pointerType === 'virtual'))) {\n      // if touch or virtual (VO) then we just want to toggle, otherwise it's impossible to multi select because they don't have modifier keys\n      this.toggleSelection(key);\n    } else {\n      this.replaceSelection(key);\n    }\n  }\n\n  /**\n   * Returns whether the current selection is equal to the given selection.\n   */\n  isSelectionEqual(selection: Set<Key>) {\n    if (selection === this.state.selectedKeys) {\n      return true;\n    }\n\n    // Check if the set of keys match.\n    let selectedKeys = this.selectedKeys;\n    if (selection.size !== selectedKeys.size) {\n      return false;\n    }\n\n    for (let key of selection) {\n      if (!selectedKeys.has(key)) {\n        return false;\n      }\n    }\n\n    for (let key of selectedKeys) {\n      if (!selection.has(key)) {\n        return false;\n      }\n    }\n\n    return true;\n  }\n\n  canSelectItem(key: Key) {\n    if (this.state.selectionMode === 'none' || this.state.disabledKeys.has(key)) {\n      return false;\n    }\n\n    let item = this.collection.getItem(key);\n    if (!item || (item.type === 'cell' && !this.allowsCellSelection)) {\n      return false;\n    }\n\n    return true;\n  }\n\n  isDisabled(key: Key) {\n    return this.state.disabledKeys.has(key) && this.state.disabledBehavior === 'all';\n  }\n}\n", "/*\n * Copyright 2020 Adobe. All rights reserved.\n * This file is licensed to you under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License. You may obtain a copy\n * of the License at http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software distributed under\n * the License is distributed on an \"AS IS\" BASIS, WITHOUT WARRANTIES OR REPRESENTATIONS\n * OF ANY KIND, either express or implied. See the License for the specific language\n * governing permissions and limitations under the License.\n */\n\nexport type {ListProps, ListState} from './useListState';\nexport type {SingleSelectListProps, SingleSelectListState} from './useSingleSelectListState';\nexport {useListState} from './useListState';\nexport {useSingleSelectListState} from './useSingleSelectListState';\nexport {ListCollection} from './ListCollection';\n", "/*\n * Copyright 2020 Adobe. All rights reserved.\n * This file is licensed to you under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License. You may obtain a copy\n * of the License at http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software distributed under\n * the License is distributed on an \"AS IS\" BASIS, WITHOUT WARRANTIES OR REPRESENTATIONS\n * OF ANY KIND, either express or implied. See the License for the specific language\n * governing permissions and limitations under the License.\n */\n\nimport {Collection, CollectionBase, Node} from '@react-types/shared';\nimport {Key, useEffect, useMemo} from 'react';\nimport {ListCollection} from './ListCollection';\nimport {MultipleSelectionStateProps, SelectionManager, useMultipleSelectionState} from '@react-stately/selection';\nimport {useCollection} from '@react-stately/collections';\n\nexport interface ListProps<T> extends CollectionBase<T>, MultipleSelectionStateProps {\n  /** Filter function to generate a filtered list of nodes. */\n  filter?: (nodes: Iterable<Node<T>>) => Iterable<Node<T>>,\n  /** @private */\n  suppressTextValueWarning?: boolean\n}\n\nexport interface ListState<T> {\n  /** A collection of items in the list. */\n  collection: Collection<Node<T>>,\n\n  /** A set of items that are disabled. */\n  disabledKeys: Set<Key>,\n\n  /** A selection manager to read and update multiple selection state. */\n  selectionManager: SelectionManager\n}\n\n/**\n * Provides state management for list-like components. Handles building a collection\n * of items from props, and manages multiple selection state.\n */\nexport function useListState<T extends object>(props: ListProps<T>): ListState<T>  {\n  let {filter} = props;\n\n  let selectionState = useMultipleSelectionState(props);\n  let disabledKeys = useMemo(() =>\n    props.disabledKeys ? new Set(props.disabledKeys) : new Set<Key>()\n  , [props.disabledKeys]);\n\n  let factory = nodes => filter ? new ListCollection(filter(nodes)) : new ListCollection(nodes as Iterable<Node<T>>);\n  let context = useMemo(() => ({suppressTextValueWarning: props.suppressTextValueWarning}), [props.suppressTextValueWarning]);\n\n  let collection = useCollection(props, factory, context, [filter]);\n\n  // Reset focused key if that item is deleted from the collection.\n  useEffect(() => {\n    if (selectionState.focusedKey != null && !collection.getItem(selectionState.focusedKey)) {\n      selectionState.setFocusedKey(null);\n    }\n  }, [collection, selectionState.focusedKey]);\n\n  return {\n    collection,\n    disabledKeys,\n    selectionManager: new SelectionManager(collection, selectionState)\n  };\n}\n", "/*\n * Copyright 2020 Adobe. All rights reserved.\n * This file is licensed to you under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License. You may obtain a copy\n * of the License at http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software distributed under\n * the License is distributed on an \"AS IS\" BASIS, WITHOUT WARRANTIES OR REPRESENTATIONS\n * OF ANY KIND, either express or implied. See the License for the specific language\n * governing permissions and limitations under the License.\n */\n\nimport {Collection, Node} from '@react-types/shared';\nimport {Key} from 'react';\n\nexport class ListCollection<T> implements Collection<Node<T>> {\n  private keyMap: Map<Key, Node<T>> = new Map();\n  private iterable: Iterable<Node<T>>;\n  private firstKey: Key;\n  private lastKey: Key;\n\n  constructor(nodes: Iterable<Node<T>>) {\n    this.iterable = nodes;\n\n    let visit = (node: Node<T>) => {\n      this.keyMap.set(node.key, node);\n\n      if (node.childNodes && node.type === 'section') {\n        for (let child of node.childNodes) {\n          visit(child);\n        }\n      }\n    };\n\n    for (let node of nodes) {\n      visit(node);\n    }\n\n    let last: Node<T>;\n    let index = 0;\n    for (let [key, node] of this.keyMap) {\n      if (last) {\n        last.nextKey = key;\n        node.prevKey = last.key;\n      } else {\n        this.firstKey = key;\n        node.prevKey = undefined;\n      }\n\n      if (node.type === 'item') {\n        node.index = index++;\n      }\n\n      last = node;\n\n      // Set nextKey as undefined since this might be the last node\n      // If it isn't the last node, last.nextKey will properly set at start of new loop\n      last.nextKey = undefined;\n    }\n\n    this.lastKey = last?.key;\n  }\n\n  *[Symbol.iterator]() {\n    yield* this.iterable;\n  }\n\n  get size() {\n    return this.keyMap.size;\n  }\n\n  getKeys() {\n    return this.keyMap.keys();\n  }\n\n  getKeyBefore(key: Key) {\n    let node = this.keyMap.get(key);\n    return node ? node.prevKey : null;\n  }\n\n  getKeyAfter(key: Key) {\n    let node = this.keyMap.get(key);\n    return node ? node.nextKey : null;\n  }\n\n  getFirstKey() {\n    return this.firstKey;\n  }\n\n  getLastKey() {\n    return this.lastKey;\n  }\n\n  getItem(key: Key) {\n    return this.keyMap.get(key);\n  }\n\n  at(idx: number) {\n    const keys = [...this.getKeys()];\n    return this.getItem(keys[idx]);\n  }\n}\n", "/*\n * Copyright 2020 Adobe. All rights reserved.\n * This file is licensed to you under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License. You may obtain a copy\n * of the License at http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software distributed under\n * the License is distributed on an \"AS IS\" BASIS, WITHOUT WARRANTIES OR REPRESENTATIONS\n * OF ANY KIND, either express or implied. See the License for the specific language\n * governing permissions and limitations under the License.\n */\n\nimport {CollectionBase, SingleSelection} from '@react-types/shared';\nimport {Key, useMemo} from 'react';\nimport {ListState, useListState} from './useListState';\nimport {Node} from '@react-types/shared';\nimport {useControlledState} from '@react-stately/utils';\n\nexport interface SingleSelectListProps<T> extends CollectionBase<T>, Omit<SingleSelection, 'disallowEmptySelection'> {\n  /** Filter function to generate a filtered list of nodes. */\n  filter?: (nodes: Iterable<Node<T>>) => Iterable<Node<T>>,\n  /** @private */\n  suppressTextValueWarning?: boolean\n}\n\nexport interface SingleSelectListState<T> extends ListState<T> {\n  /** The key for the currently selected item. */\n  readonly selectedKey: Key,\n\n  /** Sets the selected key. */\n  setSelectedKey(key: Key): void,\n\n  /** The value of the currently selected item. */\n  readonly selectedItem: Node<T>\n}\n\n/**\n * Provides state management for list-like components with single selection.\n * Handles building a collection of items from props, and manages selection state.\n */\nexport function useSingleSelectListState<T extends object>(props: SingleSelectListProps<T>): SingleSelectListState<T>  {\n  let [selectedKey, setSelectedKey] = useControlledState(props.selectedKey, props.defaultSelectedKey ?? null, props.onSelectionChange);\n  let selectedKeys = useMemo(() => selectedKey != null ? [selectedKey] : [], [selectedKey]);\n  let {collection, disabledKeys, selectionManager} = useListState({\n    ...props,\n    selectionMode: 'single',\n    disallowEmptySelection: true,\n    allowDuplicateSelectionEvents: true,\n    selectedKeys,\n    onSelectionChange: (keys: Set<Key>) => {\n      let key = keys.values().next().value;\n\n      // Always fire onSelectionChange, even if the key is the same\n      // as the current key (useControlledState does not).\n      if (key === selectedKey && props.onSelectionChange) {\n        props.onSelectionChange(key);\n      }\n\n      setSelectedKey(key);\n    }\n  });\n\n  let selectedItem = selectedKey != null\n    ? collection.getItem(selectedKey)\n    : null;\n\n  return {\n    collection,\n    disabledKeys,\n    selectionManager,\n    selectedKey,\n    setSelectedKey,\n    selectedItem\n  };\n}\n"],
  "mappings": "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",
  "names": ["$Qsto2$useRef", "$Qsto2$useState", "$Qsto2$useMemo", "$Qsto2$useEffect", "$58Phs$useMemo", "$58Phs$useEffect"]
}
