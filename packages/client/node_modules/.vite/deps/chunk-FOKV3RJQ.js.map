{
  "version": 3,
  "sources": ["../../../../../node_modules/.pnpm/@react-aria+selection@3.11.0_react@17.0.2/node_modules/@react-aria/selection/dist/packages/@react-aria/selection/src/index.ts", "../../../../../node_modules/.pnpm/@react-aria+selection@3.11.0_react@17.0.2/node_modules/@react-aria/selection/dist/packages/@react-aria/selection/src/useSelectableCollection.ts", "../../../../../node_modules/.pnpm/@react-aria+selection@3.11.0_react@17.0.2/node_modules/@react-aria/selection/dist/packages/@react-aria/selection/src/utils.ts", "../../../../../node_modules/.pnpm/@react-aria+selection@3.11.0_react@17.0.2/node_modules/@react-aria/selection/dist/packages/@react-aria/selection/src/useTypeSelect.ts", "../../../../../node_modules/.pnpm/@react-aria+selection@3.11.0_react@17.0.2/node_modules/@react-aria/selection/dist/packages/@react-aria/selection/src/useSelectableItem.ts", "../../../../../node_modules/.pnpm/@react-aria+selection@3.11.0_react@17.0.2/node_modules/@react-aria/selection/dist/packages/@react-aria/selection/src/useSelectableList.ts", "../../../../../node_modules/.pnpm/@react-aria+selection@3.11.0_react@17.0.2/node_modules/@react-aria/selection/dist/packages/@react-aria/selection/src/ListKeyboardDelegate.ts", "../../../../../node_modules/.pnpm/@react-aria+listbox@3.5.1_react@17.0.2/node_modules/@react-aria/listbox/dist/packages/@react-aria/listbox/src/index.ts", "../../../../../node_modules/.pnpm/@react-aria+listbox@3.5.1_react@17.0.2/node_modules/@react-aria/listbox/dist/packages/@react-aria/listbox/src/useListBox.ts", "../../../../../node_modules/.pnpm/@react-aria+listbox@3.5.1_react@17.0.2/node_modules/@react-aria/listbox/dist/packages/@react-aria/listbox/src/utils.ts", "../../../../../node_modules/.pnpm/@react-aria+listbox@3.5.1_react@17.0.2/node_modules/@react-aria/listbox/dist/packages/@react-aria/listbox/src/useOption.ts", "../../../../../node_modules/.pnpm/@react-aria+listbox@3.5.1_react@17.0.2/node_modules/@react-aria/listbox/dist/packages/@react-aria/listbox/src/useListBoxSection.ts"],
  "sourcesContent": ["/*\n * Copyright 2020 Adobe. All rights reserved.\n * This file is licensed to you under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License. You may obtain a copy\n * of the License at http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software distributed under\n * the License is distributed on an \"AS IS\" BASIS, WITHOUT WARRANTIES OR REPRESENTATIONS\n * OF ANY KIND, either express or implied. See the License for the specific language\n * governing permissions and limitations under the License.\n */\n\nexport {useSelectableCollection} from './useSelectableCollection';\nexport {useSelectableItem} from './useSelectableItem';\nexport {useSelectableList} from './useSelectableList';\nexport {ListKeyboardDelegate} from './ListKeyboardDelegate';\nexport {useTypeSelect} from './useTypeSelect';\n\nexport type {AriaSelectableCollectionOptions, SelectableCollectionAria} from './useSelectableCollection';\nexport type {AriaSelectableListOptions, SelectableListAria} from './useSelectableList';\nexport type {SelectableItemOptions, SelectableItemStates, SelectableItemAria} from './useSelectableItem';\nexport type {AriaTypeSelectOptions, TypeSelectAria} from './useTypeSelect';\n", "/*\n * Copyright 2020 Adobe. All rights reserved.\n * This file is licensed to you under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License. You may obtain a copy\n * of the License at http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software distributed under\n * the License is distributed on an \"AS IS\" BASIS, WITHOUT WARRANTIES OR REPRESENTATIONS\n * OF ANY KIND, either express or implied. See the License for the specific language\n * governing permissions and limitations under the License.\n */\n\nimport {DOMAttributes, FocusableElement, FocusStrategy, KeyboardDelegate} from '@react-types/shared';\nimport {FocusEvent, Key, KeyboardEvent, RefObject, useEffect, useRef} from 'react';\nimport {focusSafely, getFocusableTreeWalker} from '@react-aria/focus';\nimport {focusWithoutScrolling, mergeProps, scrollIntoView, useEvent} from '@react-aria/utils';\nimport {isCtrlKeyPressed, isNonContiguousSelectionModifier} from './utils';\nimport {MultipleSelectionManager} from '@react-stately/selection';\nimport {useLocale} from '@react-aria/i18n';\nimport {useTypeSelect} from './useTypeSelect';\n\nexport interface AriaSelectableCollectionOptions {\n  /**\n   * An interface for reading and updating multiple selection state.\n   */\n  selectionManager: MultipleSelectionManager,\n  /**\n   * A delegate object that implements behavior for keyboard focus movement.\n   */\n  keyboardDelegate: KeyboardDelegate,\n  /**\n   * The ref attached to the element representing the collection.\n   */\n  ref: RefObject<HTMLElement>,\n  /**\n   * Whether the collection or one of its items should be automatically focused upon render.\n   * @default false\n   */\n  autoFocus?: boolean | FocusStrategy,\n  /**\n   * Whether focus should wrap around when the end/start is reached.\n   * @default false\n   */\n  shouldFocusWrap?: boolean,\n  /**\n   * Whether the collection allows empty selection.\n   * @default false\n   */\n  disallowEmptySelection?: boolean,\n  /**\n   * Whether the collection allows the user to select all items via keyboard shortcut.\n   * @default false\n   */\n  disallowSelectAll?: boolean,\n  /**\n   * Whether selection should occur automatically on focus.\n   * @default false\n   */\n  selectOnFocus?: boolean,\n  /**\n   * Whether typeahead is disabled.\n   * @default false\n   */\n  disallowTypeAhead?: boolean,\n  /**\n   * Whether the collection items should use virtual focus instead of being focused directly.\n   */\n  shouldUseVirtualFocus?: boolean,\n  /**\n   * Whether navigation through tab key is enabled.\n   */\n  allowsTabNavigation?: boolean,\n  /**\n   * Whether the collection items are contained in a virtual scroller.\n   */\n  isVirtualized?: boolean,\n  /**\n   * The ref attached to the scrollable body. Used to provide automatic scrolling on item focus for non-virtualized collections.\n   * If not provided, defaults to the collection ref.\n   */\n  scrollRef?: RefObject<HTMLElement>\n}\n\nexport interface SelectableCollectionAria {\n  /** Props for the collection element. */\n  collectionProps: DOMAttributes\n}\n\n/**\n * Handles interactions with selectable collections.\n */\nexport function useSelectableCollection(options: AriaSelectableCollectionOptions): SelectableCollectionAria {\n  let {\n    selectionManager: manager,\n    keyboardDelegate: delegate,\n    ref,\n    autoFocus = false,\n    shouldFocusWrap = false,\n    disallowEmptySelection = false,\n    disallowSelectAll = false,\n    selectOnFocus = manager.selectionBehavior === 'replace',\n    disallowTypeAhead = false,\n    shouldUseVirtualFocus,\n    allowsTabNavigation = false,\n    isVirtualized,\n    // If no scrollRef is provided, assume the collection ref is the scrollable region\n    scrollRef = ref\n  } = options;\n  let {direction} = useLocale();\n\n\n  let onKeyDown = (e: KeyboardEvent) => {\n    // Prevent option + tab from doing anything since it doesn't move focus to the cells, only buttons/checkboxes\n    if (e.altKey && e.key === 'Tab') {\n      e.preventDefault();\n    }\n\n    // Keyboard events bubble through portals. Don't handle keyboard events\n    // for elements outside the collection (e.g. menus).\n    if (!ref.current.contains(e.target as Element)) {\n      return;\n    }\n\n    const navigateToKey = (key: Key | undefined, childFocus?: FocusStrategy) => {\n      if (key != null) {\n        manager.setFocusedKey(key, childFocus);\n\n        if (e.shiftKey && manager.selectionMode === 'multiple') {\n          manager.extendSelection(key);\n        } else if (selectOnFocus && !isNonContiguousSelectionModifier(e)) {\n          manager.replaceSelection(key);\n        }\n      }\n    };\n\n    switch (e.key) {\n      case 'ArrowDown': {\n        if (delegate.getKeyBelow) {\n          e.preventDefault();\n          let nextKey = manager.focusedKey != null\n              ? delegate.getKeyBelow(manager.focusedKey)\n              : delegate.getFirstKey?.();\n          if (nextKey == null && shouldFocusWrap) {\n            nextKey = delegate.getFirstKey?.(manager.focusedKey);\n          }\n          navigateToKey(nextKey);\n        }\n        break;\n      }\n      case 'ArrowUp': {\n        if (delegate.getKeyAbove) {\n          e.preventDefault();\n          let nextKey = manager.focusedKey != null\n              ? delegate.getKeyAbove(manager.focusedKey)\n              : delegate.getLastKey?.();\n          if (nextKey == null && shouldFocusWrap) {\n            nextKey = delegate.getLastKey?.(manager.focusedKey);\n          }\n          navigateToKey(nextKey);\n        }\n        break;\n      }\n      case 'ArrowLeft': {\n        if (delegate.getKeyLeftOf) {\n          e.preventDefault();\n          let nextKey = delegate.getKeyLeftOf(manager.focusedKey);\n          navigateToKey(nextKey, direction === 'rtl' ? 'first' : 'last');\n        }\n        break;\n      }\n      case 'ArrowRight': {\n        if (delegate.getKeyRightOf) {\n          e.preventDefault();\n          let nextKey = delegate.getKeyRightOf(manager.focusedKey);\n          navigateToKey(nextKey, direction === 'rtl' ? 'last' : 'first');\n        }\n        break;\n      }\n      case 'Home':\n        if (delegate.getFirstKey) {\n          e.preventDefault();\n          let firstKey = delegate.getFirstKey(manager.focusedKey, isCtrlKeyPressed(e));\n          manager.setFocusedKey(firstKey);\n          if (isCtrlKeyPressed(e) && e.shiftKey && manager.selectionMode === 'multiple') {\n            manager.extendSelection(firstKey);\n          } else if (selectOnFocus) {\n            manager.replaceSelection(firstKey);\n          }\n        }\n        break;\n      case 'End':\n        if (delegate.getLastKey) {\n          e.preventDefault();\n          let lastKey = delegate.getLastKey(manager.focusedKey, isCtrlKeyPressed(e));\n          manager.setFocusedKey(lastKey);\n          if (isCtrlKeyPressed(e) && e.shiftKey && manager.selectionMode === 'multiple') {\n            manager.extendSelection(lastKey);\n          } else if (selectOnFocus) {\n            manager.replaceSelection(lastKey);\n          }\n        }\n        break;\n      case 'PageDown':\n        if (delegate.getKeyPageBelow) {\n          e.preventDefault();\n          let nextKey = delegate.getKeyPageBelow(manager.focusedKey);\n          navigateToKey(nextKey);\n        }\n        break;\n      case 'PageUp':\n        if (delegate.getKeyPageAbove) {\n          e.preventDefault();\n          let nextKey = delegate.getKeyPageAbove(manager.focusedKey);\n          navigateToKey(nextKey);\n        }\n        break;\n      case 'a':\n        if (isCtrlKeyPressed(e) && manager.selectionMode === 'multiple' && disallowSelectAll !== true) {\n          e.preventDefault();\n          manager.selectAll();\n        }\n        break;\n      case 'Escape':\n        e.preventDefault();\n        if (!disallowEmptySelection) {\n          manager.clearSelection();\n        }\n        break;\n      case 'Tab': {\n        if (!allowsTabNavigation) {\n          // There may be elements that are \"tabbable\" inside a collection (e.g. in a grid cell).\n          // However, collections should be treated as a single tab stop, with arrow key navigation internally.\n          // We don't control the rendering of these, so we can't override the tabIndex to prevent tabbing.\n          // Instead, we handle the Tab key, and move focus manually to the first/last tabbable element\n          // in the collection, so that the browser default behavior will apply starting from that element\n          // rather than the currently focused one.\n          if (e.shiftKey) {\n            ref.current.focus();\n          } else {\n            let walker = getFocusableTreeWalker(ref.current, {tabbable: true});\n            let next: FocusableElement;\n            let last: FocusableElement;\n            do {\n              last = walker.lastChild() as FocusableElement;\n              if (last) {\n                next = last;\n              }\n            } while (last);\n\n            if (next && !next.contains(document.activeElement)) {\n              focusWithoutScrolling(next);\n            }\n          }\n          break;\n        }\n      }\n    }\n  };\n\n  // Store the scroll position so we can restore it later.\n  let scrollPos = useRef({top: 0, left: 0});\n  useEvent(scrollRef, 'scroll', isVirtualized ? null : () => {\n    scrollPos.current = {\n      top: scrollRef.current.scrollTop,\n      left: scrollRef.current.scrollLeft\n    };\n  });\n\n  let onFocus = (e: FocusEvent) => {\n    if (manager.isFocused) {\n      // If a focus event bubbled through a portal, reset focus state.\n      if (!e.currentTarget.contains(e.target)) {\n        manager.setFocused(false);\n      }\n\n      return;\n    }\n\n    // Focus events can bubble through portals. Ignore these events.\n    if (!e.currentTarget.contains(e.target)) {\n      return;\n    }\n\n    manager.setFocused(true);\n\n    if (manager.focusedKey == null) {\n      let navigateToFirstKey = (key: Key | undefined) => {\n        if (key != null) {\n          manager.setFocusedKey(key);\n          if (selectOnFocus) {\n            manager.replaceSelection(key);\n          }\n        }\n      };\n      // If the user hasn't yet interacted with the collection, there will be no focusedKey set.\n      // Attempt to detect whether the user is tabbing forward or backward into the collection\n      // and either focus the first or last item accordingly.\n      let relatedTarget = e.relatedTarget as Element;\n      if (relatedTarget && (e.currentTarget.compareDocumentPosition(relatedTarget) & Node.DOCUMENT_POSITION_FOLLOWING)) {\n        navigateToFirstKey(manager.lastSelectedKey ?? delegate.getLastKey());\n      } else {\n        navigateToFirstKey(manager.firstSelectedKey ?? delegate.getFirstKey());\n      }\n    } else if (!isVirtualized) {\n      // Restore the scroll position to what it was before.\n      scrollRef.current.scrollTop = scrollPos.current.top;\n      scrollRef.current.scrollLeft = scrollPos.current.left;\n\n      // Refocus and scroll the focused item into view if it exists within the scrollable region.\n      let element = scrollRef.current.querySelector(`[data-key=\"${manager.focusedKey}\"]`) as HTMLElement;\n      if (element) {\n        // This prevents a flash of focus on the first/last element in the collection\n        focusWithoutScrolling(element);\n        scrollIntoView(scrollRef.current, element);\n      }\n    }\n  };\n\n  let onBlur = (e) => {\n    // Don't set blurred and then focused again if moving focus within the collection.\n    if (!e.currentTarget.contains(e.relatedTarget as HTMLElement)) {\n      manager.setFocused(false);\n    }\n  };\n\n  const autoFocusRef = useRef(autoFocus);\n  useEffect(() => {\n    if (autoFocusRef.current) {\n      let focusedKey = null;\n\n      // Check focus strategy to determine which item to focus\n      if (autoFocus === 'first') {\n        focusedKey = delegate.getFirstKey();\n      } if (autoFocus === 'last') {\n        focusedKey = delegate.getLastKey();\n      }\n\n      // If there are any selected keys, make the first one the new focus target\n      let selectedKeys = manager.selectedKeys;\n      if (selectedKeys.size) {\n        focusedKey = selectedKeys.values().next().value;\n      }\n\n      manager.setFocused(true);\n      manager.setFocusedKey(focusedKey);\n\n      // If no default focus key is selected, focus the collection itself.\n      if (focusedKey == null && !shouldUseVirtualFocus) {\n        focusSafely(ref.current);\n      }\n    }\n    autoFocusRef.current = false;\n  // eslint-disable-next-line react-hooks/exhaustive-deps\n  }, []);\n\n  // If not virtualized, scroll the focused element into view when the focusedKey changes.\n  // When virtualized, Virtualizer handles this internally.\n  useEffect(() => {\n    if (!isVirtualized && manager.focusedKey && scrollRef?.current) {\n      let element = scrollRef.current.querySelector(`[data-key=\"${manager.focusedKey}\"]`) as HTMLElement;\n      if (element) {\n        scrollIntoView(scrollRef.current, element);\n      }\n    }\n  }, [isVirtualized, scrollRef, manager.focusedKey]);\n\n  let handlers = {\n    onKeyDown,\n    onFocus,\n    onBlur,\n    onMouseDown(e) {\n      // Ignore events that bubbled through portals.\n      if (e.currentTarget.contains(e.target)) {\n        // Prevent focus going to the collection when clicking on the scrollbar.\n        e.preventDefault();\n      }\n    }\n  };\n\n  let {typeSelectProps} = useTypeSelect({\n    keyboardDelegate: delegate,\n    selectionManager: manager\n  });\n\n  if (!disallowTypeAhead) {\n    handlers = mergeProps(typeSelectProps, handlers);\n  }\n\n  // If nothing is focused within the collection, make the collection itself tabbable.\n  // This will be marshalled to either the first or last item depending on where focus came from.\n  // If using virtual focus, don't set a tabIndex at all so that VoiceOver on iOS 14 doesn't try\n  // to move real DOM focus to the element anyway.\n  let tabIndex: number;\n  if (!shouldUseVirtualFocus) {\n    tabIndex = manager.focusedKey == null ? 0 : -1;\n  }\n\n  return {\n    collectionProps: {\n      ...handlers,\n      tabIndex\n    }\n  };\n}\n", "/*\n * Copyright 2020 Adobe. All rights reserved.\n * This file is licensed to you under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License. You may obtain a copy\n * of the License at http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software distributed under\n * the License is distributed on an \"AS IS\" BASIS, WITHOUT WARRANTIES OR REPRESENTATIONS\n * OF ANY KIND, either express or implied. See the License for the specific language\n * governing permissions and limitations under the License.\n */\n\nimport {isAppleDevice} from '@react-aria/utils';\nimport {isMac} from '@react-aria/utils';\n\ninterface Event {\n  altKey: boolean,\n  ctrlKey: boolean,\n  metaKey: boolean\n}\n\nexport function isNonContiguousSelectionModifier(e: Event) {\n  // Ctrl + Arrow Up/Arrow Down has a system wide meaning on macOS, so use Alt instead.\n  // On Windows and Ubuntu, Alt + Space has a system wide meaning.\n  return isAppleDevice() ? e.altKey : e.ctrlKey;\n}\n\nexport function isCtrlKeyPressed(e: Event) {\n  if (isMac()) {\n    return e.metaKey;\n  }\n\n  return e.ctrlKey;\n}\n", "/*\n * Copyright 2020 Adobe. All rights reserved.\n * This file is licensed to you under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License. You may obtain a copy\n * of the License at http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software distributed under\n * the License is distributed on an \"AS IS\" BASIS, WITHOUT WARRANTIES OR REPRESENTATIONS\n * OF ANY KIND, either express or implied. See the License for the specific language\n * governing permissions and limitations under the License.\n */\n\nimport {DOMAttributes, KeyboardDelegate} from '@react-types/shared';\nimport {Key, KeyboardEvent, useRef} from 'react';\nimport {MultipleSelectionManager} from '@react-stately/selection';\n\n/**\n * Controls how long to wait before clearing the typeahead buffer.\n */\nconst TYPEAHEAD_DEBOUNCE_WAIT_MS = 1000; // 1 second\n\nexport interface AriaTypeSelectOptions {\n  /**\n   * A delegate that returns collection item keys with respect to visual layout.\n   */\n  keyboardDelegate: KeyboardDelegate,\n  /**\n   * An interface for reading and updating multiple selection state.\n   */\n  selectionManager: MultipleSelectionManager,\n  /**\n   * Called when an item is focused by typing.\n   */\n  onTypeSelect?: (key: Key) => void\n}\n\nexport interface TypeSelectAria {\n  /**\n   * Props to be spread on the owner of the options.\n   */\n  typeSelectProps: DOMAttributes\n}\n\n/**\n * Handles typeahead interactions with collections.\n */\nexport function useTypeSelect(options: AriaTypeSelectOptions): TypeSelectAria {\n  let {keyboardDelegate, selectionManager, onTypeSelect} = options;\n  let state = useRef({\n    search: '',\n    timeout: null\n  }).current;\n\n  let onKeyDown = (e: KeyboardEvent) => {\n    let character = getStringForKey(e.key);\n    if (!character || e.ctrlKey || e.metaKey) {\n      return;\n    }\n\n    // Do not propagate the Spacebar event if it's meant to be part of the search.\n    // When we time out, the search term becomes empty, hence the check on length.\n    // Trimming is to account for the case of pressing the Spacebar more than once,\n    // which should cycle through the selection/deselection of the focused item.\n    if (character === ' ' && state.search.trim().length > 0) {\n      e.preventDefault();\n      if (!('continuePropagation' in e)) {\n        e.stopPropagation();\n      }\n    }\n\n    state.search += character;\n\n    // Use the delegate to find a key to focus.\n    // Prioritize items after the currently focused item, falling back to searching the whole list.\n    let key = keyboardDelegate.getKeyForSearch(state.search, selectionManager.focusedKey);\n\n    // If no key found, search from the top.\n    if (key == null) {\n      key = keyboardDelegate.getKeyForSearch(state.search);\n    }\n\n    if (key != null) {\n      selectionManager.setFocusedKey(key);\n      if (onTypeSelect) {\n        onTypeSelect(key);\n      }\n    }\n\n    clearTimeout(state.timeout);\n    state.timeout = setTimeout(() => {\n      state.search = '';\n    }, TYPEAHEAD_DEBOUNCE_WAIT_MS);\n  };\n\n  return {\n    typeSelectProps: {\n      // Using a capturing listener to catch the keydown event before\n      // other hooks in order to handle the Spacebar event.\n      onKeyDownCapture: keyboardDelegate.getKeyForSearch ? onKeyDown : null\n    }\n  };\n}\n\nfunction getStringForKey(key: string) {\n  // If the key is of length 1, it is an ASCII value.\n  // Otherwise, if there are no ASCII characters in the key name,\n  // it is a Unicode character.\n  // See https://www.w3.org/TR/uievents-key/\n  if (key.length === 1 || !/^[A-Z]/i.test(key)) {\n    return key;\n  }\n\n  return '';\n}\n", "/*\n * Copyright 2020 Adobe. All rights reserved.\n * This file is licensed to you under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License. You may obtain a copy\n * of the License at http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software distributed under\n * the License is distributed on an \"AS IS\" BASIS, WITHOUT WARRANTIES OR REPRESENTATIONS\n * OF ANY KIND, either express or implied. See the License for the specific language\n * governing permissions and limitations under the License.\n */\n\nimport {DOMAttributes, FocusableElement, LongPressEvent, PressEvent} from '@react-types/shared';\nimport {focusSafely} from '@react-aria/focus';\nimport {isCtrlKeyPressed, isNonContiguousSelectionModifier} from './utils';\nimport {Key, RefObject, useEffect, useRef} from 'react';\nimport {mergeProps} from '@react-aria/utils';\nimport {MultipleSelectionManager} from '@react-stately/selection';\nimport {PressProps, useLongPress, usePress} from '@react-aria/interactions';\n\nexport interface SelectableItemOptions {\n  /**\n   * An interface for reading and updating multiple selection state.\n   */\n  selectionManager: MultipleSelectionManager,\n  /**\n   * A unique key for the item.\n   */\n  key: Key,\n  /**\n   * Ref to the item.\n   */\n  ref: RefObject<FocusableElement>,\n  /**\n   * By default, selection occurs on pointer down. This can be strange if selecting an\n   * item causes the UI to disappear immediately (e.g. menus).\n   */\n  shouldSelectOnPressUp?: boolean,\n  /**\n   * Whether selection requires the pointer/mouse down and up events to occur on the same target or triggers selection on\n   * the target of the pointer/mouse up event.\n   */\n  allowsDifferentPressOrigin?: boolean,\n  /**\n   * Whether the option is contained in a virtual scroller.\n   */\n  isVirtualized?: boolean,\n  /**\n   * Function to focus the item.\n   */\n  focus?: () => void,\n  /**\n   * Whether the option should use virtual focus instead of being focused directly.\n   */\n  shouldUseVirtualFocus?: boolean,\n  /** Whether the item is disabled. */\n  isDisabled?: boolean,\n  /**\n   * Handler that is called when a user performs an action on the item. The exact user event depends on\n   * the collection's `selectionBehavior` prop and the interaction modality.\n   */\n  onAction?: () => void\n}\n\nexport interface SelectableItemStates {\n  /** Whether the item is currently in a pressed state. */\n  isPressed: boolean,\n  /** Whether the item is currently selected. */\n  isSelected: boolean,\n  /**\n   * Whether the item is non-interactive, i.e. both selection and actions are disabled and the item may\n   * not be focused. Dependent on `disabledKeys` and `disabledBehavior`.\n   */\n  isDisabled: boolean,\n  /**\n   * Whether the item may be selected, dependent on `selectionMode`, `disabledKeys`, and `disabledBehavior`.\n   */\n  allowsSelection: boolean,\n  /**\n   * Whether the item has an action, dependent on `onAction`, `disabledKeys`,\n   * and `disabledBehavior`. It may also change depending on the current selection state\n   * of the list (e.g. when selection is primary). This can be used to enable or disable hover\n   * styles or other visual indications of interactivity.\n   */\n  hasAction: boolean\n}\n\nexport interface SelectableItemAria extends SelectableItemStates {\n  /**\n   * Props to be spread on the item root node.\n   */\n  itemProps: DOMAttributes\n}\n\n/**\n * Handles interactions with an item in a selectable collection.\n */\nexport function useSelectableItem(options: SelectableItemOptions): SelectableItemAria {\n  let {\n    selectionManager: manager,\n    key,\n    ref,\n    shouldSelectOnPressUp,\n    isVirtualized,\n    shouldUseVirtualFocus,\n    focus,\n    isDisabled,\n    onAction,\n    allowsDifferentPressOrigin\n  } = options;\n\n  let onSelect = (e: PressEvent | LongPressEvent | PointerEvent) => {\n    if (e.pointerType === 'keyboard' && isNonContiguousSelectionModifier(e)) {\n      manager.toggleSelection(key);\n    } else {\n      if (manager.selectionMode === 'none') {\n        return;\n      }\n\n      if (manager.selectionMode === 'single') {\n        if (manager.isSelected(key) && !manager.disallowEmptySelection) {\n          manager.toggleSelection(key);\n        } else {\n          manager.replaceSelection(key);\n        }\n      } else if (e && e.shiftKey) {\n        manager.extendSelection(key);\n      } else if (manager.selectionBehavior === 'toggle' || (e && (isCtrlKeyPressed(e) || e.pointerType === 'touch' || e.pointerType === 'virtual'))) {\n        // if touch or virtual (VO) then we just want to toggle, otherwise it's impossible to multi select because they don't have modifier keys\n        manager.toggleSelection(key);\n      } else {\n        manager.replaceSelection(key);\n      }\n    }\n  };\n\n  // Focus the associated DOM node when this item becomes the focusedKey\n  useEffect(() => {\n    let isFocused = key === manager.focusedKey;\n    if (isFocused && manager.isFocused && !shouldUseVirtualFocus && document.activeElement !== ref.current) {\n      if (focus) {\n        focus();\n      } else {\n        focusSafely(ref.current);\n      }\n    }\n  }, [ref, key, manager.focusedKey, manager.childFocusStrategy, manager.isFocused, shouldUseVirtualFocus]);\n\n  // Set tabIndex to 0 if the element is focused, or -1 otherwise so that only the last focused\n  // item is tabbable.  If using virtual focus, don't set a tabIndex at all so that VoiceOver\n  // on iOS 14 doesn't try to move real DOM focus to the item anyway.\n  let itemProps: SelectableItemAria['itemProps'] = {};\n  if (!shouldUseVirtualFocus) {\n    itemProps = {\n      tabIndex: key === manager.focusedKey ? 0 : -1,\n      onFocus(e) {\n        if (e.target === ref.current) {\n          manager.setFocusedKey(key);\n        }\n      }\n    };\n  }\n\n\n  // With checkbox selection, onAction (i.e. navigation) becomes primary, and occurs on a single click of the row.\n  // Clicking the checkbox enters selection mode, after which clicking anywhere on any row toggles selection for that row.\n  // With highlight selection, onAction is secondary, and occurs on double click. Single click selects the row.\n  // With touch, onAction occurs on single tap, and long press enters selection mode.\n  isDisabled = isDisabled || manager.isDisabled(key);\n  let allowsSelection = !isDisabled && manager.canSelectItem(key);\n  let allowsActions = onAction && !isDisabled;\n  let hasPrimaryAction = allowsActions && (\n    manager.selectionBehavior === 'replace'\n      ? !allowsSelection\n      : manager.isEmpty\n  );\n  let hasSecondaryAction = allowsActions && allowsSelection && manager.selectionBehavior === 'replace';\n  let hasAction = hasPrimaryAction || hasSecondaryAction;\n  let modality = useRef(null);\n\n  let longPressEnabled = hasAction && allowsSelection;\n  let longPressEnabledOnPressStart = useRef(false);\n  let hadPrimaryActionOnPressStart = useRef(false);\n\n  // By default, selection occurs on pointer down. This can be strange if selecting an\n  // item causes the UI to disappear immediately (e.g. menus).\n  // If shouldSelectOnPressUp is true, we use onPressUp instead of onPressStart.\n  // onPress requires a pointer down event on the same element as pointer up. For menus,\n  // we want to be able to have the pointer down on the trigger that opens the menu and\n  // the pointer up on the menu item rather than requiring a separate press.\n  // For keyboard events, selection still occurs on key down.\n  let itemPressProps: PressProps = {};\n  if (shouldSelectOnPressUp) {\n    itemPressProps.onPressStart = (e) => {\n      modality.current = e.pointerType;\n      longPressEnabledOnPressStart.current = longPressEnabled;\n      if (e.pointerType === 'keyboard' && (!hasAction || isSelectionKey())) {\n        onSelect(e);\n      }\n    };\n\n    // If allowsDifferentPressOrigin, make selection happen on pressUp (e.g. open menu on press down, selection on menu item happens on press up.)\n    // Otherwise, have selection happen onPress (prevents listview row selection when clicking on interactable elements in the row)\n    if (!allowsDifferentPressOrigin) {\n      itemPressProps.onPress = (e) => {\n        if (hasPrimaryAction || (hasSecondaryAction && e.pointerType !== 'mouse')) {\n          if (e.pointerType === 'keyboard' && !isActionKey()) {\n            return;\n          }\n\n          onAction();\n        } else if (e.pointerType !== 'keyboard') {\n          onSelect(e);\n        }\n      };\n    } else {\n      itemPressProps.onPressUp = (e) => {\n        if (e.pointerType !== 'keyboard') {\n          onSelect(e);\n        }\n      };\n\n      itemPressProps.onPress = hasPrimaryAction ? () => onAction() : null;\n    }\n  } else {\n    itemPressProps.onPressStart = (e) => {\n      modality.current = e.pointerType;\n      longPressEnabledOnPressStart.current = longPressEnabled;\n      hadPrimaryActionOnPressStart.current = hasPrimaryAction;\n\n      // Select on mouse down unless there is a primary action which will occur on mouse up.\n      // For keyboard, select on key down. If there is an action, the Space key selects on key down,\n      // and the Enter key performs onAction on key up.\n      if (\n        (e.pointerType === 'mouse' && !hasPrimaryAction) ||\n        (e.pointerType === 'keyboard' && (!onAction || isSelectionKey()))\n      ) {\n        onSelect(e);\n      }\n    };\n\n    itemPressProps.onPress = (e) => {\n      // Selection occurs on touch up. Primary actions always occur on pointer up.\n      // Both primary and secondary actions occur on Enter key up. The only exception\n      // is secondary actions, which occur on double click with a mouse.\n      if (\n        e.pointerType === 'touch' ||\n        e.pointerType === 'pen' ||\n        e.pointerType === 'virtual' ||\n        (e.pointerType === 'keyboard' && hasAction && isActionKey()) ||\n        (e.pointerType === 'mouse' && hadPrimaryActionOnPressStart.current)\n      ) {\n        if (hasAction) {\n          onAction();\n        } else {\n          onSelect(e);\n        }\n      }\n    };\n  }\n\n  if (!isVirtualized) {\n    itemProps['data-key'] = key;\n  }\n\n  itemPressProps.preventFocusOnPress = shouldUseVirtualFocus;\n  let {pressProps, isPressed} = usePress(itemPressProps);\n\n  // Double clicking with a mouse with selectionBehavior = 'replace' performs an action.\n  let onDoubleClick = hasSecondaryAction ? (e) => {\n    if (modality.current === 'mouse') {\n      e.stopPropagation();\n      e.preventDefault();\n      onAction();\n    }\n  } : undefined;\n\n  // Long pressing an item with touch when selectionBehavior = 'replace' switches the selection behavior\n  // to 'toggle'. This changes the single tap behavior from performing an action (i.e. navigating) to\n  // selecting, and may toggle the appearance of a UI affordance like checkboxes on each item.\n  let {longPressProps} = useLongPress({\n    isDisabled: !longPressEnabled,\n    onLongPress(e) {\n      if (e.pointerType === 'touch') {\n        onSelect(e);\n        manager.setSelectionBehavior('toggle');\n      }\n    }\n  });\n\n  // Prevent native drag and drop on long press if we also select on long press.\n  // Once the user is in selection mode, they can long press again to drag.\n  // Use a capturing listener to ensure this runs before useDrag, regardless of\n  // the order the props get merged.\n  let onDragStartCapture = e => {\n    if (modality.current === 'touch' && longPressEnabledOnPressStart.current) {\n      e.preventDefault();\n    }\n  };\n\n  return {\n    itemProps: mergeProps(\n      itemProps,\n      allowsSelection || hasPrimaryAction ? pressProps : {},\n      longPressEnabled ? longPressProps : {},\n      {onDoubleClick, onDragStartCapture}\n    ),\n    isPressed,\n    isSelected: manager.isSelected(key),\n    isDisabled,\n    allowsSelection,\n    hasAction\n  };\n}\n\nfunction isActionKey() {\n  let event = window.event as KeyboardEvent;\n  return event?.key === 'Enter';\n}\n\nfunction isSelectionKey() {\n  let event = window.event as KeyboardEvent;\n  return event?.key === ' ' || event?.code === 'Space';\n}\n", "/*\n * Copyright 2020 Adobe. All rights reserved.\n * This file is licensed to you under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License. You may obtain a copy\n * of the License at http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software distributed under\n * the License is distributed on an \"AS IS\" BASIS, WITHOUT WARRANTIES OR REPRESENTATIONS\n * OF ANY KIND, either express or implied. See the License for the specific language\n * governing permissions and limitations under the License.\n */\n\nimport {Collection, DOMAttributes, FocusStrategy, KeyboardDelegate, Node} from '@react-types/shared';\nimport {Key, RefObject, useMemo} from 'react';\nimport {ListKeyboardDelegate} from './ListKeyboardDelegate';\nimport {MultipleSelectionManager} from '@react-stately/selection';\nimport {useCollator} from '@react-aria/i18n';\nimport {useSelectableCollection} from './useSelectableCollection';\n\nexport interface AriaSelectableListOptions {\n  /**\n   * An interface for reading and updating multiple selection state.\n   */\n  selectionManager: MultipleSelectionManager,\n  /**\n   * State of the collection.\n   */\n  collection: Collection<Node<unknown>>,\n  /**\n   * The item keys that are disabled. These items cannot be selected, focused, or otherwise interacted with.\n   */\n  disabledKeys: Set<Key>,\n  /**\n   * A ref to the item.\n   */\n  ref?: RefObject<HTMLElement>,\n  /**\n   * A delegate that returns collection item keys with respect to visual layout.\n   */\n  keyboardDelegate?: KeyboardDelegate,\n  /**\n   * Whether the collection or one of its items should be automatically focused upon render.\n   * @default false\n   */\n  autoFocus?: boolean | FocusStrategy,\n  /**\n   * Whether focus should wrap around when the end/start is reached.\n   * @default false\n   */\n  shouldFocusWrap?: boolean,\n  /**\n   * Whether the option is contained in a virtual scroller.\n   */\n  isVirtualized?: boolean,\n  /**\n   * Whether the collection allows empty selection.\n   * @default false\n   */\n  disallowEmptySelection?: boolean,\n  /**\n   * Whether selection should occur automatically on focus.\n   * @default false\n   */\n  selectOnFocus?: boolean,\n  /**\n   * Whether typeahead is disabled.\n   * @default false\n   */\n  disallowTypeAhead?: boolean,\n  /**\n   * Whether the collection items should use virtual focus instead of being focused directly.\n   */\n  shouldUseVirtualFocus?: boolean,\n  /**\n   * Whether navigation through tab key is enabled.\n   */\n  allowsTabNavigation?: boolean\n}\n\nexport interface SelectableListAria {\n  /**\n   * Props for the option element.\n   */\n  listProps: DOMAttributes\n}\n\n/**\n * Handles interactions with a selectable list.\n */\nexport function useSelectableList(props: AriaSelectableListOptions): SelectableListAria {\n  let {\n    selectionManager,\n    collection,\n    disabledKeys,\n    ref,\n    keyboardDelegate,\n    autoFocus,\n    shouldFocusWrap,\n    isVirtualized,\n    disallowEmptySelection,\n    selectOnFocus = selectionManager.selectionBehavior === 'replace',\n    disallowTypeAhead,\n    shouldUseVirtualFocus,\n    allowsTabNavigation\n  } = props;\n\n  // By default, a KeyboardDelegate is provided which uses the DOM to query layout information (e.g. for page up/page down).\n  // When virtualized, the layout object will be passed in as a prop and override this.\n  let collator = useCollator({usage: 'search', sensitivity: 'base'});\n  let disabledBehavior = selectionManager.disabledBehavior;\n  let delegate = useMemo(() => (\n    keyboardDelegate || new ListKeyboardDelegate(collection, disabledBehavior === 'selection' ? new Set() : disabledKeys, ref, collator)\n  ), [keyboardDelegate, collection, disabledKeys, ref, collator, disabledBehavior]);\n\n  let {collectionProps} = useSelectableCollection({\n    ref,\n    selectionManager,\n    keyboardDelegate: delegate,\n    autoFocus,\n    shouldFocusWrap,\n    disallowEmptySelection,\n    selectOnFocus,\n    disallowTypeAhead,\n    shouldUseVirtualFocus,\n    allowsTabNavigation,\n    isVirtualized,\n    scrollRef: ref\n  });\n\n  return {\n    listProps: collectionProps\n  };\n}\n", "/*\n * Copyright 2020 Adobe. All rights reserved.\n * This file is licensed to you under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License. You may obtain a copy\n * of the License at http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software distributed under\n * the License is distributed on an \"AS IS\" BASIS, WITHOUT WARRANTIES OR REPRESENTATIONS\n * OF ANY KIND, either express or implied. See the License for the specific language\n * governing permissions and limitations under the License.\n */\n\nimport {Collection, KeyboardDelegate, Node} from '@react-types/shared';\nimport {Key, RefObject} from 'react';\n\nexport class ListKeyboardDelegate<T> implements KeyboardDelegate {\n  private collection: Collection<Node<T>>;\n  private disabledKeys: Set<Key>;\n  private ref: RefObject<HTMLElement>;\n  private collator: Intl.Collator;\n\n  constructor(collection: Collection<Node<T>>, disabledKeys: Set<Key>, ref: RefObject<HTMLElement>, collator?: Intl.Collator) {\n    this.collection = collection;\n    this.disabledKeys = disabledKeys;\n    this.ref = ref;\n    this.collator = collator;\n  }\n\n  getKeyBelow(key: Key) {\n    key = this.collection.getKeyAfter(key);\n    while (key != null) {\n      let item = this.collection.getItem(key);\n      if (item.type === 'item' && !this.disabledKeys.has(key)) {\n        return key;\n      }\n\n      key = this.collection.getKeyAfter(key);\n    }\n  }\n\n  getKeyAbove(key: Key) {\n    key = this.collection.getKeyBefore(key);\n    while (key != null) {\n      let item = this.collection.getItem(key);\n      if (item.type === 'item' && !this.disabledKeys.has(key)) {\n        return key;\n      }\n\n      key = this.collection.getKeyBefore(key);\n    }\n  }\n\n  getFirstKey() {\n    let key = this.collection.getFirstKey();\n    while (key != null) {\n      let item = this.collection.getItem(key);\n      if (item.type === 'item' && !this.disabledKeys.has(key)) {\n        return key;\n      }\n\n      key = this.collection.getKeyAfter(key);\n    }\n  }\n\n  getLastKey() {\n    let key = this.collection.getLastKey();\n    while (key != null) {\n      let item = this.collection.getItem(key);\n      if (item.type === 'item' && !this.disabledKeys.has(key)) {\n        return key;\n      }\n\n      key = this.collection.getKeyBefore(key);\n    }\n  }\n\n  private getItem(key: Key): HTMLElement {\n    return this.ref.current.querySelector(`[data-key=\"${key}\"]`);\n  }\n\n  getKeyPageAbove(key: Key) {\n    let menu = this.ref.current;\n    let item = this.getItem(key);\n    if (!item) {\n      return null;\n    }\n\n    let pageY = Math.max(0, item.offsetTop + item.offsetHeight - menu.offsetHeight);\n\n    while (item && item.offsetTop > pageY) {\n      key = this.getKeyAbove(key);\n      item = this.getItem(key);\n    }\n\n    return key;\n  }\n\n  getKeyPageBelow(key: Key) {\n    let menu = this.ref.current;\n    let item = this.getItem(key);\n    if (!item) {\n      return null;\n    }\n\n    let pageY = Math.min(menu.scrollHeight, item.offsetTop - item.offsetHeight + menu.offsetHeight);\n\n    while (item && item.offsetTop < pageY) {\n      key = this.getKeyBelow(key);\n      item = this.getItem(key);\n    }\n\n    return key;\n  }\n\n  getKeyForSearch(search: string, fromKey?: Key) {\n    if (!this.collator) {\n      return null;\n    }\n\n    let collection = this.collection;\n    let key = fromKey || this.getFirstKey();\n    while (key != null) {\n      let item = collection.getItem(key);\n      let substring = item.textValue.slice(0, search.length);\n      if (item.textValue && this.collator.compare(substring, search) === 0) {\n        return key;\n      }\n\n      key = this.getKeyBelow(key);\n    }\n\n    return null;\n  }\n}\n", "/*\n * Copyright 2020 Adobe. All rights reserved.\n * This file is licensed to you under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License. You may obtain a copy\n * of the License at http://www.apache.org/licenses/LICENSE-2.0\n * \n * Unless required by applicable law or agreed to in writing, software distributed under\n * the License is distributed on an \"AS IS\" BASIS, WITHOUT WARRANTIES OR REPRESENTATIONS\n * OF ANY KIND, either express or implied. See the License for the specific language\n * governing permissions and limitations under the License.\n */\n\nexport * from './useListBox';\nexport * from './useOption';\nexport * from './useListBoxSection';\nexport * from './utils';\n", "/*\n * Copyright 2020 Adobe. All rights reserved.\n * This file is licensed to you under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License. You may obtain a copy\n * of the License at http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software distributed under\n * the License is distributed on an \"AS IS\" BASIS, WITHOUT WARRANTIES OR REPRESENTATIONS\n * OF ANY KIND, either express or implied. See the License for the specific language\n * governing permissions and limitations under the License.\n */\n\nimport {AriaListBoxProps} from '@react-types/listbox';\nimport {filterDOMProps, mergeProps} from '@react-aria/utils';\nimport {HTMLAttributes, ReactNode, RefObject} from 'react';\nimport {KeyboardDelegate} from '@react-types/shared';\nimport {listData} from './utils';\nimport {ListState} from '@react-stately/list';\nimport {useFocusWithin} from '@react-aria/interactions';\nimport {useId} from '@react-aria/utils';\nimport {useLabel} from '@react-aria/label';\nimport {useSelectableList} from '@react-aria/selection';\n\ninterface ListBoxAria {\n  /** Props for the listbox element. */\n  listBoxProps: HTMLAttributes<HTMLElement>,\n  /** Props for the listbox's visual label element (if any). */\n  labelProps: HTMLAttributes<HTMLElement>\n}\n\nexport interface AriaListBoxOptions<T> extends Omit<AriaListBoxProps<T>, 'children'> {\n  /** Whether the listbox uses virtual scrolling. */\n  isVirtualized?: boolean,\n\n  /**\n   * An optional keyboard delegate implementation for type to select,\n   * to override the default.\n   */\n  keyboardDelegate?: KeyboardDelegate,\n\n  /**\n   * Whether the listbox items should use virtual focus instead of being focused directly.\n   */\n  shouldUseVirtualFocus?: boolean,\n\n  /** Whether selection should occur on press up instead of press down. */\n  shouldSelectOnPressUp?: boolean,\n\n  /** Whether options should be focused when the user hovers over them. */\n  shouldFocusOnHover?: boolean,\n\n  /**\n   * An optional visual label for the listbox.\n   */\n  label?: ReactNode\n}\n\n/**\n * Provides the behavior and accessibility implementation for a listbox component.\n * A listbox displays a list of options and allows a user to select one or more of them.\n * @param props - Props for the listbox.\n * @param state - State for the listbox, as returned by `useListState`.\n */\nexport function useListBox<T>(props: AriaListBoxOptions<T>, state: ListState<T>, ref: RefObject<HTMLElement>): ListBoxAria {\n  let domProps = filterDOMProps(props, {labelable: true});\n  let {listProps} = useSelectableList({\n    ...props,\n    ref,\n    selectionManager: state.selectionManager,\n    collection: state.collection,\n    disabledKeys: state.disabledKeys\n  });\n\n  let {focusWithinProps} = useFocusWithin({\n    onFocusWithin: props.onFocus,\n    onBlurWithin: props.onBlur,\n    onFocusWithinChange: props.onFocusChange\n  });\n\n  // Share list id and some props with child options.\n  let id = useId(props.id);\n  listData.set(state, {\n    id,\n    shouldUseVirtualFocus: props.shouldUseVirtualFocus,\n    shouldSelectOnPressUp: props.shouldSelectOnPressUp,\n    shouldFocusOnHover: props.shouldFocusOnHover,\n    isVirtualized: props.isVirtualized\n  });\n\n  let {labelProps, fieldProps} = useLabel({\n    ...props,\n    id,\n    // listbox is not an HTML input element so it\n    // shouldn't be labeled by a <label> element.\n    labelElementType: 'span'\n  });\n\n  return {\n    labelProps,\n    listBoxProps: mergeProps(domProps, focusWithinProps, state.selectionManager.selectionMode === 'multiple' ? {\n      'aria-multiselectable': 'true'\n    } : {}, {\n      role: 'listbox',\n      ...mergeProps(fieldProps, listProps)\n    })\n  };\n}\n", "/*\n * Copyright 2020 Adobe. All rights reserved.\n * This file is licensed to you under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License. You may obtain a copy\n * of the License at http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software distributed under\n * the License is distributed on an \"AS IS\" BASIS, WITHOUT WARRANTIES OR REPRESENTATIONS\n * OF ANY KIND, either express or implied. See the License for the specific language\n * governing permissions and limitations under the License.\n */\n\nimport {Key} from 'react';\nimport {ListState} from '@react-stately/list';\n\ninterface ListData {\n  id: string,\n  shouldSelectOnPressUp?: boolean,\n  shouldFocusOnHover?: boolean,\n  shouldUseVirtualFocus?: boolean,\n  isVirtualized?: boolean\n}\n\nexport const listData = new WeakMap<ListState<unknown>, ListData>();\n\nfunction normalizeKey(key: Key): string {\n  if (typeof key === 'string') {\n    return key.replace(/\\s*/g, '');\n  }\n\n  return '' + key;\n}\n\nexport function getItemId<T>(state: ListState<T>, itemKey: Key): string {\n  let data = listData.get(state);\n\n  if (!data) {\n    throw new Error('Unknown list');\n  }\n\n  return `${data.id}-option-${normalizeKey(itemKey)}`;\n}\n", "/*\n * Copyright 2020 Adobe. All rights reserved.\n * This file is licensed to you under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License. You may obtain a copy\n * of the License at http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software distributed under\n * the License is distributed on an \"AS IS\" BASIS, WITHOUT WARRANTIES OR REPRESENTATIONS\n * OF ANY KIND, either express or implied. See the License for the specific language\n * governing permissions and limitations under the License.\n */\n\nimport {getItemCount} from '@react-stately/collections';\nimport {getItemId, listData} from './utils';\nimport {HTMLAttributes, Key, RefObject} from 'react';\nimport {isFocusVisible, useHover} from '@react-aria/interactions';\nimport {isMac, isWebKit, mergeProps, useSlotId} from '@react-aria/utils';\nimport {ListState} from '@react-stately/list';\nimport {useSelectableItem} from '@react-aria/selection';\n\ninterface OptionAria {\n  /** Props for the option element. */\n  optionProps: HTMLAttributes<HTMLElement>,\n\n  /** Props for the main text element inside the option. */\n  labelProps: HTMLAttributes<HTMLElement>,\n\n  /** Props for the description text element inside the option, if any. */\n  descriptionProps: HTMLAttributes<HTMLElement>,\n\n  /** Whether the option is currently focused. */\n  isFocused: boolean,\n  /** Whether the option is currently selected. */\n  isSelected: boolean,\n  /** Whether the option is currently in a pressed state. */\n  isPressed: boolean,\n  /** Whether the option is disabled. */\n  isDisabled: boolean\n}\n\ninterface AriaOptionProps {\n  /**\n   * Whether the option is disabled.\n   * @deprecated\n   */\n  isDisabled?: boolean,\n\n  /**\n   * Whether the option is selected.\n   * @deprecated\n   */\n  isSelected?: boolean,\n\n  /** A screen reader only label for the option. */\n  'aria-label'?: string,\n\n  /** The unique key for the option. */\n  key: Key,\n\n  /**\n   * Whether selection should occur on press up instead of press down.\n   * @deprecated\n   */\n  shouldSelectOnPressUp?: boolean,\n\n  /**\n   * Whether the option should be focused when the user hovers over it.\n   * @deprecated\n   */\n  shouldFocusOnHover?: boolean,\n\n  /**\n   * Whether the option is contained in a virtual scrolling listbox.\n   * @deprecated\n   */\n  isVirtualized?: boolean,\n\n  /**\n   * Whether the option should use virtual focus instead of being focused directly.\n   * @deprecated\n   */\n  shouldUseVirtualFocus?: boolean\n}\n\n/**\n * Provides the behavior and accessibility implementation for an option in a listbox.\n * See `useListBox` for more details about listboxes.\n * @param props - Props for the option.\n * @param state - State for the listbox, as returned by `useListState`.\n */\nexport function useOption<T>(props: AriaOptionProps, state: ListState<T>, ref: RefObject<HTMLElement>): OptionAria {\n  let {\n    key\n  } = props;\n\n  let data = listData.get(state);\n\n  let isDisabled = props.isDisabled ?? state.disabledKeys.has(key);\n  let isSelected = props.isSelected ?? state.selectionManager.isSelected(key);\n  let isFocused = state.selectionManager.focusedKey === key;\n  let shouldSelectOnPressUp = props.shouldSelectOnPressUp ?? data.shouldSelectOnPressUp;\n  let shouldFocusOnHover = props.shouldFocusOnHover ?? data.shouldFocusOnHover;\n  let shouldUseVirtualFocus = props.shouldUseVirtualFocus ?? data.shouldUseVirtualFocus;\n  let isVirtualized = props.isVirtualized ?? data.isVirtualized;\n\n  let labelId = useSlotId();\n  let descriptionId = useSlotId();\n\n  let optionProps = {\n    role: 'option',\n    'aria-disabled': isDisabled,\n    'aria-selected': state.selectionManager.selectionMode !== 'none' ? isSelected : undefined\n  };\n\n  // Safari with VoiceOver on macOS misreads options with aria-labelledby or aria-label as simply \"text\".\n  // We should not map slots to the label and description on Safari and instead just have VoiceOver read the textContent.\n  // https://bugs.webkit.org/show_bug.cgi?id=209279\n  if (!(isMac() && isWebKit())) {\n    optionProps['aria-label'] = props['aria-label'];\n    optionProps['aria-labelledby'] = labelId;\n    optionProps['aria-describedby'] = descriptionId;\n  }\n\n  if (isVirtualized) {\n    optionProps['aria-posinset'] = state.collection.getItem(key).index + 1;\n    optionProps['aria-setsize'] = getItemCount(state.collection);\n  }\n\n  let {itemProps, isPressed} = useSelectableItem({\n    selectionManager: state.selectionManager,\n    key,\n    ref,\n    shouldSelectOnPressUp,\n    allowsDifferentPressOrigin: shouldSelectOnPressUp,\n    isVirtualized,\n    shouldUseVirtualFocus,\n    isDisabled\n  });\n\n  let {hoverProps} = useHover({\n    isDisabled: isDisabled || !shouldFocusOnHover,\n    onHoverStart() {\n      if (!isFocusVisible()) {\n        state.selectionManager.setFocused(true);\n        state.selectionManager.setFocusedKey(key);\n      }\n    }\n  });\n\n  return {\n    optionProps: {\n      ...optionProps,\n      ...mergeProps(itemProps, hoverProps),\n      id: getItemId(state, key)\n    },\n    labelProps: {\n      id: labelId\n    },\n    descriptionProps: {\n      id: descriptionId\n    },\n    isFocused,\n    isSelected,\n    isDisabled,\n    isPressed\n  };\n}\n", "/*\n * Copyright 2020 Adobe. All rights reserved.\n * This file is licensed to you under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License. You may obtain a copy\n * of the License at http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software distributed under\n * the License is distributed on an \"AS IS\" BASIS, WITHOUT WARRANTIES OR REPRESENTATIONS\n * OF ANY KIND, either express or implied. See the License for the specific language\n * governing permissions and limitations under the License.\n */\n\nimport {HTMLAttributes, ReactNode} from 'react';\nimport {useId} from '@react-aria/utils';\n\ninterface AriaListBoxSectionProps {\n  /** The heading for the section. */\n  heading?: ReactNode,\n  /** An accessibility label for the section. Required if `heading` is not present. */\n  'aria-label'?: string\n}\n\ninterface ListBoxSectionAria {\n  /** Props for the wrapper list item. */\n  itemProps: HTMLAttributes<HTMLElement>,\n\n  /** Props for the heading element, if any. */\n  headingProps: HTMLAttributes<HTMLElement>,\n\n  /** Props for the group element. */\n  groupProps: HTMLAttributes<HTMLElement>\n}\n\n/**\n * Provides the behavior and accessibility implementation for a section in a listbox.\n * See `useListBox` for more details about listboxes.\n * @param props - Props for the section.\n */\nexport function useListBoxSection(props: AriaListBoxSectionProps): ListBoxSectionAria {\n  let {heading, 'aria-label': ariaLabel} = props;\n  let headingId = useId();\n\n  return {\n    itemProps: {\n      role: 'presentation'\n    },\n    headingProps: heading ? {\n      // Techincally, listbox cannot contain headings according to ARIA.\n      // We hide the heading from assistive technology, and only use it\n      // as a label for the nested group.\n      id: headingId,\n      'aria-hidden': true\n    } : {},\n    groupProps: {\n      role: 'group',\n      'aria-label': ariaLabel,\n      'aria-labelledby': heading ? headingId : undefined\n    }\n  };\n}\n"],
  "mappings": "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",
  "names": ["$eCAIO$useRef", "$eCAIO$useEffect", "$eCAIO$useMemo"]
}
