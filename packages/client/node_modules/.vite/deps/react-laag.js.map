{
  "version": 3,
  "sources": ["../../../../../node_modules/.pnpm/tiny-warning@1.0.3/node_modules/tiny-warning/dist/tiny-warning.esm.js", "../../../../../node_modules/.pnpm/react-laag@2.0.4_sfoxds7t5ydpegc3knd667wn6m/node_modules/react-laag/src/hooks.ts", "../../../../../node_modules/.pnpm/react-laag@2.0.4_sfoxds7t5ydpegc3knd667wn6m/node_modules/react-laag/src/util.ts", "../../../../../node_modules/.pnpm/react-laag@2.0.4_sfoxds7t5ydpegc3knd667wn6m/node_modules/react-laag/src/useTrackElements.ts", "../../../../../node_modules/.pnpm/react-laag@2.0.4_sfoxds7t5ydpegc3knd667wn6m/node_modules/react-laag/src/useGroup.ts", "../../../../../node_modules/.pnpm/react-laag@2.0.4_sfoxds7t5ydpegc3knd667wn6m/node_modules/react-laag/src/PlacementType.ts", "../../../../../node_modules/.pnpm/react-laag@2.0.4_sfoxds7t5ydpegc3knd667wn6m/node_modules/react-laag/src/Sides.ts", "../../../../../node_modules/.pnpm/react-laag@2.0.4_sfoxds7t5ydpegc3knd667wn6m/node_modules/react-laag/src/BoundsOffsets.ts", "../../../../../node_modules/.pnpm/react-laag@2.0.4_sfoxds7t5ydpegc3knd667wn6m/node_modules/react-laag/src/Bounds.ts", "../../../../../node_modules/.pnpm/react-laag@2.0.4_sfoxds7t5ydpegc3knd667wn6m/node_modules/react-laag/src/Placement.ts", "../../../../../node_modules/.pnpm/react-laag@2.0.4_sfoxds7t5ydpegc3knd667wn6m/node_modules/react-laag/src/getArrowStyle.ts", "../../../../../node_modules/.pnpm/react-laag@2.0.4_sfoxds7t5ydpegc3knd667wn6m/node_modules/react-laag/src/Placements.ts", "../../../../../node_modules/.pnpm/react-laag@2.0.4_sfoxds7t5ydpegc3knd667wn6m/node_modules/react-laag/src/SubjectsBounds.ts", "../../../../../node_modules/.pnpm/react-laag@2.0.4_sfoxds7t5ydpegc3knd667wn6m/node_modules/react-laag/src/useLayer.ts", "../../../../../node_modules/.pnpm/react-laag@2.0.4_sfoxds7t5ydpegc3knd667wn6m/node_modules/react-laag/src/Arrow.ts", "../../../../../node_modules/.pnpm/react-laag@2.0.4_sfoxds7t5ydpegc3knd667wn6m/node_modules/react-laag/src/useHover.ts", "../../../../../node_modules/.pnpm/react-laag@2.0.4_sfoxds7t5ydpegc3knd667wn6m/node_modules/react-laag/src/Transition.ts"],
  "sourcesContent": ["var isProduction = process.env.NODE_ENV === 'production';\nfunction warning(condition, message) {\n  if (!isProduction) {\n    if (condition) {\n      return;\n    }\n\n    var text = \"Warning: \" + message;\n\n    if (typeof console !== 'undefined') {\n      console.warn(text);\n    }\n\n    try {\n      throw Error(text);\n    } catch (x) {}\n  }\n}\n\nexport default warning;\n", "import {\n  useRef,\n  useMemo,\n  useLayoutEffect,\n  useEffect,\n  MutableRefObject,\n  useState,\n  MouseEvent\n} from \"react\";\nimport { IBounds } from \"./Bounds\";\n\n/**\n * Utility hook to track the reference of a html-element.\n * It notifies the listener when a change occured, so it can act\n * on the change\n */\nexport function useTrackRef(\n  onRefChange: (element: HTMLElement) => void\n): (node: HTMLElement | null) => void {\n  const storedReference = useRef<HTMLElement | null>(null);\n\n  // this is de function that actually gets passed to the `ref` prop\n  // on the html element. I.e.:\n  // <div ref={setter} />\n  function setter(element: HTMLElement | null) {\n    if (!element || element === storedReference.current) {\n      return;\n    }\n\n    storedReference.current = element;\n    onRefChange(element);\n  }\n\n  return setter;\n}\n\n/**\n * Utility hook that stores mutable state.\n * Since a getter function is used, it will always return the most\n * up-to-date state. This is useful when you want to get certain state within\n * an effect, without triggering the same effect when the same state changes.\n * Note: may be seen as an anti-pattern.\n */\nexport function useMutableStore<State>(initialState: State): readonly [\n  () => State,\n  {\n    (setter: (state: State) => State): void;\n    (setter: State): void;\n  }\n] {\n  const state = useRef<State>(initialState);\n\n  return useMemo(() => {\n    function set(setter: (state: State) => State): void;\n    function set(setter: State): void;\n    function set(setter: any): void {\n      if (typeof setter === \"function\") {\n        state.current = setter(state.current);\n      } else {\n        state.current = setter;\n      }\n    }\n\n    function get() {\n      return state.current;\n    }\n\n    return [get, set] as const;\n  }, []);\n}\n\n/**\n * Utility hook that keeps track of active event listeners and how\n * to remove these listeners\n */\nexport function useEventSubscriptions() {\n  const subscriptions = useRef<Array<() => void>>([]);\n\n  return useMemo(() => {\n    function hasEventSubscriptions() {\n      return subscriptions.current.length > 0;\n    }\n\n    function removeAllEventSubscriptions() {\n      for (const unsubscribe of subscriptions.current!) {\n        unsubscribe();\n      }\n\n      subscriptions.current = [];\n    }\n\n    function addEventSubscription(unsubscriber: () => void) {\n      subscriptions.current.push(unsubscriber);\n    }\n\n    return {\n      hasEventSubscriptions,\n      removeAllEventSubscriptions,\n      addEventSubscription\n    };\n  }, []);\n}\n\n/**\n * SSR-safe effect hook\n */\nexport const useIsomorphicLayoutEffect =\n  typeof window !== \"undefined\" ? useLayoutEffect : useEffect;\n\n/**\n * Utility hook that tracks an state object.\n * If `enabled=false` it will discard changes and reset the lastState to `null`\n */\nexport function useLastState<T extends unknown>(\n  currentState: T,\n  enabled: boolean\n): MutableRefObject<T | null> {\n  const lastState = useRef<T | null>(currentState);\n\n  if (!enabled) {\n    lastState.current = null;\n    return lastState;\n  }\n\n  lastState.current = currentState;\n  return lastState;\n}\n\nexport type UseMousePositionAsTriggerOptions = {\n  /**\n   * @description Should the position be actively tracked?\n   * @default true\n   */\n  enabled?: boolean;\n  /**\n   * @description Should `handleMouseEvent` preventDefault()?\n   * @default true\n   */\n  preventDefault?: boolean;\n};\n\nexport type UseMousePositionAsTriggerProps = {\n  hasMousePosition: boolean;\n  resetMousePosition: () => void;\n  handleMouseEvent: (evt: MouseEvent) => void;\n  trigger: {\n    getBounds: () => IBounds;\n    getParent?: () => HTMLElement;\n  };\n  parentRef: MutableRefObject<any>;\n};\n\nconst EMPTY_BOUNDS: IBounds = {\n  top: 0,\n  left: 0,\n  right: 1,\n  bottom: 1,\n  width: 1,\n  height: 1\n};\n\n/**\n * @description Utility hook that lets you use the mouse-position as source of the trigger.\n * This is useful in scenario's like context-menu's.\n *\n * @example\n * ```tsx\n * const {\n *  hasMousePosition,\n *  resetMousePosition,\n *  handleMouseEvent,\n *  trigger\n *  } = useMousePositionAsTrigger();\n *\n * const { renderLayer, layerProps } = useLayer({\n *  isOpen: hasMousePosition,\n *  trigger,\n *  onOutsideClick: resetMousePosition\n * });\n *\n * return (\n *  <>\n *   {isOpen && renderLayer(<div {...layerProps} />)}\n *   <div onContextMenu={handleMouseEvent} />\n *  </>\n * );\n * ```\n */\nexport function useMousePositionAsTrigger({\n  enabled = true,\n  preventDefault = true\n}: UseMousePositionAsTriggerOptions = {}): UseMousePositionAsTriggerProps {\n  const parentRef = useRef<any>(null);\n\n  const [mouseBounds, setMouseBounds] = useState<IBounds>(EMPTY_BOUNDS);\n\n  function resetMousePosition() {\n    setMouseBounds(EMPTY_BOUNDS);\n  }\n\n  const hasMousePosition = mouseBounds !== EMPTY_BOUNDS;\n\n  function handleMouseEvent(evt: MouseEvent) {\n    if (!enabled) {\n      return;\n    }\n\n    if (preventDefault) {\n      evt.preventDefault();\n    }\n    const { clientX: left, clientY: top } = evt;\n    setMouseBounds({\n      top,\n      left,\n      width: 1,\n      height: 1,\n      right: left + 1,\n      bottom: top + 1\n    });\n  }\n\n  return {\n    hasMousePosition,\n    resetMousePosition,\n    handleMouseEvent,\n    trigger: {\n      getBounds: () => mouseBounds!,\n      getParent: parentRef.current ? () => parentRef.current : undefined\n    },\n    parentRef\n  };\n}\n", "/**\n * Convert a pixel value into a numeric value\n * @param value string value (ie. '12px')\n */\nexport function getPixelValue(value: string) {\n  return parseFloat(value.replace(\"px\", \"\"));\n}\n\n/**\n * Returns a numeric value that doesn't exceed min or max\n */\nexport function limit(value: number, min: number, max: number): number {\n  return value < min ? min : value > max ? max : value;\n}\n\n/**\n * Utility function which ensures whether a value is truthy\n */\nexport function isSet<T>(value: T | null | undefined): value is T {\n  return value === null || value === undefined ? false : true;\n}\n\n/**\n * Utility function that let's you assign multiple references to a 'ref' prop\n * @param refs list of MutableRefObject's and / or callbacks\n */\nexport function mergeRefs(...refs: any[]) {\n  return (element: HTMLElement | null) => {\n    for (const ref of refs) {\n      if (!ref) {\n        continue;\n      }\n\n      if (typeof ref === \"function\") {\n        ref(element);\n      } else {\n        ref.current = element!;\n      }\n    }\n  };\n}\n", "import { useCallback, useRef, useEffect } from \"react\";\nimport warning from \"tiny-warning\";\nimport { ResizeObserverClass, ScrollOffsets, BorderOffsets } from \"./types\";\nimport {\n  useTrackRef,\n  useMutableStore,\n  useEventSubscriptions,\n  useIsomorphicLayoutEffect\n} from \"./hooks\";\nimport { getPixelValue } from \"./util\";\nimport { IBounds } from \"./Bounds\";\n\n/**\n * Utility to get the correct ResizeObserver class\n */\nexport function getResizeObserver(\n  environment: Window | undefined,\n  polyfill: ResizeObserverClass | undefined\n): ResizeObserverClass | undefined {\n  if (typeof environment === \"undefined\") {\n    return undefined;\n  }\n\n  return polyfill || (environment as any).ResizeObserver;\n}\n\n/**\n * Utility function that given a element traverses up in the html-hierarchy\n * to find and return all ancestors that have scroll behavior\n */\nexport function findScrollContainers(\n  element: HTMLElement | null,\n  environment?: Window\n): HTMLElement[] {\n  const result: HTMLElement[] = [];\n\n  if (!element || !environment || element === document.body) {\n    return result;\n  }\n\n  const { overflow, overflowX, overflowY } =\n    environment.getComputedStyle(element);\n\n  if (\n    [overflow, overflowX, overflowY].some(prop =>\n      [\"auto\", \"scroll\"].includes(prop)\n    )\n  ) {\n    result.push(element);\n  }\n\n  return [\n    ...result,\n    ...findScrollContainers(element.parentElement, environment)\n  ];\n}\n\nfunction createReferenceError(subject: string) {\n  return `react-laag: Could not find a valid reference for the ${subject} element. There might be 2 causes:\n   - Make sure that the 'ref' is set correctly on the ${subject} element when isOpen: true. Also make sure your component forwards the ref with \"forwardRef()\".\n   - Make sure that you are actually rendering the ${subject} when the isOpen prop is set to true`;\n}\n\nexport type OnChangeElements = {\n  layer: HTMLElement;\n  trigger: HTMLElement;\n  arrow: HTMLElement | null;\n  scrollContainers: HTMLElement[];\n};\n\nexport type UseTrackElementsProps = {\n  enabled: boolean;\n  onChange: (\n    elements: OnChangeElements,\n    scrollOffsets: ScrollOffsets,\n    borderOffsets: BorderOffsets\n  ) => void;\n  environment: Window | undefined;\n  ResizeObserverPolyfill: ResizeObserverClass | undefined;\n  overflowContainer: boolean;\n  triggerOption?: {\n    getBounds: () => IBounds;\n    getParent?: () => HTMLElement;\n  };\n};\n\ntype UseTrackElementsReturnValue = {\n  triggerRef: (element: HTMLElement | null) => void;\n  layerRef: (element: HTMLElement | null) => void;\n  arrowRef: React.MutableRefObject<HTMLElement | null>;\n  closestScrollContainer: HTMLElement | null;\n};\n\n/**\n * This hook has the responsibility to track the bounds of:\n * - the trigger element\n * - the layer element\n * - the arrow element\n * - the scroll-containers of which the trigger element is a descendant of\n *\n * It will call the `onChange` callback with a collection of these elements when any\n * of the tracked elements bounds have changed\n *\n * It will detect these changes by listening:\n * - when the reference of the trigger element changes\n * - when the reference of the layer element changes\n * - when the trigger, layer or document body changes in size\n * - when the user scrolls the page, or any of the scroll containers\n */\nexport function useTrackElements({\n  // should we track the bounds?\n  enabled,\n  // call this callback when the bounds have changed\n  onChange,\n  // optional environment (i.e. when using iframes)\n  environment,\n  // optionally inject a polyfill when the browser does not support it\n  // out of the box\n  ResizeObserverPolyfill,\n  // behavior will alter slightly when `overflowContainer` is enabled\n  overflowContainer,\n  // the optional trigger-option provided by the user\n  triggerOption\n}: UseTrackElementsProps): UseTrackElementsReturnValue {\n  // get the correct reference to the ResizeObserver class\n  const ResizeObserver = getResizeObserver(environment, ResizeObserverPolyfill);\n\n  // warn the user when no valid ResizeObserver class could be found\n  useEffect(() => {\n    warning(\n      ResizeObserver,\n      `This browser does not support ResizeObserver out of the box. We recommend to add a polyfill in order to utilize the full capabilities of react-laag. See: https://github.com/everweij/react-laag#resize-observer`\n    );\n  }, [ResizeObserver]);\n\n  // keep reference of the optional arrow-component\n  const arrowRef = useRef<HTMLElement | null>(null);\n\n  // if user has provided the trigger-option we should ingore certain things elsewhere\n  const hasTriggerOption = Boolean(triggerOption);\n\n  // Keep track of mutable element related state\n  // It is generally better to use React.useState, but unfortunately that causes to many re-renders\n  const [get, set] = useMutableStore<{\n    scrollContainers: HTMLElement[];\n    trigger: HTMLElement | null;\n    layer: HTMLElement | null;\n  }>({\n    scrollContainers: [],\n    trigger: null,\n    layer: null\n  });\n\n  // utility to keep track of the scroll and resize listeners and how to unsubscribe them\n  const {\n    hasEventSubscriptions,\n    addEventSubscription,\n    removeAllEventSubscriptions\n  } = useEventSubscriptions();\n\n  // All scroll and resize changes eventually end up here, where the collection of bounds (subjectsBounds) is\n  // constructed in order to notifiy the `onBoundsChange` callback\n  const handleChange = useCallback(\n    function handleChange() {\n      const { layer, trigger, scrollContainers } = get();\n      const closestScrollContainer = scrollContainers[0];\n\n      if (!layer) {\n        throw new Error(createReferenceError(\"layer\"));\n      }\n      // ignore when user has provided the trigger-option\n      if (!trigger && !hasTriggerOption) {\n        throw new Error(createReferenceError(\"trigger\"));\n      }\n\n      let scrollOffsets: ScrollOffsets = { top: 0, left: 0 };\n      if (closestScrollContainer) {\n        const { scrollLeft, scrollTop } = closestScrollContainer;\n        scrollOffsets = {\n          top: scrollTop,\n          left: scrollLeft\n        };\n      } else {\n        const { scrollX, scrollY } = environment!;\n        scrollOffsets = {\n          top: scrollY,\n          left: scrollX\n        };\n      }\n\n      let borderOffsets: BorderOffsets = { left: 0, top: 0 };\n      if (closestScrollContainer) {\n        const { borderLeftWidth, borderTopWidth } =\n          environment!.getComputedStyle(closestScrollContainer);\n\n        borderOffsets = {\n          left: getPixelValue(borderLeftWidth) || 0,\n          top: getPixelValue(borderTopWidth) || 0\n        };\n      }\n\n      onChange(\n        {\n          layer,\n          trigger: trigger!,\n          scrollContainers,\n          arrow: arrowRef.current\n        },\n        scrollOffsets,\n        borderOffsets\n      );\n    },\n    [get, onChange, environment, arrowRef, hasTriggerOption]\n  );\n\n  // responsible for adding the scroll and resize listeners to the correct\n  // html elements\n  const addEventListeners = useCallback(\n    function addEventListeners() {\n      const { trigger, layer, scrollContainers } = get();\n\n      if (!layer) {\n        throw new Error(createReferenceError(\"layer\"));\n      }\n      if (!trigger && !hasTriggerOption) {\n        // ignore when user has provided the trigger-option\n        throw new Error(createReferenceError(\"trigger\"));\n      }\n\n      if (ResizeObserver) {\n        let ignoredInitialCall = false;\n        const observerCallback = () => {\n          if (!ignoredInitialCall) {\n            ignoredInitialCall = true;\n            return;\n          }\n\n          handleChange();\n        };\n\n        const observer = new ResizeObserver(observerCallback);\n        for (const element of [trigger, layer, document.body]) {\n          if (element) observer.observe(element);\n        }\n\n        addEventSubscription(() => {\n          for (const element of [trigger, layer, document.body]) {\n            if (element) observer.unobserve(element);\n          }\n          observer.disconnect();\n        });\n      }\n\n      const listenForScrollElements = [environment!, ...scrollContainers];\n      for (const element of listenForScrollElements) {\n        element.addEventListener(\"scroll\", handleChange);\n\n        addEventSubscription(() =>\n          element.removeEventListener(\"scroll\", handleChange)\n        );\n      }\n    },\n    [\n      get,\n      addEventSubscription,\n      handleChange,\n      environment,\n      ResizeObserver,\n      hasTriggerOption\n    ]\n  );\n\n  // when either the reference to the trigger or layer element changes\n  // we should reset the event listeners and trigger a `onChange`\n  const resetWhenReferenceChangedWhileTracking = useCallback(\n    (previous: HTMLElement | null, next: HTMLElement) => {\n      if (enabled && previous && previous !== next) {\n        removeAllEventSubscriptions();\n        addEventListeners();\n        handleChange();\n      }\n    },\n    [removeAllEventSubscriptions, addEventListeners, handleChange, enabled]\n  );\n\n  // Logic when reference to layer changes\n  const layerRef = useTrackRef(\n    useCallback(\n      layer => {\n        const { layer: previousLayer } = get();\n\n        // store new reference\n        set(state => ({\n          ...state,\n          layer\n        }));\n\n        // check if we should reset the event listeners\n        resetWhenReferenceChangedWhileTracking(previousLayer, layer);\n      },\n      [get, set, resetWhenReferenceChangedWhileTracking]\n    )\n  );\n\n  const getScrollContainers = useCallback(\n    function handleScrollContainers(element: HTMLElement) {\n      const scrollContainers = findScrollContainers(element, environment);\n\n      const closestScrollContainer = scrollContainers[0];\n\n      if (closestScrollContainer) {\n        // Check if we should warn the user about 'position: relative; stuff...'\n        const position = environment!.getComputedStyle(\n          closestScrollContainer\n        ).position;\n\n        const closestScrollContainerHasCorrectStyling =\n          [\"relative\", \"absolute\", \"fixed\"].includes(position) ||\n          overflowContainer;\n\n        if (!closestScrollContainerHasCorrectStyling) {\n          closestScrollContainer.style.position = \"relative\";\n        }\n\n        warning(\n          closestScrollContainerHasCorrectStyling,\n          `react-laag: Set the 'position' style of the nearest scroll-container to 'relative', 'absolute' or 'fixed', or set the 'overflowContainer' prop to true. This is needed in order to position the layer properly. Currently the scroll-container is positioned: \"${position}\". For now, \"position: relative;\" is added for you, but this behavior might be removed in the future. Visit https://react-laag.com/docs/#position-relative for more info.`\n        );\n      }\n      return scrollContainers;\n    },\n    [environment, overflowContainer]\n  );\n\n  // Logic when reference to trigger changes\n  // Note: this will have no effect when user provided the trigger-option\n  const triggerRef = useTrackRef(\n    useCallback(\n      trigger => {\n        // collect list of scroll containers\n        const scrollContainers = getScrollContainers(trigger);\n\n        const { trigger: previousTrigger } = get();\n\n        // store new references\n        set(state => ({\n          ...state,\n          trigger,\n          scrollContainers\n        }));\n\n        // check if we should reset the event listeners\n        resetWhenReferenceChangedWhileTracking(previousTrigger, trigger);\n      },\n      [get, set, resetWhenReferenceChangedWhileTracking, getScrollContainers]\n    )\n  );\n\n  // when user has provided the trigger-option, it monitors the optional parent-element\n  // in order to determine the scroll-containers\n  const triggerOptionParent = triggerOption?.getParent?.();\n  useIsomorphicLayoutEffect(() => {\n    if (!triggerOptionParent) {\n      return;\n    }\n    set(state => ({\n      ...state,\n      scrollContainers: getScrollContainers(triggerOptionParent)\n    }));\n  }, [triggerOptionParent, set, getScrollContainers]);\n\n  useIsomorphicLayoutEffect(() => {\n    if (enabled) {\n      // add event listeners if necessary\n      if (!hasEventSubscriptions()) {\n        addEventListeners();\n      }\n    }\n\n    return () => {\n      if (hasEventSubscriptions()) {\n        removeAllEventSubscriptions();\n      }\n    };\n  }, [\n    enabled,\n    hasEventSubscriptions,\n    addEventListeners,\n    removeAllEventSubscriptions\n  ]);\n\n  // run this effect after every render\n  useIsomorphicLayoutEffect(() => {\n    if (enabled) {\n      // eventually call `handleChange` with latest elements-refs\n      handleChange();\n    }\n  });\n\n  return {\n    triggerRef,\n    layerRef,\n    arrowRef,\n    closestScrollContainer: get().scrollContainers[0] || null\n  };\n}\n", "import {\n  ReactNode,\n  createContext,\n  MutableRefObject,\n  useCallback,\n  useRef,\n  useContext,\n  useEffect,\n  createElement\n} from \"react\";\nimport warning from \"tiny-warning\";\n\ntype Registration = {\n  shouldCloseWhenClickedOutside: (event: MouseEvent) => boolean;\n  closeChild: () => void;\n};\n\ntype Registrations = Set<Registration>;\n\ntype RegisterFn = (registration: Registration) => () => void;\n\ntype GroupContextType = {} | RegisterFn;\n\nconst GroupContext = createContext({} as GroupContextType);\n\ntype GroupProviderProps = {\n  children: ReactNode;\n  registrations: MutableRefObject<Registrations>;\n};\n\n// Provider that wraps arround the layer in order to provide other useLayers\n// down in the hiearchy (child layers) with means to communicate with the parent.\n// This provider receives a `registrations` Set which can be used to add and\n// delete registrations.\nexport function GroupProvider({ children, registrations }: GroupProviderProps) {\n  // registration function that is used as 'context payload' for child layers\n  // to call. It returns a function to unregister.\n  const handleRegister = useCallback(\n    function register(registration: Registration) {\n      registrations.current.add(registration);\n\n      return () => registrations.current.delete(registration);\n    },\n    [registrations]\n  );\n\n  return createElement(\n    GroupContext.Provider,\n    { value: handleRegister },\n    children\n  );\n}\n\n// asks child layers if they would close given the documents click event\n// if there's one that signals not to close, return early (false)\nfunction getShouldCloseAccordingToChildren(\n  registrations: Registrations,\n  event: MouseEvent\n) {\n  for (const { shouldCloseWhenClickedOutside } of registrations) {\n    if (!shouldCloseWhenClickedOutside(event)) {\n      return false;\n    }\n  }\n\n  return true;\n}\n\ntype UseGroup = {\n  isOpen: boolean;\n  onOutsideClick?: () => void;\n  onParentClose?: () => void;\n};\n\n/**\n * Responsible for close behavior\n * When the `onOutsideClick` callback is provided by the user, it will listen for clicks\n * in the document, and tell whether the user clicked outside -> not on layer / trigger.\n * It keeps track of nested useLayers a.k.a child layers (`registrations` Set), through which\n * we can ask whether they `shouldCloseWhenClickedOutside`, or tell them to close.\n *\n * Behavior:\n * - `onOutsideClick` only works on the most outer parent, and not on children. The parent will ask\n *   the child layers whether they would close, and will handle accordingly. The parent may\n *   command the children to close indirectly with the help of `onParentClose`\n * - When the parent just was closed, it will make sure that any children will also close\n *   with the help of `onParentClose`\n */\nexport function useGroup({ isOpen, onOutsideClick, onParentClose }: UseGroup) {\n  // store references to the dom-elements\n  // we need these to later determine wether the clicked outside or not\n  const trigger = useRef<HTMLElement>(null!);\n  const layer = useRef<HTMLElement>(null!);\n\n  // a Set which keeps track of callbacks given by the child layers through context\n  const registrations = useRef<Registrations>(new Set());\n\n  // if this instance is a child itself, we should use this function to register\n  // some callbacks to the parent\n  const possibleRegisterFn = useContext(GroupContext);\n\n  // recursively checks whether to close or not. This mechanism has some similarities\n  // with event bubbling.\n  const shouldCloseWhenClickedOutside = useCallback(\n    function shouldCloseWhenClickedOutside(event: MouseEvent) {\n      const target = event.target as HTMLElement;\n\n      const clickedOnTrigger =\n        trigger.current && trigger.current.contains(target);\n      const clickedOnLayer = layer.current && layer.current.contains(target);\n\n      const shouldCloseAccordingToChildren = getShouldCloseAccordingToChildren(\n        registrations.current,\n        event\n      );\n\n      // when clicked on own layer, but the child would have closed ->\n      // let child close\n      if (clickedOnLayer && shouldCloseAccordingToChildren) {\n        registrations.current.forEach(({ closeChild }) => closeChild());\n      }\n\n      return (\n        !clickedOnTrigger && !clickedOnLayer && shouldCloseAccordingToChildren\n      );\n    },\n    [trigger, layer, registrations]\n  );\n\n  // registration stuff\n  useEffect(() => {\n    if (typeof possibleRegisterFn !== \"function\") {\n      return;\n    }\n\n    // 'possibleRegisterFn' will return a function that will unregister\n    // on cleanup\n    return possibleRegisterFn({\n      shouldCloseWhenClickedOutside,\n      closeChild: () => {\n        warning(\n          onParentClose,\n          `react-laag: You are using useLayer() in a nested setting but forgot to set the 'onParentClose()' callback in the options. This could lead to unexpected behavior.`\n        );\n\n        if (onParentClose) {\n          onParentClose();\n        }\n      }\n    });\n  }, [\n    possibleRegisterFn,\n    shouldCloseWhenClickedOutside,\n    onParentClose,\n    registrations\n  ]);\n\n  // document click handling\n  useEffect(() => {\n    const isChild = typeof possibleRegisterFn === \"function\";\n    const shouldNotListen = !isOpen || !onOutsideClick || isChild;\n    if (shouldNotListen) {\n      return;\n    }\n\n    function handleClick(event: MouseEvent) {\n      if (shouldCloseWhenClickedOutside(event)) {\n        onOutsideClick!();\n      }\n    }\n\n    document.addEventListener(\"click\", handleClick, true);\n    return () => document.removeEventListener(\"click\", handleClick, true);\n  }, [\n    isOpen,\n    onOutsideClick,\n    shouldCloseWhenClickedOutside,\n    possibleRegisterFn\n  ]);\n\n  // When this 'useLayer' gets closed -> tell child layers to close as well\n  useEffect(() => {\n    if (!isOpen) {\n      registrations.current.forEach(({ closeChild }) => closeChild());\n    }\n  }, [isOpen]);\n\n  return {\n    closeOnOutsideClickRefs: {\n      trigger,\n      layer\n    },\n    registrations\n  };\n}\n", "export const PLACEMENT_TYPES: PlacementType[] = [\n  \"bottom-start\",\n  \"bottom-end\",\n  \"bottom-center\",\n  \"top-start\",\n  \"top-center\",\n  \"top-end\",\n  \"left-end\",\n  \"left-center\",\n  \"left-start\",\n  \"right-end\",\n  \"right-center\",\n  \"right-start\",\n  \"center\"\n];\n\nexport type PlacementType =\n  | \"bottom-start\"\n  | \"bottom-end\"\n  | \"bottom-center\"\n  | \"top-start\"\n  | \"top-center\"\n  | \"top-end\"\n  | \"left-end\"\n  | \"left-center\"\n  | \"left-start\"\n  | \"right-end\"\n  | \"right-center\"\n  | \"right-start\"\n  | \"center\";\n", "export type BoundSideProp = \"top\" | \"left\" | \"bottom\" | \"right\";\nexport type SideProp = BoundSideProp | \"center\";\ntype SizeProp = \"width\" | \"height\";\ntype CssProp = \"top\" | \"left\";\n\nconst OPPOSITES: Record<SideProp, SideProp> = {\n  top: \"bottom\",\n  left: \"right\",\n  bottom: \"top\",\n  right: \"left\",\n  center: \"center\"\n};\n\nclass SideBase<T extends SideProp> {\n  constructor(\n    readonly prop: T,\n    readonly opposite: SideBase<T>,\n    readonly isHorizontal: boolean,\n    readonly sizeProp: SizeProp,\n    readonly oppositeSizeProp: SizeProp,\n    readonly cssProp: CssProp,\n    readonly oppositeCssProp: CssProp,\n    readonly isCenter: boolean,\n    readonly isPush: boolean // left | top\n  ) {}\n\n  factor(value: number) {\n    return value * (this.isPush ? 1 : -1);\n  }\n\n  isOppositeDirection(side: SideBase<any>) {\n    return this.isHorizontal !== side.isHorizontal;\n  }\n}\n\nfunction createSide<T extends SideProp>(\n  prop: T,\n  recursive = true\n): SideBase<T> {\n  const isHorizontal = [\"left\", \"right\"].includes(prop);\n\n  return new SideBase<T>(\n    prop,\n    recursive ? createSide<T>((OPPOSITES as any)[prop], false) : null!,\n    isHorizontal,\n    isHorizontal ? \"width\" : \"height\",\n    isHorizontal ? \"height\" : \"width\",\n    isHorizontal ? \"left\" : \"top\",\n    isHorizontal ? \"top\" : \"left\",\n    prop === \"center\",\n    ![\"right\", \"bottom\"].includes(prop)\n  );\n}\n\nexport type BoundSideType = SideBase<BoundSideProp>;\nexport type SideType = SideBase<SideProp>;\n\nexport const BoundSide = {\n  top: createSide(\"top\") as BoundSideType,\n  bottom: createSide(\"bottom\") as BoundSideType,\n  left: createSide(\"left\") as BoundSideType,\n  right: createSide(\"right\") as BoundSideType\n};\n\nexport const Side = {\n  ...(BoundSide as {\n    top: SideType;\n    left: SideType;\n    bottom: SideType;\n    right: SideType;\n  }),\n  center: createSide(\"center\")\n};\n", "export interface IBoundsOffsets {\n  top: number;\n  left: number;\n  right: number;\n  bottom: number;\n}\n\nconst SIDES = [\"top\", \"left\", \"bottom\", \"right\"] as (keyof IBoundsOffsets)[];\n\n/**\n * A class containing the positional properties which represent the distance\n * between two Bounds instances for each side\n */\nexport class BoundsOffsets implements IBoundsOffsets {\n  top!: number;\n  left!: number;\n  right!: number;\n  bottom!: number;\n\n  constructor(offsets: IBoundsOffsets) {\n    return Object.assign(this, offsets);\n  }\n\n  /**\n   * Takes multiple BoundsOffets instances and creates a new BoundsOffsets instance\n   * by taking the smallest value for each side\n   * @param boundsOffsets list of BoundsOffsets instances\n   */\n  static mergeSmallestSides(boundsOffsets: BoundsOffsets[]): BoundsOffsets {\n    const [first, ...rest] = boundsOffsets;\n\n    if (!first) {\n      throw new Error(\n        \"Please provide at least 1 bounds objects in order to merge\"\n      );\n    }\n\n    const result: IBoundsOffsets = Object.fromEntries(\n      SIDES.map(side => [side, first[side]])\n    ) as any;\n\n    for (const boundsOffset of rest) {\n      for (const side of SIDES) {\n        result[side] = Math.min(result[side], boundsOffset[side]);\n      }\n    }\n\n    return new BoundsOffsets(result);\n  }\n\n  /**\n   * Checks whether all sides sides are positive, meaning the corresponding Bounds instance\n   * fits perfectly within a parent Bounds instance\n   */\n  get allSidesArePositive(): boolean {\n    return SIDES.every(side => this[side] >= 0);\n  }\n\n  /**\n   * Returns a partial IBoundsOffsets with sides that are negative, meaning sides aren't entirely\n   * visible in respect to a parent Bounds instance\n   */\n  get negativeSides(): Partial<IBoundsOffsets> {\n    return Object.fromEntries(\n      SIDES.filter(side => this[side] < 0).map(side => [side, this[side]])\n    ) as Partial<IBoundsOffsets>;\n  }\n}\n", "import { BoundSide, BoundSideProp, BoundSideType } from \"./Sides\";\nimport { BoundsOffsets } from \"./BoundsOffsets\";\nimport { getPixelValue } from \"./util\";\n\n/**\n * Utility function that returns sum of various computed styles\n * @param propertyValues list of computed styles (ie. '12px')\n */\nfunction sumOfPropertyValues(...propertyValues: string[]) {\n  return propertyValues.reduce(\n    (sum, propertyValue) =>\n      sum + (propertyValue ? getPixelValue(propertyValue!) : 0),\n    0\n  );\n}\n\nexport interface IBounds {\n  top: number;\n  left: number;\n  right: number;\n  bottom: number;\n  width: number;\n  height: number;\n}\n\nexport function boundsToObject({\n  top,\n  left,\n  right,\n  bottom,\n  width,\n  height\n}: IBounds): IBounds {\n  return { top, left, right, bottom, width, height };\n}\n\nconst EMPTY: IBounds = {\n  top: 0,\n  left: 0,\n  right: 0,\n  bottom: 0,\n  width: 0,\n  height: 0\n};\n\n/**\n * A class containing the positional properties of the native DOM's ClientRect\n * (`element.getBoundingClientRect()`), together with some utility methods\n */\nexport class Bounds implements IBounds {\n  top!: number;\n  left!: number;\n  right!: number;\n  bottom!: number;\n  width!: number;\n  height!: number;\n\n  /**\n   * Creates a new Bounds class\n   * @param bounds An object that adheres to the `IBounds` interface\n   */\n  static create(bounds: IBounds): Bounds {\n    return new Bounds(bounds);\n  }\n\n  /**\n   * Creates a new Bounds class from a DOM-element\n   * @param element reference to the DOM-element\n   * @param options optional options object\n   */\n  static fromElement(\n    element: HTMLElement,\n    options: {\n      /** should transforms like 'scale' taken into account? Defaults to `true` */\n      withTransform?: boolean;\n      /** reference to the window-object (needed when working with iframes for instance). Defaults to `window` */\n      environment?: Window;\n      /** should the elements scrollbars be included? Defaults to `true` */\n      withScrollbars?: boolean;\n    } = {}\n  ): Bounds {\n    const {\n      withTransform = true,\n      environment = window,\n      withScrollbars = true\n    } = options;\n\n    const plain: IBounds = boundsToObject(element.getBoundingClientRect());\n\n    let bounds: Bounds = new Bounds(plain);\n\n    if (!withTransform) {\n      const {\n        width,\n        height,\n        boxSizing,\n        borderLeft,\n        borderRight,\n        borderTop,\n        borderBottom,\n        paddingLeft,\n        paddingRight,\n        paddingTop,\n        paddingBottom\n      } = environment.getComputedStyle(element);\n\n      const boxWidth =\n        boxSizing === \"border-box\"\n          ? getPixelValue(width!)\n          : sumOfPropertyValues(\n              width,\n              borderLeft,\n              borderRight,\n              paddingLeft,\n              paddingRight\n            );\n\n      const boxHeight =\n        boxSizing === \"border-box\"\n          ? getPixelValue(height!)\n          : sumOfPropertyValues(\n              height,\n              borderTop,\n              borderBottom,\n              paddingTop,\n              paddingBottom\n            );\n\n      bounds = new Bounds({\n        ...bounds,\n        width: boxWidth,\n        height: boxHeight\n      });\n    }\n\n    if (!withScrollbars) {\n      const scrollbarWidth = bounds.width - element.clientWidth;\n      const scrollbarHeight = bounds.height - element.clientHeight;\n      return bounds.substract({\n        right: scrollbarWidth,\n        bottom: scrollbarHeight\n      });\n    }\n\n    return bounds;\n  }\n\n  /**\n   * Creates an empty Bounds class\n   */\n  static empty(): Bounds {\n    return new Bounds();\n  }\n\n  /**\n   * Creates a Bounds class from the window's dimensions\n   * @param environment reference to the window-object (needed when working with iframes for instance). Defaults to `window`\n   */\n  static fromWindow(environment?: Window): Bounds {\n    const scrollingElement =\n      environment?.document.scrollingElement ??\n      environment?.document.documentElement;\n    const { clientWidth: width = 0, clientHeight: height = 0 } =\n      scrollingElement ?? {};\n\n    return new Bounds({ width, height, right: width, bottom: height });\n  }\n\n  protected constructor(bounds: Partial<IBounds> = {}) {\n    return Object.assign(this, EMPTY, bounds);\n  }\n\n  /**\n   * Returns the square surface of the bounds in pixels\n   */\n  get surface(): number {\n    return this.width * this.height;\n  }\n\n  /**\n   * Returns a plain object containing only positional properties\n   */\n  toObject(): IBounds {\n    return boundsToObject(this);\n  }\n\n  /**\n   * Returns a new Bounds instance by merging two bounds\n   * @param bounds partial bounds which should be merged\n   */\n  merge(bounds: Partial<IBounds>): Bounds;\n  /**\n   * Returns a new Bounds instance by merging two bounds\n   * @param mergeFn callback which takes the current bounds and returns new merged bounds\n   */\n  merge(mergeFn: (current: IBounds) => Partial<IBounds>): Bounds;\n  merge(partialBoundsOrMergeFn: unknown): Bounds {\n    const current = this.toObject();\n    return new Bounds({\n      ...current,\n      ...(typeof partialBoundsOrMergeFn === \"function\"\n        ? partialBoundsOrMergeFn(current)\n        : partialBoundsOrMergeFn)\n    });\n  }\n\n  /**\n   * Return a new Bounds instance by subtracting each property of the provided IBounds object\n   * @param bounds partial IBounds object to substract with\n   */\n  substract(bounds: Partial<IBounds>): Bounds {\n    const result = this.toObject();\n\n    const entries = Object.entries(bounds) as [keyof IBounds, number][];\n\n    for (const [prop, value] of entries) {\n      if (prop in BoundSide) {\n        // if `prop` is one of 'top', 'left', 'bottom' or 'right'...\n        const boundSide = BoundSide[prop as BoundSideProp];\n        // decide if we should add or substract\n        result[prop] += boundSide.factor(value);\n        // make sure that the size-properties are also updated\n        result[boundSide.isHorizontal ? \"width\" : \"height\"] -= value;\n      } else {\n        // prop is 'width' or 'height'\n        result[prop] -= value || 0;\n      }\n    }\n\n    return new Bounds(result);\n  }\n\n  /**\n   * Returns a new BoundsOffsets instance by determining the distance for each bound-side:\n   * (child -> parent)\n   * @param child child bounds instance\n   */\n  offsetsTo(child: Bounds): BoundsOffsets {\n    return new BoundsOffsets({\n      top: child.top - this.top,\n      bottom: this.bottom - child.bottom,\n      left: child.left - this.left,\n      right: this.right - child.right\n    });\n  }\n\n  /**\n   * Return a new Bounds instance by mapping over each bound-side\n   * @param mapper callback that takes a boundSide + value in pixels, returning a new value for that side\n   */\n  mapSides(\n    mapper: (boundSide: BoundSideType, value: number) => number\n  ): Bounds {\n    const result = this.toObject();\n    const boundSides = Object.values(BoundSide) as BoundSideType[];\n    for (const boundSide of boundSides) {\n      result[boundSide.prop] = mapper(boundSide, result[boundSide.prop]);\n    }\n    return new Bounds(result);\n  }\n}\n", "import { BoundSideType, SideType, BoundSide, BoundSideProp } from \"./Sides\";\nimport { PlacementType } from \"./PlacementType\";\nimport { SubjectsBounds } from \"./SubjectsBounds\";\nimport { PositionConfig, Offsets } from \"./types\";\nimport { Bounds, IBounds } from \"./Bounds\";\nimport { BoundsOffsets } from \"./BoundsOffsets\";\nimport { limit } from \"./util\";\n\n/**\n * Class for various calculations based on a placement-type. I.e 'top-left';\n */\nexport class Placement {\n  protected subjectsBounds!: SubjectsBounds;\n  private _cachedLayerBounds: Bounds | null = null;\n  private _cachedContainerOffsets: BoundsOffsets | null = null;\n\n  constructor(\n    public readonly primary: SideType,\n    public readonly secondary: SideType,\n    subjectBounds: SubjectsBounds,\n    layerDimensions: PositionConfig[\"layerDimensions\"],\n    private readonly offsets: Offsets\n  ) {\n    this.setSubjectsBounds(subjectBounds, layerDimensions);\n  }\n\n  /**\n   * Set subjectsBounds that are specific for this placement\n   * @param subjectBounds original SubjectBounds instance\n   * @param layerDimensions possible config prodvided by the user\n   */\n  private setSubjectsBounds(\n    subjectBounds: SubjectsBounds,\n    layerDimensions: PositionConfig[\"layerDimensions\"]\n  ): void {\n    // if user did not provide any layerDimensions config...\n    if (!layerDimensions) {\n      this.subjectsBounds = subjectBounds;\n      return;\n    }\n\n    // get anticipated layer-dimensions provided by the user\n    const dimensions =\n      // if the user passed a callback, call it with the layerSide corresponding to\n      // the placement\n      typeof layerDimensions === \"function\"\n        ? layerDimensions(this.primary.prop)\n        : layerDimensions;\n\n    // create new SubjectsBounds instance by merging our newly create layer-bounds\n    this.subjectsBounds = subjectBounds.merge({\n      layer: {\n        ...subjectBounds.layer,\n        ...dimensions\n      }\n    });\n  }\n\n  /**\n   * Returns the string respresentation of this placement (ie. 'top-start')\n   */\n  public get type(): PlacementType {\n    return `${this.primary.prop}-${\n      this.secondary.prop === \"center\"\n        ? \"center\"\n        : [\"bottom\", \"right\"].includes(this.secondary.prop)\n        ? \"end\"\n        : \"start\"\n    }` as PlacementType;\n  }\n\n  /**\n   * Calculates the actual boundaries based on the placement\n   * @param secondaryOffset optional offset on the secondary-side\n   */\n  public getLayerBounds(secondaryOffset = 0): Bounds {\n    // return cached version if possible\n    if (this._cachedLayerBounds && secondaryOffset === 0) {\n      return this._cachedLayerBounds;\n    }\n\n    const { primary, secondary, subjectsBounds } = this;\n    const { trigger, layer, arrow } = subjectsBounds;\n    const { isHorizontal, oppositeCssProp, oppositeSizeProp, prop, opposite } =\n      primary as BoundSideType;\n\n    const result = Bounds.empty() as IBounds;\n\n    // let's take the placement 'top-start' as an example...\n    // the offsets are the following:\n    // trigger -> 8px\n    // container -> 10px;\n    // arrow -> 2px;\n\n    // PRIMARY STUFF\n\n    // bottom = trigger.top + 8;\n    result[opposite.prop] =\n      trigger[prop] - primary.factor(this.offsets.trigger);\n\n    // top = bottom - layer.height\n    result[prop] =\n      result[opposite.prop] - primary.factor(layer[primary.sizeProp]);\n\n    // SECONDARY STUFF\n\n    // arrowOffsetBase = 4\n    const arrowOffsetBase = this.offsets.arrow * 2;\n\n    // limitMin = trigger.left - (layer.width - arrow.width) + 4\n    let limitMin =\n      trigger[oppositeCssProp] -\n      (layer[oppositeSizeProp] - arrow[oppositeSizeProp]) +\n      arrowOffsetBase;\n    // limitMax = trigger.left + (trigger.width - arrow.width) - 4\n    let limitMax =\n      trigger[oppositeCssProp] +\n      (trigger[oppositeSizeProp] - arrow[oppositeSizeProp]) -\n      arrowOffsetBase;\n\n    if (!secondary.isPush) {\n      // if secondary is bottom or right -> add the width or height of the layer\n      limitMin += layer[oppositeSizeProp];\n      limitMax += layer[oppositeSizeProp];\n    }\n\n    if (secondary.isCenter) {\n      const propertyA = (isHorizontal ? BoundSide.top : BoundSide.left).prop;\n      const propertyB = (isHorizontal ? BoundSide.bottom : BoundSide.right)\n        .prop;\n\n      // left = limit(\n      //   trigger.left + trigger.width / 2 - layer.width / 2 + secondaryOffset,\n      //   limitMin,\n      //   limitMax\n      // )\n      result[propertyA] = limit(\n        trigger[propertyA] +\n          trigger[oppositeSizeProp] / 2 -\n          layer[oppositeSizeProp] / 2 +\n          secondaryOffset,\n        limitMin,\n        limitMax\n      );\n\n      // right = left + layer.width\n      result[propertyB] = result[propertyA] + layer[oppositeSizeProp];\n    } else {\n      const sec = secondary as BoundSideType;\n\n      const triggerValue = trigger[sec.prop];\n\n      // Under some conditions, when the layer is not able to align with the trigger\n      // due to arrow-size and arrow-offsets, we need to compensate.\n      // Otherwise, the secondary-offset will have no impact\n      const arrowCompensation =\n        triggerValue < limitMin\n          ? limitMin - triggerValue\n          : triggerValue > limitMax\n          ? limitMax - triggerValue\n          : 0;\n\n      // left = limit(\n      //   trigger.left + secondaryOffset + arrowCompensation,\n      //   limitMin,\n      //   limitMax\n      // )\n      result[sec.prop] = limit(\n        triggerValue + secondaryOffset + arrowCompensation,\n        limitMin,\n        limitMax\n      );\n\n      // right = left + layer.width\n      result[sec.opposite.prop] =\n        result[sec.prop] + secondary.factor(layer[oppositeSizeProp]);\n    }\n\n    // set the correct dimensions\n    result.width = result.right - result.left;\n    result.height = result.bottom - result.top;\n\n    // create new bounds object\n    const layerBounds = Bounds.create(result);\n\n    if (secondaryOffset === 0) {\n      this._cachedLayerBounds = layerBounds;\n    }\n\n    return layerBounds;\n  }\n\n  /**\n   * Checks whether the trigger is bigger on the opposite side\n   * ie. placement \"top-start\" -> has trigger a bigger width?\n   */\n  public get triggerIsBigger() {\n    const { isHorizontal } = this.secondary;\n    const { triggerHasBiggerWidth, triggerHasBiggerHeight } =\n      this.subjectsBounds;\n\n    return (\n      (isHorizontal && triggerHasBiggerWidth) ||\n      (!isHorizontal && triggerHasBiggerHeight)\n    );\n  }\n\n  /**\n   * Checks whether the placement fits within all it's container (including container-offset)\n   */\n  public get fitsContainer(): boolean {\n    return this.getContainerOffsets().allSidesArePositive;\n  }\n\n  /**\n   * Returns the surface in square pixels of the visible part of the layer\n   */\n  public get visibleSurface(): number {\n    const layerBounds = this.getLayerBounds();\n    const containerOffsets = this.getContainerOffsets(layerBounds);\n\n    const substract = containerOffsets.negativeSides;\n    for (const side in substract) {\n      // @ts-ignore\n      substract[side] = -substract[side]; // make positive for substraction;\n    }\n\n    return layerBounds.substract(substract).surface;\n  }\n\n  /**\n   * Returns a BoundSide by looking at the most negative offset that is the opposite direction\n   */\n  public get secondaryOffsetSide(): BoundSideType | null {\n    // Given placement 'top-start' and containerOffsets { left: -20, top: -10, right: -10, bottom: 200 }...\n    // the only negative offsets on the opposite side are { left: -20, right: -10 }\n    // since we have to return only 1 side, we pick the most negative, which is 'left'\n\n    const containerOffsets = this.getContainerOffsets();\n\n    const [mostNegativeSide] =\n      Object.entries(containerOffsets.negativeSides)\n        .map(\n          ([side, value]) => [BoundSide[side as BoundSideProp], value] as const\n        )\n        .filter(([side]) => this.primary.isOppositeDirection(side))\n        .sort(([, a], [, b]) => b! - a!)?.[0] ?? [];\n\n    return mostNegativeSide || null;\n  }\n\n  /**\n   * returns getLayerBounds(), including container-offsets\n   */\n  private getLayerCollisionBounds(): Bounds {\n    const { container } = this.offsets;\n\n    return this.getLayerBounds()\n      .mapSides((side, value) => (value -= side.factor(container)))\n      .merge(({ width, height }) => ({\n        width: width + container * 2,\n        height: height + container * 2\n      }));\n  }\n\n  /**\n   * Returns a BoundsOffsets instance containing merged offsets to containers with the most\n   * negative scenario\n   */\n  public getContainerOffsets(layerBounds?: Bounds): BoundsOffsets {\n    if (this._cachedContainerOffsets && !layerBounds) {\n      return this._cachedContainerOffsets;\n    }\n\n    const subjectBounds = this.subjectsBounds.merge({\n      layer: layerBounds || this.getLayerCollisionBounds()\n    });\n\n    const offsets = BoundsOffsets.mergeSmallestSides(\n      subjectBounds.layerOffsetsToScrollContainers\n    );\n\n    if (!layerBounds) {\n      this._cachedContainerOffsets = offsets;\n    }\n\n    return offsets;\n  }\n}\n\nexport class PlacementCenter extends Placement {\n  getLayerBounds(): Bounds {\n    const { trigger, layer } = this.subjectsBounds;\n\n    const result = Bounds.empty() as IBounds;\n\n    result.top = trigger.top + trigger.height / 2 - layer.height / 2;\n    result.bottom = result.top + layer.height;\n    result.left = trigger.left + trigger.width / 2 - layer.width / 2;\n    result.right = result.left + layer.width;\n    result.width = result.right - result.left;\n    result.height = result.bottom - result.top;\n\n    return result as Bounds;\n  }\n}\n", "import { limit } from \"./util\";\nimport { SubjectsBounds } from \"./SubjectsBounds\";\nimport { Placement } from \"./Placement\";\n\n// how much pixels is the center of layer removed from edge of trigger?\nfunction getNegativeOffsetBetweenLayerCenterAndTrigger(\n  subjectsBounds: SubjectsBounds,\n  placement: Placement,\n  arrowOffset: number\n) {\n  const { layer, trigger, arrow } = subjectsBounds;\n\n  const sizeProperty = placement.primary.oppositeSizeProp;\n\n  const [sideA, sideB] = !placement.primary.isHorizontal\n    ? ([\"left\", \"right\"] as const)\n    : ([\"top\", \"bottom\"] as const);\n\n  const offsetA =\n    layer[sideA] +\n    layer[sizeProperty] / 2 -\n    trigger[sideA] -\n    arrow[sizeProperty] / 2 -\n    arrowOffset;\n  const offsetB =\n    layer[sideB] -\n    layer[sizeProperty] / 2 -\n    trigger[sideB] +\n    arrow[sizeProperty] / 2 +\n    arrowOffset;\n\n  return (offsetA < 0 ? -offsetA : 0) + (offsetB > 0 ? -offsetB : 0);\n}\n\nconst STYLE_BASE: React.CSSProperties = {\n  position: \"absolute\",\n  willChange: \"top, left\",\n  left: null!,\n  right: null!,\n  top: null!,\n  bottom: null!\n};\n\nexport function getArrowStyle(\n  subjectsBounds: SubjectsBounds,\n  placement: Placement,\n  arrowOffset: number\n): React.CSSProperties {\n  if (placement.primary.isCenter) {\n    return STYLE_BASE;\n  }\n\n  const { layer, trigger, arrow } = subjectsBounds;\n\n  const sizeProperty = placement.primary.oppositeSizeProp;\n  const triggerIsBigger = trigger[sizeProperty] > layer[sizeProperty];\n\n  const min = arrowOffset + arrow[sizeProperty] / 2;\n  const max = layer[sizeProperty] - arrow[sizeProperty] / 2 - arrowOffset;\n\n  const negativeOffset = getNegativeOffsetBetweenLayerCenterAndTrigger(\n    subjectsBounds,\n    placement,\n    arrowOffset\n  );\n\n  const primarySide = placement.primary.prop;\n  const secondarySide = placement.primary.oppositeCssProp;\n\n  const secondaryValue = triggerIsBigger\n    ? layer[sizeProperty] / 2 + negativeOffset\n    : trigger[secondarySide] + trigger[sizeProperty] / 2 - layer[secondarySide];\n\n  return {\n    ...STYLE_BASE,\n    [primarySide]: \"100%\",\n    [secondarySide]: limit(secondaryValue, min, max)\n  };\n}\n", "import { CSSProperties } from \"react\";\nimport {\n  BoundSide,\n  Side,\n  BoundSideType,\n  SideType,\n  BoundSideProp,\n  SideProp\n} from \"./Sides\";\nimport { PlacementType } from \"./PlacementType\";\nimport { Placement, PlacementCenter } from \"./Placement\";\nimport { SubjectsBounds } from \"./SubjectsBounds\";\nimport {\n  PositionConfig,\n  Offsets,\n  ScrollOffsets,\n  BorderOffsets,\n  DisappearType,\n  Styles\n} from \"./types\";\nimport { Bounds } from \"./Bounds\";\nimport { getArrowStyle } from \"./getArrowStyle\";\nimport { BoundsOffsets } from \"./BoundsOffsets\";\n\n/**\n * Class mostly concerned about calculating and finding the right placement\n */\nexport class Placements {\n  protected constructor(\n    public readonly placements: Placement[],\n    private config: PositionConfig,\n    private subjectsBounds: SubjectsBounds\n  ) {}\n\n  /**\n   * Converts a placement-type into a primary-side and a secondary-side\n   */\n  static getSidesFromPlacementType(\n    type: PlacementType\n  ): [BoundSideType, SideType] {\n    let [a, b] = type.split(\"-\") as unknown as [\n      keyof typeof BoundSide,\n      \"start\" | \"center\" | \"end\"\n    ];\n\n    const primary = BoundSide[a];\n    let secondary: SideType;\n    if (b === \"center\") {\n      secondary = Side.center;\n    } else if (primary.isHorizontal) {\n      secondary = b === \"start\" ? Side.top : Side.bottom;\n    } else {\n      secondary = b === \"start\" ? Side.left : Side.right;\n    }\n\n    return [primary, secondary];\n  }\n\n  /**\n   * Main static method to create a Placements instance\n   * @param subjectsBounds instance of the SubjectsBounds class\n   * @param config config provided by the user\n   */\n  static create(\n    subjectsBounds: SubjectsBounds,\n    config: PositionConfig\n  ): Placements {\n    // create offsets-object from user config\n    const offsets: Offsets = {\n      arrow: config.arrowOffset,\n      container: config.containerOffset,\n      trigger: config.triggerOffset\n    };\n\n    // function which creates a prioritized list of possible placments\n    // by looking at user-config\n    function getListOfPlacements(preferedPlacement = config.placement) {\n      const [primary, secondary] =\n        Placements.getSidesFromPlacementType(preferedPlacement);\n\n      const preferredSide =\n        BoundSide[primary.isHorizontal ? config.preferY : config.preferX];\n\n      // some priorities may alter when the trigger is bigger\n      const triggerIsBigger =\n        (!primary.isHorizontal && subjectsBounds.triggerHasBiggerWidth) ||\n        (primary.isHorizontal && subjectsBounds.triggerHasBiggerHeight);\n\n      // utility function which constructs a placement by primary and secondary sides\n      function placementFrom(\n        primary: BoundSideType,\n        secondary: SideType\n      ): Placement {\n        return new Placement(\n          primary,\n          secondary,\n          subjectsBounds,\n          config.layerDimensions,\n          offsets\n        );\n      }\n\n      // creating the list\n      let list: Placement[] = [];\n      list[0] = placementFrom(primary, secondary);\n      list[1] = placementFrom(\n        primary,\n        secondary.isCenter ? preferredSide : Side.center\n      );\n      list[2] = placementFrom(\n        primary,\n        Side[\n          (secondary.opposite.isCenter\n            ? preferredSide.opposite\n            : secondary.opposite\n          ).prop\n        ]\n      );\n      list[3] = placementFrom(\n        preferredSide,\n        triggerIsBigger ? primary : Side[primary.opposite.prop]\n      );\n      list[4] = placementFrom(preferredSide, Side.center);\n      list[5] = placementFrom(\n        preferredSide,\n        triggerIsBigger ? Side[primary.opposite.prop] : primary\n      );\n      list[6] = placementFrom(\n        BoundSide[preferredSide.opposite.prop],\n        triggerIsBigger ? primary : Side[primary.opposite.prop]\n      );\n      list[7] = placementFrom(\n        BoundSide[preferredSide.opposite.prop],\n        Side.center\n      );\n      list[8] = placementFrom(\n        BoundSide[preferredSide.opposite.prop],\n        triggerIsBigger ? Side[primary.opposite.prop] : primary\n      );\n      list[9] = placementFrom(BoundSide[primary.opposite.prop], secondary);\n      list[10] = placementFrom(\n        BoundSide[primary.opposite.prop],\n        secondary.isCenter ? preferredSide : Side.center\n      );\n      list[11] = placementFrom(\n        BoundSide[primary.opposite.prop],\n        Side[\n          (secondary.opposite.isCenter\n            ? preferredSide.opposite\n            : secondary.opposite\n          ).prop\n        ]\n      );\n\n      // only include placements that are part of 'possible-placements'\n      list = list.filter(\n        placement =>\n          placement.type === config.placement ||\n          config.possiblePlacements.includes(placement.type)\n      );\n\n      return list;\n    }\n\n    // treat placement 'center' a little bit different\n    if (config.placement === \"center\") {\n      return new Placements(\n        [\n          new PlacementCenter(\n            Side.center,\n            Side.center,\n            subjectsBounds,\n            config.layerDimensions,\n            offsets\n          ),\n          ...getListOfPlacements(\n            `${config.preferY}-${config.preferX}` as PlacementType\n          )\n        ],\n        config,\n        subjectsBounds\n      );\n    }\n\n    return new Placements(getListOfPlacements(), config, subjectsBounds);\n  }\n\n  private filterPlacementsBySide(side: SideType): Placement[] {\n    return this.placements.filter(placement => placement.primary === side);\n  }\n\n  private findFirstPlacementThatFits(): Placement | undefined {\n    return this.placements.find(placement => placement.fitsContainer);\n  }\n\n  private placementWithBiggestVisibleSurface(): Placement {\n    const [{ placement: placementWithBiggestSurface }] = this.placements\n      .map(placement => ({\n        placement,\n        surface: placement.visibleSurface\n      }))\n      // sort -> biggest surface first\n      .sort((a, b) => b.surface - a.surface);\n\n    return placementWithBiggestSurface;\n  }\n\n  private findSuitablePlacement(): Placement {\n    if (!this.config.auto) {\n      return this.placements[0];\n    }\n\n    return (\n      this.findFirstPlacementThatFits() ||\n      this.placementWithBiggestVisibleSurface()\n    );\n  }\n\n  /**\n   * secondary offset: the number of pixels between the edge of the\n   * scroll-container and the current placement, on the side of the layer\n   * that didn't fit.\n   * Eventually this secondary offset gets added / subtracted from the\n   * placement that does fit in order to move the layer closer to the\n   * position of the placement that just would not fit.\n   * This creates the effect that the layer is moving gradually from one\n   * placement to the next as the users scrolls the page or scroll-container\n   */\n  private getSecondaryOffset(placement: Placement): number {\n    const { auto, snap } = this.config;\n\n    // return early when we're not interested...\n    if (!auto || snap || placement instanceof PlacementCenter) {\n      return 0;\n    }\n\n    // if current placement fits and is prefered placement...\n    // return early\n    const placementsOnSameSide = this.filterPlacementsBySide(placement.primary);\n    const currentPlacementHasHighestPriority =\n      placementsOnSameSide.indexOf(placement) === 0;\n    if (currentPlacementHasHighestPriority && placement.fitsContainer) {\n      return 0;\n    }\n\n    const firstPlacementThatDoesNotFit = placementsOnSameSide.find(\n      placement => !placement.fitsContainer\n    );\n    if (!firstPlacementThatDoesNotFit) {\n      return 0;\n    }\n    const secondaryOffsetSide =\n      firstPlacementThatDoesNotFit.secondaryOffsetSide!;\n    if (!secondaryOffsetSide) {\n      return 0;\n    }\n\n    const containerOffsets = placement.getContainerOffsets();\n\n    // determine whether we should add or substract the secondary-offset\n    const { secondary } = placement;\n    let factor: number;\n    if (\n      placement.triggerIsBigger ||\n      firstPlacementThatDoesNotFit === placement\n    ) {\n      factor = secondaryOffsetSide.isPush ? -1 : 1;\n    } else {\n      factor =\n        secondary === Side.left ||\n        ([Side.top, Side.center].includes(secondary) &&\n          secondaryOffsetSide.isPush)\n          ? -1\n          : 1;\n    }\n\n    // get number of pixels between placement that did not fit and current\n    // placement\n    const secondaryOffset = containerOffsets[secondaryOffsetSide!.prop];\n\n    return secondaryOffset * factor;\n  }\n\n  private getStyles(\n    layerBounds: Bounds,\n    placement: Placement,\n    scrollOffsets: ScrollOffsets,\n    borderOffsets: BorderOffsets\n  ): Styles {\n    const layerStyleBase: CSSProperties = {\n      willChange: \"top, left, width, height\"\n    };\n\n    const arrow = getArrowStyle(\n      this.subjectsBounds.merge({ layer: layerBounds }),\n      placement,\n      this.config.arrowOffset\n    );\n\n    const layer: CSSProperties = this.config.overflowContainer\n      ? {\n          ...layerStyleBase,\n          position: \"fixed\",\n          top: layerBounds.top,\n          left: layerBounds.left\n        }\n      : {\n          ...layerStyleBase,\n          position: \"absolute\",\n          top:\n            layerBounds.top -\n            this.subjectsBounds.parent.top +\n            scrollOffsets.top -\n            borderOffsets.top,\n          left:\n            layerBounds.left -\n            this.subjectsBounds.parent.left +\n            scrollOffsets.left -\n            borderOffsets.left\n        };\n\n    return {\n      arrow,\n      layer\n    };\n  }\n\n  private getHasDisappeared(layerBounds: Bounds): DisappearType | null {\n    const subject = this.config.overflowContainer\n      ? this.subjectsBounds.trigger\n      : layerBounds;\n\n    const containerOffsets = BoundsOffsets.mergeSmallestSides(\n      this.subjectsBounds.offsetsToScrollContainers(subject, true)\n    );\n\n    const entries = Object.entries(\n      containerOffsets.negativeSides\n    ) as unknown as [BoundSideProp, number][];\n\n    const hasFullyDisappeared = entries.some(([prop, value]) => {\n      const side = BoundSide[prop];\n      return value <= -subject[side.sizeProp];\n    });\n\n    if (hasFullyDisappeared) {\n      return \"full\";\n    }\n\n    if (!containerOffsets.allSidesArePositive) {\n      return \"partial\";\n    }\n\n    return null;\n  }\n\n  public result(scrollOffsets: ScrollOffsets, borderOffsets: BorderOffsets) {\n    const suitablePlacement = this.findSuitablePlacement();\n    const secondaryOffset = this.getSecondaryOffset(suitablePlacement);\n    const layerBounds = suitablePlacement.getLayerBounds(secondaryOffset);\n    const styles = this.getStyles(\n      layerBounds,\n      suitablePlacement,\n      scrollOffsets,\n      borderOffsets\n    );\n    const layerSide = suitablePlacement.primary.prop as SideProp;\n\n    return {\n      styles,\n      layerSide,\n      placement: suitablePlacement,\n      layerBounds,\n      hasDisappeared: this.getHasDisappeared(layerBounds)\n    };\n  }\n}\n", "import { Bounds, IBounds, boundsToObject } from \"./Bounds\";\n\ninterface ISubjectsBounds {\n  trigger: IBounds;\n  layer: IBounds;\n  arrow: IBounds;\n  parent: IBounds;\n  window: IBounds;\n  scrollContainers: IBounds[];\n}\n\nexport class SubjectsBounds implements ISubjectsBounds {\n  public readonly trigger!: Bounds;\n  public readonly layer!: Bounds;\n  public readonly arrow!: Bounds;\n  public readonly parent!: Bounds;\n  public readonly window!: Bounds;\n  public readonly scrollContainers!: Bounds[];\n\n  private constructor(\n    subjectsBounds: ISubjectsBounds,\n    private readonly overflowContainer: boolean\n  ) {\n    Object.assign(this, subjectsBounds);\n  }\n\n  static create(\n    environment: Window,\n    layer: HTMLElement,\n    trigger: HTMLElement,\n    parent: HTMLElement | undefined,\n    arrow: HTMLElement | null,\n    scrollContainers: HTMLElement[],\n    overflowContainer: boolean,\n    getTriggerBounds?: () => IBounds\n  ) {\n    const window = Bounds.fromWindow(environment);\n\n    return new SubjectsBounds(\n      {\n        layer: Bounds.fromElement(layer, {\n          environment,\n          withTransform: false\n        }),\n        trigger: getTriggerBounds\n          ? Bounds.create(boundsToObject(getTriggerBounds()))\n          : Bounds.fromElement(trigger),\n        arrow: arrow ? Bounds.fromElement(arrow) : Bounds.empty(),\n        parent: parent ? Bounds.fromElement(parent) : window,\n        window,\n        scrollContainers: [\n          window,\n          ...scrollContainers.map(container =>\n            Bounds.fromElement(container, { withScrollbars: false })\n          )\n        ]\n      },\n      overflowContainer\n    );\n  }\n\n  merge(subjectsBounds: Partial<ISubjectsBounds>) {\n    return new SubjectsBounds(\n      {\n        ...this,\n        ...subjectsBounds\n      },\n      this.overflowContainer\n    );\n  }\n\n  get layerOffsetsToScrollContainers() {\n    return this.offsetsToScrollContainers(this.layer);\n  }\n\n  get triggerHasBiggerWidth() {\n    return this.trigger.width > this.layer.width;\n  }\n\n  get triggerHasBiggerHeight() {\n    return this.trigger.height > this.layer.height;\n  }\n\n  offsetsToScrollContainers(subject: Bounds, allContainers = false) {\n    const scrollContainers =\n      this.overflowContainer && !allContainers\n        ? [this.window]\n        : this.scrollContainers;\n\n    return scrollContainers.map(scrollContainer =>\n      scrollContainer.offsetsTo(subject)\n    );\n  }\n}\n", "import {\n  useCallback,\n  useState,\n  useRef,\n  createElement,\n  ReactNode,\n  ReactPortal,\n  MutableRefObject,\n  CSSProperties,\n  useEffect\n} from \"react\";\nimport { createPortal } from \"react-dom\";\nimport warning from \"tiny-warning\";\nimport {\n  Options,\n  LayerSide,\n  Styles,\n  ScrollOffsets,\n  BorderOffsets,\n  PositionConfig,\n  RefCallback,\n  Container\n} from \"./types\";\nimport { useTrackElements, OnChangeElements } from \"./useTrackElements\";\nimport { useGroup, GroupProvider } from \"./useGroup\";\nimport { PlacementType, PLACEMENT_TYPES } from \"./PlacementType\";\nimport { Placements } from \"./Placements\";\nimport { SubjectsBounds } from \"./SubjectsBounds\";\nimport { useLastState } from \"./hooks\";\nimport { isSet, mergeRefs } from \"./util\";\n\nlet GLOBAL_CONTAINER: HTMLElement | null = null;\n\nexport function setGlobalContainer(container: Container) {\n  if (typeof document === \"undefined\") {\n    return;\n  }\n\n  warning(\n    !(GLOBAL_CONTAINER instanceof HTMLElement),\n    `react-laag: You've called 'setGlobalContainer() previously'. It is recommended to only set the global container once, otherwise this may lead to unexpected behaviour.`\n  );\n\n  if (typeof container === \"function\") {\n    GLOBAL_CONTAINER = container();\n  } else if (typeof container === \"string\") {\n    GLOBAL_CONTAINER = document.getElementById(container);\n  } else {\n    GLOBAL_CONTAINER = container;\n  }\n\n  warning(\n    GLOBAL_CONTAINER instanceof HTMLElement,\n    `react-laag: You've called 'setGlobalContainer()', but it didn't result in a valid html-element`\n  );\n}\n\nexport type LayerProps = { ref: RefCallback; style: Styles[\"layer\"] };\nexport type TriggerProps = { ref: RefCallback };\nexport type UseLayerArrowProps = {\n  ref: MutableRefObject<any> | RefCallback;\n  layerSide: LayerSide;\n  style: Styles[\"arrow\"];\n};\n\nexport type UseLayerProps = {\n  renderLayer: (children: ReactNode) => ReactPortal | null;\n  triggerProps: TriggerProps;\n  layerProps: LayerProps;\n  arrowProps: UseLayerArrowProps;\n  layerSide: LayerSide;\n  triggerBounds: ClientRect | null;\n};\n\ntype State = {\n  layerSide: LayerSide;\n  styles: Styles;\n};\n\nexport const DEFAULT_OPTIONS: Required<\n  Omit<\n    Options,\n    | \"ResizeObserver\"\n    | \"environment\"\n    | \"onParentClose\"\n    | \"onOutsideClick\"\n    | \"onDisappear\"\n    | \"isOpen\"\n    | \"layerDimensions\"\n  >\n> = {\n  auto: false,\n  arrowOffset: 0,\n  containerOffset: 10,\n  triggerOffset: 0,\n  overflowContainer: true,\n  placement: \"top-center\",\n  possiblePlacements: PLACEMENT_TYPES as unknown as PlacementType[],\n  preferX: \"right\",\n  preferY: \"bottom\",\n  snap: false,\n  container: undefined!,\n  trigger: undefined!\n};\n\nexport function useLayer({\n  isOpen = false,\n  overflowContainer = DEFAULT_OPTIONS.overflowContainer,\n  environment = typeof window !== \"undefined\" ? window : undefined,\n  ResizeObserver: ResizeObserverPolyfill,\n  placement = DEFAULT_OPTIONS.placement,\n  possiblePlacements = DEFAULT_OPTIONS.possiblePlacements,\n  preferX = DEFAULT_OPTIONS.preferX,\n  preferY = DEFAULT_OPTIONS.preferY,\n  auto = DEFAULT_OPTIONS.auto,\n  snap = DEFAULT_OPTIONS.snap,\n  triggerOffset = DEFAULT_OPTIONS.triggerOffset,\n  containerOffset = DEFAULT_OPTIONS.containerOffset,\n  arrowOffset = DEFAULT_OPTIONS.arrowOffset,\n  container = DEFAULT_OPTIONS.container,\n  layerDimensions = null,\n  onDisappear,\n  onOutsideClick,\n  onParentClose,\n  trigger: triggerOption\n}: Options): UseLayerProps {\n  // initialize styles\n  const [state, setState] = useState<State>(() => ({\n    layerSide:\n      placement === \"center\"\n        ? \"center\"\n        : Placements.getSidesFromPlacementType(placement)[0].prop,\n    styles: {\n      layer: {\n        position: overflowContainer ? \"fixed\" : \"absolute\",\n        top: 0,\n        left: 0\n      },\n      arrow: {\n        position: \"absolute\",\n        top: 0,\n        left: 0\n      }\n    }\n  }));\n\n  const triggerBoundsRef = useRef<HTMLElement>(null!);\n\n  // tracks state in order for us to use read inside functions that require dependencies,\n  // like `useCallback`, without triggering an update\n  const lastState = useLastState(state, isOpen);\n\n  // track invalidations for scheduled position updates\n  const repositioningToken = useRef({ cancelled: false });\n  useEffect(() => {\n    return () => {\n      // when this hook unmounts, make sure to cancel any scheduled position updates\n      repositioningToken.current.cancelled = true;\n    };\n  }, []);\n\n  // Most important function regarding positioning\n  // It receives boundaries collected by `useTrackElements`, does some calculations,\n  // sets new styles, and handles when a layer has disappeared.\n  const handlePositioning = useCallback(\n    function handlePositioning(\n      { arrow, layer, scrollContainers, trigger }: OnChangeElements,\n      scrollOffsets: ScrollOffsets,\n      borderOffsets: BorderOffsets\n    ) {\n      const parent = scrollContainers[0];\n\n      const subjectsBounds = SubjectsBounds.create(\n        environment!,\n        layer,\n        trigger,\n        parent,\n        arrow,\n        scrollContainers,\n        overflowContainer,\n        triggerOption?.getBounds\n      );\n\n      const config: PositionConfig = {\n        placement,\n        possiblePlacements,\n        auto,\n        layerDimensions,\n        arrowOffset,\n        containerOffset,\n        triggerOffset,\n        preferX,\n        preferY,\n        snap,\n        overflowContainer\n      };\n\n      const { hasDisappeared, layerSide, styles } = Placements.create(\n        subjectsBounds,\n        config\n      ).result(scrollOffsets, borderOffsets);\n\n      const newState: State = {\n        layerSide,\n        styles\n      };\n\n      if (!lastState.current || didStateChange(lastState.current, newState)) {\n        lastState.current = newState; // optimistically update lastState to prevent infinite loop\n\n        /**\n         * Throttle state updates slightly by delaying them using an immediately\n         * resolved promise, only applying them if there is no later update.\n         * This helps for multiple updates that happens synchronously one after another.\n         */\n        repositioningToken.current.cancelled = true;\n        const token = { cancelled: false };\n        repositioningToken.current = token;\n\n        Promise.resolve().then(() => {\n          if (!token.cancelled) {\n            setState(newState);\n          }\n        });\n      }\n\n      if (isSet(hasDisappeared) && isSet(onDisappear)) {\n        onDisappear(hasDisappeared);\n      }\n    },\n    [\n      arrowOffset,\n      auto,\n      containerOffset,\n      environment,\n      layerDimensions,\n      onDisappear,\n      overflowContainer,\n      placement,\n      possiblePlacements,\n      preferX,\n      preferY,\n      snap,\n      triggerOffset,\n      lastState,\n      triggerOption\n    ]\n  );\n\n  const { triggerRef, layerRef, arrowRef, closestScrollContainer } =\n    useTrackElements({\n      ResizeObserverPolyfill,\n      environment,\n      enabled: isOpen,\n      overflowContainer,\n      onChange: handlePositioning,\n      triggerOption\n    });\n\n  const { closeOnOutsideClickRefs, registrations } = useGroup({\n    isOpen,\n    onOutsideClick,\n    onParentClose\n  });\n\n  const props: UseLayerProps = {\n    triggerProps: Boolean(triggerOption)\n      ? ({} as any) // when using the `trigger` option, make `triggerProps` useless\n      : {\n          ref: mergeRefs(\n            triggerRef,\n            closeOnOutsideClickRefs.trigger,\n            triggerBoundsRef\n          )\n        },\n    layerProps: {\n      ref: mergeRefs(layerRef, closeOnOutsideClickRefs.layer),\n      style: state.styles.layer\n    },\n    arrowProps: {\n      ref: arrowRef,\n      style: state.styles.arrow,\n      layerSide: state.layerSide\n    },\n    layerSide: state.layerSide,\n    triggerBounds: isOpen\n      ? triggerOption\n        ? triggerOption.getBounds()\n        : triggerBoundsRef.current?.getBoundingClientRect()\n      : null,\n    renderLayer: children =>\n      typeof document !== \"undefined\"\n        ? createPortal(\n            createElement(GroupProvider, { registrations, children }),\n            overflowContainer || !closestScrollContainer\n              ? getContainerElement(container)\n              : closestScrollContainer\n          )\n        : null\n  };\n\n  return props;\n}\n\nfunction didStateChange(previous: State, next: State): boolean {\n  if (previous.layerSide !== next.layerSide) {\n    return true;\n  }\n\n  const styleProps: Array<keyof CSSProperties> = [\n    \"position\",\n    \"top\",\n    \"left\",\n    \"right\",\n    \"bottom\"\n  ];\n  for (const prop of styleProps) {\n    if (\n      previous.styles.layer[prop] !== next.styles.layer[prop] ||\n      previous.styles.arrow[prop] !== next.styles.arrow[prop]\n    ) {\n      return true;\n    }\n  }\n\n  return false;\n}\n\nconst DEFAULT_CONTAINER_ID = \"layers\";\n\nfunction getContainerElement(container?: Container): HTMLElement {\n  let element: HTMLElement;\n\n  if (typeof container === \"function\") {\n    element = container();\n    if (!element || !(element instanceof HTMLElement)) {\n      throw new Error(\n        `react-laag: You've passed a function to the 'container' prop, but it returned no valid HTMLElement`\n      );\n    }\n  } else if (container instanceof HTMLElement) {\n    element = container;\n  } else if (typeof container === \"string\") {\n    element = document.getElementById(container)!;\n    if (!element) {\n      throw new Error(\n        `react-laag: You've passed element with id '${container}' to the 'container' prop, but it returned no valid HTMLElement`\n      );\n    }\n  } else if (GLOBAL_CONTAINER instanceof HTMLElement) {\n    return GLOBAL_CONTAINER;\n  } else {\n    element = document.getElementById(DEFAULT_CONTAINER_ID)!;\n    if (!element) {\n      element = document.createElement(\"div\");\n      element.id = DEFAULT_CONTAINER_ID;\n      element.style.cssText = `\n        position: absolute;\n        top: 0px;\n        left: 0px;\n        right: 0px;\n      `;\n      document.body.appendChild(element);\n    }\n  }\n\n  return element;\n}\n", "import { createElement, forwardRef } from \"react\";\nimport { BoundSide, BoundSideType } from \"./Sides\";\nimport { LayerSide } from \"./types\";\n\nconst LEFT = \"left\";\nconst TOP = \"top\";\nconst BOTTOM = \"bottom\";\nconst RIGHT = \"right\";\n\nfunction getWidthBasedOnAngle(angle: number, size: number) {\n  return Math.tan(angle * (Math.PI / 180)) * size;\n}\n\nfunction getViewBox(\n  sizeA: number,\n  sizeB: number,\n  side: BoundSideType,\n  borderWidth: number\n) {\n  const map = {\n    [BOTTOM]: `0 ${-borderWidth} ${sizeB} ${sizeA}`,\n    [TOP]: `0 0 ${sizeB} ${sizeA + borderWidth}`,\n    [RIGHT]: `${-borderWidth} 0 ${sizeA} ${sizeB}`,\n    [LEFT]: `0 0 ${sizeA + borderWidth} ${sizeB}`\n  };\n\n  return map[side.prop];\n}\n\nfunction getTrianglePath(\n  sizeA: number,\n  sizeB: number,\n  side: BoundSideType,\n  roundness: number,\n  angle: number\n) {\n  const relativeRoundness = (roundness / 10) * sizeA * 2;\n\n  const A = {\n    [BOTTOM]: [0, sizeA],\n    [TOP]: [0, 0],\n    [RIGHT]: [sizeA, sizeB],\n    [LEFT]: [0, sizeB]\n  }[side.prop].join(\" \");\n\n  const B = side.isHorizontal ? `V 0` : `H ${sizeB}`;\n\n  const cPoint = sizeB / 2;\n  const c1A = sizeB / 2 + getWidthBasedOnAngle(angle, sizeA / 8);\n  const c1B = sizeA / 8;\n\n  const C = {\n    [BOTTOM]: [\"C\", c1A, c1B, cPoint + relativeRoundness, 0, cPoint, 0],\n    [TOP]: [\n      \"C\",\n      c1A,\n      sizeA - c1B,\n      cPoint + relativeRoundness,\n      sizeA,\n      cPoint,\n      sizeA\n    ],\n    [RIGHT]: [\"C\", c1B, sizeB - c1A, 0, cPoint - relativeRoundness, 0, cPoint],\n    [LEFT]: [\n      \"C\",\n      sizeA - c1B,\n      sizeB - c1A,\n      sizeA,\n      cPoint - relativeRoundness,\n      sizeA,\n      cPoint\n    ]\n  }[side.prop].join(\" \");\n\n  const d1A = sizeB / 2 - getWidthBasedOnAngle(angle, sizeA / 8);\n  const d1B = sizeA / 8;\n\n  const D = {\n    [BOTTOM]: [\"C\", cPoint - relativeRoundness, 0, d1A, d1B, A],\n    [TOP]: [\"C\", cPoint - relativeRoundness, sizeA, d1A, sizeA - d1B, A],\n    [RIGHT]: [\"C\", 0, cPoint + relativeRoundness, d1B, sizeB - d1A, A],\n    [LEFT]: [\n      \"C\",\n      sizeA,\n      cPoint + relativeRoundness,\n      sizeA - d1B,\n      sizeB - d1A,\n      A\n    ]\n  }[side.prop].join(\" \");\n\n  return [\"M\", A, B, C, D].join(\" \");\n}\n\nfunction getBorderMaskPath(\n  sizeA: number,\n  sizeB: number,\n  borderWidth: number,\n  side: BoundSideType,\n  angle: number\n) {\n  const borderOffset = getWidthBasedOnAngle(angle, borderWidth);\n\n  const [A, B] = !side.isPush ? [sizeA, sizeA - borderWidth] : [0, borderWidth];\n\n  if (side.isHorizontal) {\n    return [\n      \"M\",\n      A,\n      borderWidth,\n      \"V\",\n      sizeB - borderWidth,\n      \"L\",\n      B,\n      sizeB - borderWidth - borderOffset,\n      \"V\",\n      borderOffset + borderWidth,\n      \"Z\"\n    ].join(\" \");\n  }\n\n  return [\n    \"M\",\n    borderWidth,\n    A,\n    \"H\",\n    sizeB - borderWidth,\n    \"L\",\n    sizeB - borderWidth - borderOffset,\n    B,\n    \"H\",\n    borderOffset + borderWidth,\n    \"Z\"\n  ].join(\" \");\n}\n\nexport type ArrowProps = React.ComponentPropsWithoutRef<\"svg\"> & {\n  /**\n   * angle of triangle\n   * default is `45`\n   */\n  angle?: number;\n  /**\n   * distance in pixels between point of triangle and layer\n   * default is `8`\n   */\n  size?: number;\n  /**\n   * roundness of the point of the arrow\n   * range: 0 - 1\n   * default is `0`\n   */\n  roundness?: number;\n  /**\n   * width of the layers border\n   * default is `0`\n   */\n  borderWidth?: number;\n  /**\n   * color of the layers border\n   * default is `\"black\"`\n   */\n  borderColor?: string;\n  /**\n   * background-color of the layer\n   * default is `\"white\"`\n   */\n  backgroundColor?: string;\n  /**\n   * Given by `useLayer()` and determines the direction the arrow should\n   * be pointing to\n   */\n  layerSide?: LayerSide;\n};\n\nexport const Arrow = forwardRef<SVGSVGElement, ArrowProps>(function Arrow(\n  {\n    size = 8,\n    angle = 45,\n    borderWidth = 0,\n    borderColor = \"black\",\n    roundness = 0,\n    backgroundColor = \"white\",\n    layerSide = \"top\",\n    style = {},\n    ...rest\n  },\n  ref\n) {\n  if (layerSide === \"center\") {\n    return null;\n  }\n\n  const side = BoundSide[layerSide];\n  const sizeA = size;\n  const sizeB = getWidthBasedOnAngle(angle, size) * 2;\n\n  const maxSize = Math.max(sizeA, sizeB);\n\n  return createElement(\n    \"svg\",\n    {\n      ref,\n      ...rest,\n      style: {\n        ...style,\n        transform: `translate${side.isHorizontal ? \"Y\" : \"X\"}(-50%)`\n      },\n      width: maxSize,\n      height: maxSize,\n      preserveAspectRatio: side.isPush ? \"xMinYMin\" : \"xMaxYMax\",\n      viewBox: getViewBox(sizeA, sizeB, side, borderWidth)\n    },\n    createElement(\"path\", {\n      fill: backgroundColor,\n      strokeWidth: borderWidth,\n      stroke: borderColor,\n      d: getTrianglePath(sizeA, sizeB, side, roundness, angle)\n    }),\n    createElement(\"path\", {\n      fill: backgroundColor,\n      d: getBorderMaskPath(sizeA, sizeB, borderWidth, side, angle)\n    })\n  );\n});\n", "import { useState, useRef, useCallback, useEffect, MouseEvent } from \"react\";\n\nexport type UseHoverOptions = {\n  /**\n   * Amount of milliseconds to wait while hovering before opening.\n   * Default is `0`\n   */\n  delayEnter?: number;\n  /**\n   * Amount of milliseconds to wait when mouse has left the trigger before closing.\n   * Default is `0`\n   */\n  delayLeave?: number;\n  /**\n   * Determines whether the layer should hide when the user starts scrolling.\n   * Default is `true`\n   */\n  hideOnScroll?: boolean;\n};\n\nexport type PlainCallback = (...args: any[]) => void;\n\nexport type UseHoverProps = {\n  onMouseEnter: PlainCallback;\n  onMouseLeave: PlainCallback;\n  onTouchStart: PlainCallback;\n  onTouchMove: PlainCallback;\n  onTouchEnd: PlainCallback;\n};\n\nenum Status {\n  ENTERING,\n  LEAVING,\n  IDLE\n}\n\nexport function useHover({\n  delayEnter = 0,\n  delayLeave = 0,\n  hideOnScroll = true\n}: UseHoverOptions = {}): readonly [boolean, UseHoverProps, () => void] {\n  const [show, setShow] = useState(false);\n\n  const timeout = useRef<number | null>(null);\n\n  const status = useRef<Status>(Status.IDLE);\n\n  const hasTouchMoved = useRef<boolean>(false);\n\n  const removeTimeout = useCallback(function removeTimeout() {\n    clearTimeout(timeout.current!);\n    timeout.current = null;\n    status.current = Status.IDLE;\n  }, []);\n\n  function onMouseEnter() {\n    // if was leaving, stop leaving\n    if (status.current === Status.LEAVING && timeout.current) {\n      removeTimeout();\n    }\n\n    if (show) {\n      return;\n    }\n\n    status.current = Status.ENTERING;\n    timeout.current = window.setTimeout(() => {\n      setShow(true);\n      timeout.current = null;\n      status.current = Status.IDLE;\n    }, delayEnter);\n  }\n\n  function onMouseLeave(_: MouseEvent<any>, immediate?: boolean) {\n    // if was waiting for entering,\n    // clear timeout\n    if (status.current === Status.ENTERING && timeout.current) {\n      removeTimeout();\n    }\n\n    if (!show) {\n      return;\n    }\n\n    if (immediate) {\n      setShow(false);\n      timeout.current = null;\n      status.current = Status.IDLE;\n      return;\n    }\n\n    status.current = Status.LEAVING;\n    timeout.current = window.setTimeout(() => {\n      setShow(false);\n      timeout.current = null;\n      status.current = Status.IDLE;\n    }, delayLeave);\n  }\n\n  // make sure to clear timeout on unmount\n  useEffect(() => {\n    function onScroll() {\n      if (show && hideOnScroll) {\n        removeTimeout();\n        setShow(false);\n      }\n    }\n\n    window.addEventListener(\"scroll\", onScroll, true);\n\n    return () => {\n      window.removeEventListener(\"scroll\", onScroll, true);\n\n      if (timeout.current) {\n        clearTimeout(timeout.current);\n      }\n    };\n  }, [show, hideOnScroll, removeTimeout]);\n\n  const hoverProps: UseHoverProps = {\n    onMouseEnter,\n    onMouseLeave,\n    onTouchStart: () => {\n      hasTouchMoved.current = false;\n    },\n    onTouchMove: () => {\n      hasTouchMoved.current = true;\n    },\n    onTouchEnd: () => {\n      if (!hasTouchMoved.current && !show) {\n        setShow(true);\n      }\n\n      hasTouchMoved.current = false;\n    }\n  };\n\n  return [show, hoverProps, () => onMouseLeave(null!, true)] as const;\n}\n", "import { useState, useRef, useEffect } from \"react\";\nimport warning from \"tiny-warning\";\n\nexport type TransitionProps = {\n  isOpen: boolean;\n  children: (\n    isOpen: boolean,\n    onTransitionEnd: any,\n    isLeaving: boolean\n  ) => React.ReactElement;\n};\n\n/**\n * @deprecated\n * Note: this component is marked as deprecated and will be removed and a possible\n * future release\n */\nexport function Transition({\n  isOpen: isOpenExternal,\n  children\n}: TransitionProps) {\n  const [state, setState] = useState({\n    isOpenInternal: isOpenExternal,\n    isLeaving: false\n  });\n\n  const didMount = useRef(false);\n\n  useEffect(() => {\n    if (isOpenExternal) {\n      setState({\n        isOpenInternal: true,\n        isLeaving: false\n      });\n    } else if (didMount.current) {\n      setState({\n        isOpenInternal: false,\n        isLeaving: true\n      });\n    }\n  }, [isOpenExternal, setState]);\n\n  useEffect(() => {\n    warning(\n      children,\n      `react-laag: You are using 'Transition'. Note that this component is marked as deprecated and will be removed at future releases`\n    );\n  }, [children]);\n\n  useEffect(() => {\n    didMount.current = true;\n  }, []);\n\n  if (!isOpenExternal && !state.isOpenInternal && !state.isLeaving) {\n    return null;\n  }\n\n  return children(\n    state.isOpenInternal,\n    () => {\n      if (!state.isOpenInternal) {\n        setState(s => ({ ...s, isLeaving: false }));\n      }\n    },\n    state.isLeaving\n  );\n}\n"],
  "mappings": "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",
  "names": ["useTrackRef", "onRefChange", "storedReference", "useRef", "setter", "element", "current", "useMutableStore", "initialState", "state", "useMemo", "set", "get", "useEventSubscriptions", "subscriptions", "hasEventSubscriptions", "length", "removeAllEventSubscriptions", "unsubscribe", "addEventSubscription", "unsubscriber", "push", "useIsomorphicLayoutEffect", "window", "useLayoutEffect", "useEffect", "useLastState", "currentState", "enabled", "lastState", "EMPTY_BOUNDS", "top", "left", "right", "bottom", "width", "height", "useMousePositionAsTrigger", "preventDefault", "parentRef", "useState", "mouseBounds", "setMouseBounds", "resetMousePosition", "hasMousePosition", "handleMouseEvent", "evt", "clientX", "clientY", "trigger", "getBounds", "getParent", "undefined", "getPixelValue", "value", "parseFloat", "replace", "limit", "min", "max", "isSet", "mergeRefs", "refs", "ref", "getResizeObserver", "environment", "polyfill", "ResizeObserver", "findScrollContainers", "result", "document", "body", "getComputedStyle", "overflow", "overflowX", "overflowY", "some", "prop", "includes", "parentElement", "createReferenceError", "subject", "useTrackElements", "onChange", "ResizeObserverPolyfill", "overflowContainer", "triggerOption", "warning", "arrowRef", "hasTriggerOption", "Boolean", "scrollContainers", "layer", "handleChange", "useCallback", "closestScrollContainer", "Error", "scrollOffsets", "scrollLeft", "scrollTop", "scrollX", "scrollY", "borderOffsets", "borderLeftWidth", "borderTopWidth", "arrow", "addEventListeners", "ignoredInitialCall", "observerCallback", "observer", "observe", "unobserve", "disconnect", "listenForScrollElements", "addEventListener", "removeEventListener", "resetWhenReferenceChangedWhileTracking", "previous", "next", "layerRef", "previousLayer", "getScrollContainers", "handleScrollContainers", "position", "closestScrollContainerHasCorrectStyling", "style", "triggerRef", "previousTrigger", "triggerOptionParent", "GroupContext", "createContext", "GroupProvider", "children", "registrations", "handleRegister", "register", "registration", "add", "delete", "createElement", "Provider", "getShouldCloseAccordingToChildren", "event", "shouldCloseWhenClickedOutside", "useGroup", "isOpen", "onOutsideClick", "onParentClose", "Set", "possibleRegisterFn", "useContext", "target", "clickedOnTrigger", "contains", "clickedOnLayer", "shouldCloseAccordingToChildren", "forEach", "closeChild", "isChild", "shouldNotListen", "handleClick", "closeOnOutsideClickRefs", "PLACEMENT_TYPES", "OPPOSITES", "center", "SideBase", "opposite", "isHorizontal", "sizeProp", "oppositeSizeProp", "cssProp", "oppositeCssProp", "isCenter", "isPush", "factor", "isOppositeDirection", "side", "createSide", "recursive", "BoundSide", "Side", "SIDES", "BoundsOffsets", "offsets", "Object", "assign", "mergeSmallestSides", "boundsOffsets", "first", "rest", "fromEntries", "map", "boundsOffset", "Math", "every", "filter", "sumOfPropertyValues", "propertyValues", "reduce", "sum", "propertyValue", "boundsToObject", "EMPTY", "Bounds", "create", "bounds", "fromElement", "options", "withTransform", "withScrollbars", "plain", "getBoundingClientRect", "boxSizing", "borderLeft", "borderRight", "borderTop", "borderBottom", "paddingLeft", "paddingRight", "paddingTop", "paddingBottom", "boxWidth", "boxHeight", "scrollbarWidth", "clientWidth", "scrollbarHeight", "clientHeight", "substract", "empty", "fromWindow", "scrollingElement", "documentElement", "toObject", "merge", "partialBoundsOrMergeFn", "entries", "boundSide", "offsetsTo", "child", "mapSides", "mapper", "boundSides", "values", "Placement", "primary", "secondary", "subjectBounds", "layerDimensions", "subjectsBounds", "_cachedLayerBounds", "_cachedContainerOffsets", "setSubjectsBounds", "dimensions", "getLayerBounds", "secondaryOffset", "arrowOffsetBase", "limitMin", "limitMax", "propertyA", "propertyB", "sec", "triggerValue", "arrowCompensation", "layerBounds", "getLayerCollisionBounds", "container", "getContainerOffsets", "layerOffsetsToScrollContainers", "triggerHasBiggerWidth", "triggerHasBiggerHeight", "allSidesArePositive", "containerOffsets", "negativeSides", "surface", "sort", "a", "b", "mostNegativeSide", "PlacementCenter", "getNegativeOffsetBetweenLayerCenterAndTrigger", "placement", "arrowOffset", "sizeProperty", "sideA", "sideB", "offsetA", "offsetB", "STYLE_BASE", "willChange", "getArrowStyle", "triggerIsBigger", "negativeOffset", "primarySide", "secondarySide", "secondaryValue", "Placements", "placements", "config", "getSidesFromPlacementType", "type", "split", "containerOffset", "triggerOffset", "getListOfPlacements", "preferedPlacement", "preferredSide", "preferY", "preferX", "placementFrom", "list", "possiblePlacements", "filterPlacementsBySide", "findFirstPlacementThatFits", "find", "fitsContainer", "placementWithBiggestVisibleSurface", "visibleSurface", "placementWithBiggestSurface", "findSuitablePlacement", "auto", "getSecondaryOffset", "snap", "placementsOnSameSide", "currentPlacementHasHighestPriority", "indexOf", "firstPlacementThatDoesNotFit", "secondaryOffsetSide", "getStyles", "layerStyleBase", "parent", "getHasDisappeared", "offsetsToScrollContainers", "hasFullyDisappeared", "suitablePlacement", "styles", "layerSide", "hasDisappeared", "SubjectsBounds", "getTriggerBounds", "allContainers", "scrollContainer", "GLOBAL_CONTAINER", "setGlobalContainer", "HTMLElement", "getElementById", "DEFAULT_OPTIONS", "useLayer", "onDisappear", "setState", "triggerBoundsRef", "repositioningToken", "cancelled", "handlePositioning", "newState", "didStateChange", "token", "Promise", "resolve", "then", "props", "triggerProps", "layerProps", "arrowProps", "triggerBounds", "renderLayer", "createPortal", "getContainerElement", "styleProps", "DEFAULT_CONTAINER_ID", "id", "cssText", "appendChild", "LEFT", "TOP", "BOTTOM", "RIGHT", "getWidthBasedOnAngle", "angle", "size", "tan", "PI", "getViewBox", "sizeA", "sizeB", "borderWidth", "getTrianglePath", "roundness", "relativeRoundness", "A", "join", "B", "cPoint", "c1A", "c1B", "C", "d1A", "d1B", "D", "getBorderMaskPath", "borderOffset", "Arrow", "forwardRef", "borderColor", "backgroundColor", "maxSize", "transform", "preserveAspectRatio", "viewBox", "fill", "strokeWidth", "stroke", "d", "Status", "useHover", "delayEnter", "delayLeave", "hideOnScroll", "show", "setShow", "timeout", "status", "IDLE", "hasTouchMoved", "removeTimeout", "clearTimeout", "onMouseEnter", "LEAVING", "ENTERING", "setTimeout", "onMouseLeave", "_", "immediate", "onScroll", "hoverProps", "onTouchStart", "onTouchMove", "onTouchEnd", "Transition", "isOpenExternal", "isOpenInternal", "isLeaving", "didMount", "s"]
}
