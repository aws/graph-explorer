import {
  require_react
} from "./chunk-57SFASAQ.js";
import {
  __commonJS,
  __toESM
} from "./chunk-S5KM4IGW.js";

// ../../node_modules/.pnpm/exenv@1.2.2/node_modules/exenv/index.js
var require_exenv = __commonJS({
  "../../node_modules/.pnpm/exenv@1.2.2/node_modules/exenv/index.js"(exports, module) {
    (function() {
      "use strict";
      var canUseDOM2 = !!(typeof window !== "undefined" && window.document && window.document.createElement);
      var ExecutionEnvironment = {
        canUseDOM: canUseDOM2,
        canUseWorkers: typeof Worker !== "undefined",
        canUseEventListeners: canUseDOM2 && !!(window.addEventListener || window.attachEvent),
        canUseViewport: canUseDOM2 && !!window.screen
      };
      if (typeof define === "function" && typeof define.amd === "object" && define.amd) {
        define(function() {
          return ExecutionEnvironment;
        });
      } else if (typeof module !== "undefined" && module.exports) {
        module.exports = ExecutionEnvironment;
      } else {
        window.ExecutionEnvironment = ExecutionEnvironment;
      }
    })();
  }
});

// ../../node_modules/.pnpm/react-inlinesvg@2.3.0_react@17.0.2/node_modules/react-inlinesvg/esm/index.js
var React2 = __toESM(require_react());

// ../../node_modules/.pnpm/react-from-dom@0.6.2_react@17.0.2/node_modules/react-from-dom/esm/index.js
var React = __toESM(require_react());

// ../../node_modules/.pnpm/react-from-dom@0.6.2_react@17.0.2/node_modules/react-from-dom/esm/helpers.js
var __read = function(o, n) {
  var m = typeof Symbol === "function" && o[Symbol.iterator];
  if (!m)
    return o;
  var i = m.call(o), r, ar = [], e;
  try {
    while ((n === void 0 || n-- > 0) && !(r = i.next()).done)
      ar.push(r.value);
  } catch (error) {
    e = { error };
  } finally {
    try {
      if (r && !r.done && (m = i["return"]))
        m.call(i);
    } finally {
      if (e)
        throw e.error;
    }
  }
  return ar;
};
var styleToObject = function(input) {
  var attributes = input.split(/ ?; ?/);
  return attributes.reduce(function(acc, d) {
    var _a = __read(d.split(/ ?: ?/), 2), key = _a[0], value = _a[1];
    if (key && value) {
      acc[key.replace(/-(\w)/g, function(_$0, $1) {
        return $1.toUpperCase();
      })] = Number.isNaN(Number(value)) ? value : Number(value);
    }
    return acc;
  }, {});
};
function randomString(length) {
  if (length === void 0) {
    length = 6;
  }
  var characters = "0123456789abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ";
  var result = "";
  for (var index = length; index > 0; --index) {
    result += characters[Math.round(Math.random() * (characters.length - 1))];
  }
  return result;
}
var noTextChildNodes = [
  "br",
  "col",
  "colgroup",
  "dl",
  "hr",
  "iframe",
  "img",
  "input",
  "link",
  "menuitem",
  "meta",
  "ol",
  "param",
  "select",
  "table",
  "tbody",
  "tfoot",
  "thead",
  "tr",
  "ul",
  "wbr"
];
var possibleStandardNames = {
  "accept-charset": "acceptCharset",
  acceptcharset: "acceptCharset",
  accesskey: "accessKey",
  allowfullscreen: "allowFullScreen",
  autocapitalize: "autoCapitalize",
  autocomplete: "autoComplete",
  autocorrect: "autoCorrect",
  autofocus: "autoFocus",
  autoplay: "autoPlay",
  autosave: "autoSave",
  cellpadding: "cellPadding",
  cellspacing: "cellSpacing",
  charset: "charSet",
  class: "className",
  classid: "classID",
  classname: "className",
  colspan: "colSpan",
  contenteditable: "contentEditable",
  contextmenu: "contextMenu",
  controlslist: "controlsList",
  crossorigin: "crossOrigin",
  dangerouslysetinnerhtml: "dangerouslySetInnerHTML",
  datetime: "dateTime",
  defaultchecked: "defaultChecked",
  defaultvalue: "defaultValue",
  enctype: "encType",
  for: "htmlFor",
  formmethod: "formMethod",
  formaction: "formAction",
  formenctype: "formEncType",
  formnovalidate: "formNoValidate",
  formtarget: "formTarget",
  frameborder: "frameBorder",
  hreflang: "hrefLang",
  htmlfor: "htmlFor",
  httpequiv: "httpEquiv",
  "http-equiv": "httpEquiv",
  icon: "icon",
  innerhtml: "innerHTML",
  inputmode: "inputMode",
  itemid: "itemID",
  itemprop: "itemProp",
  itemref: "itemRef",
  itemscope: "itemScope",
  itemtype: "itemType",
  keyparams: "keyParams",
  keytype: "keyType",
  marginwidth: "marginWidth",
  marginheight: "marginHeight",
  maxlength: "maxLength",
  mediagroup: "mediaGroup",
  minlength: "minLength",
  nomodule: "noModule",
  novalidate: "noValidate",
  playsinline: "playsInline",
  radiogroup: "radioGroup",
  readonly: "readOnly",
  referrerpolicy: "referrerPolicy",
  rowspan: "rowSpan",
  spellcheck: "spellCheck",
  srcdoc: "srcDoc",
  srclang: "srcLang",
  srcset: "srcSet",
  tabindex: "tabIndex",
  typemustmatch: "typeMustMatch",
  usemap: "useMap",
  accentheight: "accentHeight",
  "accent-height": "accentHeight",
  alignmentbaseline: "alignmentBaseline",
  "alignment-baseline": "alignmentBaseline",
  allowreorder: "allowReorder",
  arabicform: "arabicForm",
  "arabic-form": "arabicForm",
  attributename: "attributeName",
  attributetype: "attributeType",
  autoreverse: "autoReverse",
  basefrequency: "baseFrequency",
  baselineshift: "baselineShift",
  "baseline-shift": "baselineShift",
  baseprofile: "baseProfile",
  calcmode: "calcMode",
  capheight: "capHeight",
  "cap-height": "capHeight",
  clippath: "clipPath",
  "clip-path": "clipPath",
  clippathunits: "clipPathUnits",
  cliprule: "clipRule",
  "clip-rule": "clipRule",
  colorinterpolation: "colorInterpolation",
  "color-interpolation": "colorInterpolation",
  colorinterpolationfilters: "colorInterpolationFilters",
  "color-interpolation-filters": "colorInterpolationFilters",
  colorprofile: "colorProfile",
  "color-profile": "colorProfile",
  colorrendering: "colorRendering",
  "color-rendering": "colorRendering",
  contentscripttype: "contentScriptType",
  contentstyletype: "contentStyleType",
  diffuseconstant: "diffuseConstant",
  dominantbaseline: "dominantBaseline",
  "dominant-baseline": "dominantBaseline",
  edgemode: "edgeMode",
  enablebackground: "enableBackground",
  "enable-background": "enableBackground",
  externalresourcesrequired: "externalResourcesRequired",
  fillopacity: "fillOpacity",
  "fill-opacity": "fillOpacity",
  fillrule: "fillRule",
  "fill-rule": "fillRule",
  filterres: "filterRes",
  filterunits: "filterUnits",
  floodopacity: "floodOpacity",
  "flood-opacity": "floodOpacity",
  floodcolor: "floodColor",
  "flood-color": "floodColor",
  fontfamily: "fontFamily",
  "font-family": "fontFamily",
  fontsize: "fontSize",
  "font-size": "fontSize",
  fontsizeadjust: "fontSizeAdjust",
  "font-size-adjust": "fontSizeAdjust",
  fontstretch: "fontStretch",
  "font-stretch": "fontStretch",
  fontstyle: "fontStyle",
  "font-style": "fontStyle",
  fontvariant: "fontVariant",
  "font-variant": "fontVariant",
  fontweight: "fontWeight",
  "font-weight": "fontWeight",
  glyphname: "glyphName",
  "glyph-name": "glyphName",
  glyphorientationhorizontal: "glyphOrientationHorizontal",
  "glyph-orientation-horizontal": "glyphOrientationHorizontal",
  glyphorientationvertical: "glyphOrientationVertical",
  "glyph-orientation-vertical": "glyphOrientationVertical",
  glyphref: "glyphRef",
  gradienttransform: "gradientTransform",
  gradientunits: "gradientUnits",
  horizadvx: "horizAdvX",
  "horiz-adv-x": "horizAdvX",
  horizoriginx: "horizOriginX",
  "horiz-origin-x": "horizOriginX",
  imagerendering: "imageRendering",
  "image-rendering": "imageRendering",
  kernelmatrix: "kernelMatrix",
  kernelunitlength: "kernelUnitLength",
  keypoints: "keyPoints",
  keysplines: "keySplines",
  keytimes: "keyTimes",
  lengthadjust: "lengthAdjust",
  letterspacing: "letterSpacing",
  "letter-spacing": "letterSpacing",
  lightingcolor: "lightingColor",
  "lighting-color": "lightingColor",
  limitingconeangle: "limitingConeAngle",
  markerend: "markerEnd",
  "marker-end": "markerEnd",
  markerheight: "markerHeight",
  markermid: "markerMid",
  "marker-mid": "markerMid",
  markerstart: "markerStart",
  "marker-start": "markerStart",
  markerunits: "markerUnits",
  markerwidth: "markerWidth",
  maskcontentunits: "maskContentUnits",
  maskunits: "maskUnits",
  numoctaves: "numOctaves",
  overlineposition: "overlinePosition",
  "overline-position": "overlinePosition",
  overlinethickness: "overlineThickness",
  "overline-thickness": "overlineThickness",
  paintorder: "paintOrder",
  "paint-order": "paintOrder",
  "panose-1": "panose1",
  pathlength: "pathLength",
  patterncontentunits: "patternContentUnits",
  patterntransform: "patternTransform",
  patternunits: "patternUnits",
  pointerevents: "pointerEvents",
  "pointer-events": "pointerEvents",
  pointsatx: "pointsAtX",
  pointsaty: "pointsAtY",
  pointsatz: "pointsAtZ",
  preservealpha: "preserveAlpha",
  preserveaspectratio: "preserveAspectRatio",
  primitiveunits: "primitiveUnits",
  refx: "refX",
  refy: "refY",
  renderingintent: "renderingIntent",
  "rendering-intent": "renderingIntent",
  repeatcount: "repeatCount",
  repeatdur: "repeatDur",
  requiredextensions: "requiredExtensions",
  requiredfeatures: "requiredFeatures",
  shaperendering: "shapeRendering",
  "shape-rendering": "shapeRendering",
  specularconstant: "specularConstant",
  specularexponent: "specularExponent",
  spreadmethod: "spreadMethod",
  startoffset: "startOffset",
  stddeviation: "stdDeviation",
  stitchtiles: "stitchTiles",
  stopcolor: "stopColor",
  "stop-color": "stopColor",
  stopopacity: "stopOpacity",
  "stop-opacity": "stopOpacity",
  strikethroughposition: "strikethroughPosition",
  "strikethrough-position": "strikethroughPosition",
  strikethroughthickness: "strikethroughThickness",
  "strikethrough-thickness": "strikethroughThickness",
  strokedasharray: "strokeDasharray",
  "stroke-dasharray": "strokeDasharray",
  strokedashoffset: "strokeDashoffset",
  "stroke-dashoffset": "strokeDashoffset",
  strokelinecap: "strokeLinecap",
  "stroke-linecap": "strokeLinecap",
  strokelinejoin: "strokeLinejoin",
  "stroke-linejoin": "strokeLinejoin",
  strokemiterlimit: "strokeMiterlimit",
  "stroke-miterlimit": "strokeMiterlimit",
  strokewidth: "strokeWidth",
  "stroke-width": "strokeWidth",
  strokeopacity: "strokeOpacity",
  "stroke-opacity": "strokeOpacity",
  suppresscontenteditablewarning: "suppressContentEditableWarning",
  suppresshydrationwarning: "suppressHydrationWarning",
  surfacescale: "surfaceScale",
  systemlanguage: "systemLanguage",
  tablevalues: "tableValues",
  targetx: "targetX",
  targety: "targetY",
  textanchor: "textAnchor",
  "text-anchor": "textAnchor",
  textdecoration: "textDecoration",
  "text-decoration": "textDecoration",
  textlength: "textLength",
  textrendering: "textRendering",
  "text-rendering": "textRendering",
  underlineposition: "underlinePosition",
  "underline-position": "underlinePosition",
  underlinethickness: "underlineThickness",
  "underline-thickness": "underlineThickness",
  unicodebidi: "unicodeBidi",
  "unicode-bidi": "unicodeBidi",
  unicoderange: "unicodeRange",
  "unicode-range": "unicodeRange",
  unitsperem: "unitsPerEm",
  "units-per-em": "unitsPerEm",
  unselectable: "unselectable",
  valphabetic: "vAlphabetic",
  "v-alphabetic": "vAlphabetic",
  vectoreffect: "vectorEffect",
  "vector-effect": "vectorEffect",
  vertadvy: "vertAdvY",
  "vert-adv-y": "vertAdvY",
  vertoriginx: "vertOriginX",
  "vert-origin-x": "vertOriginX",
  vertoriginy: "vertOriginY",
  "vert-origin-y": "vertOriginY",
  vhanging: "vHanging",
  "v-hanging": "vHanging",
  videographic: "vIdeographic",
  "v-ideographic": "vIdeographic",
  viewbox: "viewBox",
  viewtarget: "viewTarget",
  vmathematical: "vMathematical",
  "v-mathematical": "vMathematical",
  wordspacing: "wordSpacing",
  "word-spacing": "wordSpacing",
  writingmode: "writingMode",
  "writing-mode": "writingMode",
  xchannelselector: "xChannelSelector",
  xheight: "xHeight",
  "x-height": "xHeight",
  xlinkactuate: "xlinkActuate",
  "xlink:actuate": "xlinkActuate",
  xlinkarcrole: "xlinkArcrole",
  "xlink:arcrole": "xlinkArcrole",
  xlinkhref: "xlinkHref",
  "xlink:href": "xlinkHref",
  xlinkrole: "xlinkRole",
  "xlink:role": "xlinkRole",
  xlinkshow: "xlinkShow",
  "xlink:show": "xlinkShow",
  xlinktitle: "xlinkTitle",
  "xlink:title": "xlinkTitle",
  xlinktype: "xlinkType",
  "xlink:type": "xlinkType",
  xmlbase: "xmlBase",
  "xml:base": "xmlBase",
  xmllang: "xmlLang",
  "xml:lang": "xmlLang",
  "xml:space": "xmlSpace",
  xmlnsxlink: "xmlnsXlink",
  "xmlns:xlink": "xmlnsXlink",
  xmlspace: "xmlSpace",
  ychannelselector: "yChannelSelector",
  zoomandpan: "zoomAndPan",
  onblur: "onBlur",
  onchange: "onChange",
  onclick: "onClick",
  oncontextmenu: "onContextMenu",
  ondoubleclick: "onDoubleClick",
  ondrag: "onDrag",
  ondragend: "onDragEnd",
  ondragenter: "onDragEnter",
  ondragexit: "onDragExit",
  ondragleave: "onDragLeave",
  ondragover: "onDragOver",
  ondragstart: "onDragStart",
  ondrop: "onDrop",
  onerror: "onError",
  onfocus: "onFocus",
  oninput: "onInput",
  oninvalid: "onInvalid",
  onkeydown: "onKeyDown",
  onkeypress: "onKeyPress",
  onkeyup: "onKeyUp",
  onload: "onLoad",
  onmousedown: "onMouseDown",
  onmouseenter: "onMouseEnter",
  onmouseleave: "onMouseLeave",
  onmousemove: "onMouseMove",
  onmouseout: "onMouseOut",
  onmouseover: "onMouseOver",
  onmouseup: "onMouseUp",
  onscroll: "onScroll",
  onsubmit: "onSubmit",
  ontouchcancel: "onTouchCancel",
  ontouchend: "onTouchEnd",
  ontouchmove: "onTouchMove",
  ontouchstart: "onTouchStart",
  onwheel: "onWheel"
};

// ../../node_modules/.pnpm/react-from-dom@0.6.2_react@17.0.2/node_modules/react-from-dom/esm/index.js
var __assign = function() {
  __assign = Object.assign || function(t) {
    for (var s, i = 1, n = arguments.length; i < n; i++) {
      s = arguments[i];
      for (var p in s)
        if (Object.prototype.hasOwnProperty.call(s, p))
          t[p] = s[p];
    }
    return t;
  };
  return __assign.apply(this, arguments);
};
var __read2 = function(o, n) {
  var m = typeof Symbol === "function" && o[Symbol.iterator];
  if (!m)
    return o;
  var i = m.call(o), r, ar = [], e;
  try {
    while ((n === void 0 || n-- > 0) && !(r = i.next()).done)
      ar.push(r.value);
  } catch (error) {
    e = { error };
  } finally {
    try {
      if (r && !r.done && (m = i["return"]))
        m.call(i);
    } finally {
      if (e)
        throw e.error;
    }
  }
  return ar;
};
var __spreadArray = function(to, from, pack) {
  if (pack || arguments.length === 2)
    for (var i = 0, l = from.length, ar; i < l; i++) {
      if (ar || !(i in from)) {
        if (!ar)
          ar = Array.prototype.slice.call(from, 0, i);
        ar[i] = from[i];
      }
    }
  return to.concat(ar || Array.prototype.slice.call(from));
};
function parseAttributes(node, reactKey) {
  var attributes = {
    key: reactKey
  };
  if (node instanceof Element) {
    var nodeClassNames = node.getAttribute("class");
    if (nodeClassNames) {
      attributes.className = nodeClassNames;
    }
    __spreadArray([], __read2(node.attributes), false).forEach(function(d) {
      switch (d.name) {
        case "class":
          break;
        case "style":
          attributes[d.name] = styleToObject(d.value);
          break;
        case "allowfullscreen":
        case "allowpaymentrequest":
        case "async":
        case "autofocus":
        case "autoplay":
        case "checked":
        case "controls":
        case "default":
        case "defer":
        case "disabled":
        case "formnovalidate":
        case "hidden":
        case "ismap":
        case "itemscope":
        case "loop":
        case "multiple":
        case "muted":
        case "nomodule":
        case "novalidate":
        case "open":
        case "readonly":
        case "required":
        case "reversed":
        case "selected":
        case "typemustmatch":
          attributes[possibleStandardNames[d.name] || d.name] = true;
          break;
        default:
          attributes[possibleStandardNames[d.name] || d.name] = d.value;
      }
    });
  }
  return attributes;
}
function parseChildren(childNodeList, level, options) {
  var children = __spreadArray([], __read2(childNodeList), false).map(function(node, index) {
    return convertFromNode(node, __assign(__assign({}, options), { index, level: level + 1 }));
  }).filter(Boolean);
  if (!children.length) {
    return null;
  }
  return children;
}
function parseName(nodeName) {
  if (/[a-z]+[A-Z]+[a-z]+/.test(nodeName)) {
    return nodeName;
  }
  return nodeName.toLowerCase();
}
function convertFromNode(input, options) {
  var _a;
  if (options === void 0) {
    options = {};
  }
  if (!input || !(input instanceof Node)) {
    return null;
  }
  var _b = options.actions, actions = _b === void 0 ? [] : _b, _c = options.index, index = _c === void 0 ? 0 : _c, _d = options.level, level = _d === void 0 ? 0 : _d, randomKey = options.randomKey;
  var node = input;
  var key = "".concat(level, "-").concat(index);
  var result = [];
  if (randomKey && level === 0) {
    key = "".concat(randomString(), "-").concat(key);
  }
  if (Array.isArray(actions)) {
    actions.forEach(function(action) {
      if (action.condition(node, key, level)) {
        if (typeof action.pre === "function") {
          node = action.pre(node, key, level);
          if (!(node instanceof Node)) {
            node = input;
            if (true) {
              console.warn("The `pre` method always must return a valid DomNode (instanceof Node) - your modification will be ignored (Hint: if you want to render a React-component, use the `post` method instead)");
            }
          }
        }
        if (typeof action.post === "function") {
          result.push(action.post(node, key, level));
        }
      }
    });
  }
  if (result.length) {
    return result;
  }
  switch (node.nodeType) {
    case 1: {
      return React.createElement(parseName(node.nodeName), parseAttributes(node, key), parseChildren(node.childNodes, level, options));
    }
    case 3: {
      var nodeText = ((_a = node.nodeValue) === null || _a === void 0 ? void 0 : _a.toString()) || "";
      if (/^\s+$/.test(nodeText) && !/[\u00A0\u202F]/.test(nodeText)) {
        return null;
      }
      if (!node.parentNode) {
        return nodeText;
      }
      var parentNodeName = node.parentNode.nodeName.toLowerCase();
      if (noTextChildNodes.includes(parentNodeName)) {
        if (/\S/.test(nodeText)) {
          console.warn("A textNode is not allowed inside '".concat(parentNodeName, `'. Your text "`).concat(nodeText, '" will be ignored'));
        }
        return null;
      }
      return nodeText;
    }
    case 8: {
      return null;
    }
    default: {
      return null;
    }
  }
}
function convertFromString(input, options) {
  if (options === void 0) {
    options = {};
  }
  if (!input || typeof input !== "string") {
    return null;
  }
  var _a = options.nodeOnly, nodeOnly = _a === void 0 ? false : _a, _b = options.selector, selector = _b === void 0 ? "body > *" : _b, _c = options.type, type = _c === void 0 ? "text/html" : _c;
  try {
    var parser = new DOMParser();
    var document_1 = parser.parseFromString(input, type);
    var node = document_1.querySelector(selector);
    if (!(node instanceof Node)) {
      throw new TypeError("Error parsing input");
    }
    if (nodeOnly) {
      return node;
    }
    return convertFromNode(node, options);
  } catch (error) {
    if (true) {
      console.error(error);
    }
  }
  return null;
}
function convert(input, options) {
  if (options === void 0) {
    options = {};
  }
  if (typeof input === "string") {
    return convertFromString(input, options);
  }
  if (input instanceof Node) {
    return convertFromNode(input, options);
  }
  return null;
}

// ../../node_modules/.pnpm/react-inlinesvg@2.3.0_react@17.0.2/node_modules/react-inlinesvg/esm/helpers.js
var import_exenv = __toESM(require_exenv());
var STATUS = {
  FAILED: "failed",
  LOADED: "loaded",
  LOADING: "loading",
  PENDING: "pending",
  READY: "ready",
  UNSUPPORTED: "unsupported"
};
function canUseDOM() {
  return import_exenv.canUseDOM;
}
function isSupportedEnvironment() {
  return supportsInlineSVG() && typeof window !== "undefined" && window !== null;
}
function supportsInlineSVG() {
  if (!document) {
    return false;
  }
  var div = document.createElement("div");
  div.innerHTML = "<svg />";
  return !!div.firstChild && div.firstChild.namespaceURI === "http://www.w3.org/2000/svg";
}
function randomString2(length) {
  var letters = "abcdefghijklmnopqrstuvwxyz";
  var numbers = "1234567890";
  var charset = "" + letters + letters.toUpperCase() + numbers;
  var randomCharacter = function(character) {
    return character[Math.floor(Math.random() * character.length)];
  };
  var R = "";
  for (var i = 0; i < length; i++) {
    R += randomCharacter(charset);
  }
  return R;
}
function removeProperties(input) {
  var filter = [];
  for (var _i = 1; _i < arguments.length; _i++) {
    filter[_i - 1] = arguments[_i];
  }
  var output = {};
  for (var key in input) {
    if ({}.hasOwnProperty.call(input, key)) {
      if (!filter.includes(key)) {
        output[key] = input[key];
      }
    }
  }
  return output;
}

// ../../node_modules/.pnpm/react-inlinesvg@2.3.0_react@17.0.2/node_modules/react-inlinesvg/esm/index.js
var __extends = function() {
  var extendStatics = function(d, b) {
    extendStatics = Object.setPrototypeOf || { __proto__: [] } instanceof Array && function(d2, b2) {
      d2.__proto__ = b2;
    } || function(d2, b2) {
      for (var p in b2)
        if (Object.prototype.hasOwnProperty.call(b2, p))
          d2[p] = b2[p];
    };
    return extendStatics(d, b);
  };
  return function(d, b) {
    if (typeof b !== "function" && b !== null)
      throw new TypeError("Class extends value " + String(b) + " is not a constructor or null");
    extendStatics(d, b);
    function __() {
      this.constructor = d;
    }
    d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
  };
}();
var __assign2 = function() {
  __assign2 = Object.assign || function(t) {
    for (var s, i = 1, n = arguments.length; i < n; i++) {
      s = arguments[i];
      for (var p in s)
        if (Object.prototype.hasOwnProperty.call(s, p))
          t[p] = s[p];
    }
    return t;
  };
  return __assign2.apply(this, arguments);
};
var __read3 = function(o, n) {
  var m = typeof Symbol === "function" && o[Symbol.iterator];
  if (!m)
    return o;
  var i = m.call(o), r, ar = [], e;
  try {
    while ((n === void 0 || n-- > 0) && !(r = i.next()).done)
      ar.push(r.value);
  } catch (error) {
    e = { error };
  } finally {
    try {
      if (r && !r.done && (m = i["return"]))
        m.call(i);
    } finally {
      if (e)
        throw e.error;
    }
  }
  return ar;
};
var __spreadArray2 = function(to, from) {
  for (var i = 0, il = from.length, j = to.length; i < il; i++, j++)
    to[j] = from[i];
  return to;
};
var cacheStore = /* @__PURE__ */ Object.create(null);
var InlineSVG = function(_super) {
  __extends(InlineSVG2, _super);
  function InlineSVG2(props) {
    var _this = _super.call(this, props) || this;
    _this.isActive = false;
    _this.handleCacheQueue = function(content) {
      if (typeof content === "string") {
        _this.handleLoad(content);
        return;
      }
      _this.handleError(content);
    };
    _this.handleLoad = function(content) {
      if (_this.isActive) {
        _this.setState({
          content,
          status: STATUS.LOADED
        }, _this.getElement);
      }
    };
    _this.handleError = function(error) {
      var onError = _this.props.onError;
      var status = error.message === "Browser does not support SVG" ? STATUS.UNSUPPORTED : STATUS.FAILED;
      if (_this.isActive) {
        _this.setState({ status }, function() {
          if (typeof onError === "function") {
            onError(error);
          }
        });
      }
    };
    _this.request = function() {
      var _a = _this.props, cacheRequests = _a.cacheRequests, fetchOptions = _a.fetchOptions, src = _a.src;
      try {
        if (cacheRequests) {
          cacheStore[src] = { content: "", status: STATUS.LOADING, queue: [] };
        }
        return fetch(src, fetchOptions).then(function(response) {
          var contentType = response.headers.get("content-type");
          var _a2 = __read3((contentType || "").split(/ ?; ?/), 1), fileType = _a2[0];
          if (response.status > 299) {
            throw new Error("Not found");
          }
          if (!["image/svg+xml", "text/plain"].some(function(d) {
            return fileType.indexOf(d) >= 0;
          })) {
            throw new Error("Content type isn't valid: " + fileType);
          }
          return response.text();
        }).then(function(content) {
          var currentSrc = _this.props.src;
          if (src !== currentSrc) {
            return;
          }
          _this.handleLoad(content);
          if (cacheRequests) {
            var cache = cacheStore[src];
            if (cache) {
              cache.content = content;
              cache.status = STATUS.LOADED;
              cache.queue = cache.queue.filter(function(cb) {
                cb(content);
                return false;
              });
            }
          }
        }).catch(function(error) {
          _this.handleError(error);
          if (cacheRequests) {
            var cache = cacheStore[src];
            if (cache) {
              cache.queue.forEach(function(cb) {
                cb(error);
              });
              delete cacheStore[src];
            }
          }
        });
      } catch (error) {
        return _this.handleError(new Error(error.message));
      }
    };
    _this.state = {
      content: "",
      element: null,
      hasCache: !!props.cacheRequests && !!cacheStore[props.src],
      status: STATUS.PENDING
    };
    _this.hash = props.uniqueHash || randomString2(8);
    return _this;
  }
  InlineSVG2.prototype.componentDidMount = function() {
    this.isActive = true;
    if (!canUseDOM()) {
      return;
    }
    var status = this.state.status;
    var src = this.props.src;
    try {
      if (status === STATUS.PENDING) {
        if (!isSupportedEnvironment()) {
          throw new Error("Browser does not support SVG");
        }
        if (!src) {
          throw new Error("Missing src");
        }
        this.load();
      }
    } catch (error) {
      this.handleError(error);
    }
  };
  InlineSVG2.prototype.componentDidUpdate = function(prevProps, prevState) {
    if (!canUseDOM()) {
      return;
    }
    var _a = this.state, hasCache = _a.hasCache, status = _a.status;
    var _b = this.props, onLoad = _b.onLoad, src = _b.src;
    if (prevState.status !== STATUS.READY && status === STATUS.READY) {
      if (onLoad) {
        onLoad(src, hasCache);
      }
    }
    if (prevProps.src !== src) {
      if (!src) {
        this.handleError(new Error("Missing src"));
        return;
      }
      this.load();
    }
  };
  InlineSVG2.prototype.componentWillUnmount = function() {
    this.isActive = false;
  };
  InlineSVG2.prototype.processSVG = function() {
    var content = this.state.content;
    var preProcessor = this.props.preProcessor;
    if (preProcessor) {
      return preProcessor(content);
    }
    return content;
  };
  InlineSVG2.prototype.updateSVGAttributes = function(node) {
    var _this = this;
    var _a = this.props, _b = _a.baseURL, baseURL = _b === void 0 ? "" : _b, uniquifyIDs = _a.uniquifyIDs;
    var replaceableAttributes = ["id", "href", "xlink:href", "xlink:role", "xlink:arcrole"];
    var linkAttributes = ["href", "xlink:href"];
    var isDataValue = function(name, value) {
      return linkAttributes.indexOf(name) >= 0 && (value ? value.indexOf("#") < 0 : false);
    };
    if (!uniquifyIDs) {
      return node;
    }
    __spreadArray2([], __read3(node.children)).map(function(d) {
      if (d.attributes && d.attributes.length) {
        var attributes_1 = Object.values(d.attributes).map(function(a) {
          var attr = a;
          var match = a.value.match(/url\((.*?)\)/);
          if (match && match[1]) {
            attr.value = a.value.replace(match[0], "url(" + baseURL + match[1] + "__" + _this.hash + ")");
          }
          return attr;
        });
        replaceableAttributes.forEach(function(r) {
          var attribute = attributes_1.find(function(a) {
            return a.name === r;
          });
          if (attribute && !isDataValue(r, attribute.value)) {
            attribute.value = attribute.value + "__" + _this.hash;
          }
        });
      }
      if (d.children.length) {
        return _this.updateSVGAttributes(d);
      }
      return d;
    });
    return node;
  };
  InlineSVG2.prototype.getNode = function() {
    var _a = this.props, description = _a.description, title = _a.title;
    try {
      var svgText = this.processSVG();
      var node = convert(svgText, { nodeOnly: true });
      if (!node || !(node instanceof SVGSVGElement)) {
        throw new Error("Could not convert the src to a DOM Node");
      }
      var svg = this.updateSVGAttributes(node);
      if (description) {
        var originalDesc = svg.querySelector("desc");
        if (originalDesc && originalDesc.parentNode) {
          originalDesc.parentNode.removeChild(originalDesc);
        }
        var descElement = document.createElement("desc");
        descElement.innerHTML = description;
        svg.prepend(descElement);
      }
      if (title) {
        var originalTitle = svg.querySelector("title");
        if (originalTitle && originalTitle.parentNode) {
          originalTitle.parentNode.removeChild(originalTitle);
        }
        var titleElement = document.createElement("title");
        titleElement.innerHTML = title;
        svg.prepend(titleElement);
      }
      return svg;
    } catch (error) {
      return this.handleError(error);
    }
  };
  InlineSVG2.prototype.getElement = function() {
    try {
      var node = this.getNode();
      var element = convert(node);
      if (!element || !React2.isValidElement(element)) {
        throw new Error("Could not convert the src to a React element");
      }
      this.setState({
        element,
        status: STATUS.READY
      });
    } catch (error) {
      this.handleError(new Error(error.message));
    }
  };
  InlineSVG2.prototype.load = function() {
    var _this = this;
    if (this.isActive) {
      this.setState({
        content: "",
        element: null,
        status: STATUS.LOADING
      }, function() {
        var _a = _this.props, cacheRequests = _a.cacheRequests, src = _a.src;
        var cache = cacheRequests && cacheStore[src];
        if (cache) {
          if (cache.status === STATUS.LOADING) {
            cache.queue.push(_this.handleCacheQueue);
          } else if (cache.status === STATUS.LOADED) {
            _this.handleLoad(cache.content);
          }
          return;
        }
        var dataURI = src.match(/data:image\/svg[^,]*?(;base64)?,(.*)/);
        var inlineSrc;
        if (dataURI) {
          inlineSrc = dataURI[1] ? atob(dataURI[2]) : decodeURIComponent(dataURI[2]);
        } else if (src.indexOf("<svg") >= 0) {
          inlineSrc = src;
        }
        if (inlineSrc) {
          _this.handleLoad(inlineSrc);
          return;
        }
        _this.request();
      });
    }
  };
  InlineSVG2.prototype.render = function() {
    var _a = this.state, element = _a.element, status = _a.status;
    var _b = this.props, _c = _b.children, children = _c === void 0 ? null : _c, innerRef = _b.innerRef, _d = _b.loader, loader = _d === void 0 ? null : _d;
    var elementProps = removeProperties(this.props, "baseURL", "cacheRequests", "children", "description", "fetchOptions", "innerRef", "loader", "onError", "onLoad", "preProcessor", "src", "title", "uniqueHash", "uniquifyIDs");
    if (!canUseDOM()) {
      return loader;
    }
    if (element) {
      return React2.cloneElement(element, __assign2({ ref: innerRef }, elementProps));
    }
    if ([STATUS.UNSUPPORTED, STATUS.FAILED].indexOf(status) > -1) {
      return children;
    }
    return loader;
  };
  InlineSVG2.defaultProps = {
    cacheRequests: true,
    uniquifyIDs: false
  };
  return InlineSVG2;
}(React2.PureComponent);
var esm_default = InlineSVG;
export {
  cacheStore,
  esm_default as default
};
/*!
  Copyright (c) 2015 Jed Watson.
  Based on code that is Copyright 2013-2015, Facebook, Inc.
  All rights reserved.
*/
//# sourceMappingURL=react-inlinesvg.js.map
