{"version":3,"file":"urx.cjs.development.js","sources":["../src/constants.ts","../src/utils.ts","../src/actions.ts","../src/streams.ts","../src/pipe.ts","../src/transformers.ts","../src/system.ts"],"sourcesContent":["export const PUBLISH = 0 as const\nexport type PUBLISH = typeof PUBLISH\n\nexport const SUBSCRIBE = 1 as const\nexport type SUBSCRIBE = typeof SUBSCRIBE\n\nexport const RESET = 2 as const\nexport type RESET = typeof RESET\n\nexport const VALUE = 4 as const\nexport type VALUE = typeof VALUE\n","/**\n * Utils includes\n * - a handful of functional utilities inspired by or taken from the [Ramda library](https://ramdajs.com/);\n * - TypeScript crutches - the [[tup]] function.\n *\n * Use these for your convenience - they are here so that urx is zero-dependency package.\n *\n * @packageDocumentation\n */\n\n/** @internal */\nexport interface Proc {\n  (): any\n}\n\n/**\n * Performs left to right composition of two functions.\n */\nexport function compose<I, A, R>(a: (arg: A) => R, b: (arg: I) => A): (arg: I) => R {\n  return (arg: I) => a(b(arg))\n}\n\n/**\n * Takes a value and applies a function to it.\n */\nexport function thrush<I, K>(arg: I, proc: (arg: I) => K) {\n  return proc(arg)\n}\n\n/**\n * Takes a 2 argument function and partially applies the first argument.\n */\nexport function curry2to1<T, K, R>(proc: (arg1: T, arg2: K) => R, arg1: T): (arg2: K) => R {\n  return arg2 => proc(arg1, arg2)\n}\n\n/**\n * Takes a 1 argument function and returns a function which when called, executes it with the provided argument.\n */\nexport function curry1to0<T, R>(proc: (arg: T) => R, arg: T): () => R {\n  return () => proc(arg)\n}\n\n/**\n * Returns a function which extracts the property from from the passed object.\n */\nexport function prop(property: string) {\n  return (object: any) => object[property]\n}\n\n/**\n * Calls callback with the first argument, and returns it.\n */\nexport function tap<T>(arg: T, proc: (arg: T) => any): T {\n  proc(arg)\n  return arg\n}\n\n/**\n *  Utility function to help typescript figure out that what we pass is a tuple and not a generic array.\n *  Taken from (this StackOverflow tread)[https://stackoverflow.com/questions/49729550/implicitly-create-a-tuple-in-typescript/52445008#52445008]\n */\nexport function tup<T extends Array<any>>(...args: T): T {\n  return args\n}\n\n/**\n * Calls the passed function.\n */\nexport function call(proc: Proc) {\n  proc()\n}\n\n/**\n * returns a function which when called always returns the passed value\n */\nexport function always<T>(value: T) {\n  return () => value\n}\n\n/**\n * returns a function which calls all passed functions in the passed order.\n * joinProc does not pass arguments or collect return values.\n */\nexport function joinProc(...procs: Proc[]) {\n  return () => {\n    procs.map(call)\n  }\n}\n\nexport function noop() {}\n","/**\n * urx Actions operate on streams - `publish` publishes data in a stream, and `subscribe` attaches a subscription to a stream.\n * @packageDocumentation\n */\nimport { PUBLISH, RESET, SUBSCRIBE, VALUE } from './constants'\nimport { curry2to1 } from './utils'\n\n/**\n * A Publisher is the **input end** of a Stream. The [[publish]] action publishes values in publishers.\n * @typeParam T the type of values to be published.\n */\nexport interface Publisher<T> {\n  /** @internal */\n  (action: PUBLISH, value: T): void\n}\n\n/**\n * An Emitter is the **output end** of a Stream. The [[subscribe]] action binds {@link Subscription | subscriptions} to emitters.\n * @typeParam T the type of values that will be emitted.\n */\nexport interface Emitter<T> {\n  /** @internal */\n  (action: SUBSCRIBE, subscription: Subscription<T>): Unsubscribe\n  /** @internal */\n  (action: RESET): void\n}\n\n/**\n * Subscriptions are bound to Emitters with the [[subscribe]] action, and get called with the new values.\n * @typeParam T the Emitter value type.\n */\nexport interface Subscription<T> {\n  (value: T): any\n}\n\n/**\n * Subscribe-like actions return unsubscribe handles of the Unsubscribe type, which, when called, unbind the subscription.\n */\nexport interface Unsubscribe {\n  (): void\n}\n\n/**\n * Streams present both the input and the output ends of a stream.\n * A single stream instance can be both subscribed to and published in.\n */\nexport interface Stream<T> extends Publisher<T>, Emitter<T> {\n  /** @internal */\n  (action: SUBSCRIBE | PUBLISH | RESET): any // fix for bug with pipe + connect\n}\n\n/**\n * Just like {@link Stream | streams}, stateful streams present both input and output ends of a stream.\n * A single stream instance can be both subscribed to and published in.\n * Stateful Streams can also act like depots, preserving the last passed value and immediately publishing it to new subscriptions.\n * [[getValue]] can be used to extract value from stateful streams.\n */\nexport interface StatefulStream<T> extends Publisher<T>, Emitter<T> {\n  /** @internal */\n  (action: SUBSCRIBE | PUBLISH | RESET | VALUE): any // fix for bug with pipe + connect\n  // StatefulStream should extend rather then duplicate the signature, but this somehow causes a bug in TS\n}\n\n/**\n * Subscribes the specified [[Subscription]] to the updates from the Emitter.\n * The emitter calls the subscription with the new data each time new data is published into it.\n *\n * ```ts\n * const foo = stream<number>();\n * subscribe(foo, (value) => console.log(value));\n * ```\n *\n * @returns an [[Unsubscribe]] handle  - calling it will unbind the subscription from the emitter.\n *```ts\n * const foo = stream<number>();\n * const unsub = subscribe(foo, (value) => console.log(value));\n * unsub();\n *```\n */\nexport function subscribe<T>(emitter: Emitter<T>, subscription: Subscription<T>): Unsubscribe {\n  return emitter(SUBSCRIBE, subscription)\n}\n\n/**\n * Publishes the value into the passed [[Publisher]].\n *\n * ```ts\n * const foo = stream<number>();\n * publish(foo, 42);\n * ```\n */\nexport function publish<T>(publisher: Publisher<T>, value: T) {\n  publisher(PUBLISH, value)\n}\n\n/**\n * Clears all subscriptions from the [[Emitter]].\n * ```ts\n * const foo = stream<number>();\n * subscribe(foo, (value) => console.log(value));\n * reset(foo);\n * publish(foo, 42);\n * ```\n */\nexport function reset(emitter: Emitter<any>) {\n  emitter(RESET)\n}\n\n/**\n * Extracts the current value from a stateful stream. Use it only as an escape hatch, as it violates the concept of reactive programming.\n * ```ts\n * const foo = statefulStream(42);\n * console.log(getValue(foo));\n * ```\n */\nexport function getValue<T>(depot: StatefulStream<T>): T {\n  return depot(VALUE)\n}\n\n/**\n * Connects two streams - any value emitted from the emitter will be published in the publisher.\n * ```ts\n * const foo = stream<number>();\n * const bar = stream<number>();\n * subscribe(bar, (value) => console.log(`Bar emitted ${value}`));\n *\n * connect(foo, bar);\n * publish(foo);\n * ```\n * @returns an [[Unsubscribe]] handle which will disconnect the two streams.\n */\nexport function connect<T>(emitter: Emitter<T>, publisher: Publisher<T>) {\n  return subscribe(emitter, curry2to1(publisher, PUBLISH))\n}\n\n/**\n * Executes the passed subscription at most once, for the next emit from the emitter.\n * ```ts\n * const foo = stream<number>()\n * handleNext(foo, value => console.log(value)) // called once, with 42\n * publish(foo, 42)\n * publish(foo, 43)\n * ```\n * @returns an [[Unsubscribe]] handle to unbind the subscription if necessary.\n */\nexport function handleNext<T>(emitter: Emitter<T>, subscription: Subscription<T>) {\n  const unsub = emitter(SUBSCRIBE, value => {\n    unsub()\n    subscription(value)\n  })\n  return unsub\n}\n","/**\n * Streams are the basic building blocks of a reactive system. Think of them as the system permanent \"data tubes\".\n *\n * A stream acts as both an [[Emitter]] and [[Publisher]]. Each stream can have multiple {@link Subscription | Subscriptions}.\n *\n * urx streams are either **stateless** or **stateful**.\n * Stateless streams emit data to existing subscriptions when published, without keeping track of it.\n * Stateful streams remember the last published value and immediately publish it to new subscriptions.\n *\n * ```ts\n * import { stream, statefulStream, publish, subscribe } from \"@virtuoso.dev/urx\";\n *\n * // foo is a stateless stream\n * const foo = stream<number>();\n *\n * publish(foo, 42);\n * // this subsription will not be called...\n * subscribe(foo, (value) => console.log(value));\n * // it will only catch published values after it\n * publish(foo, 43);\n *\n * // stateful streams always start with an initial value\n * const bar = statefulStream(42);\n *\n * // subscribing to a stateful stream\n * // immediately calls the subscription with the current value\n * subscribe(bar, (value) => console.log(value));\n *\n * // subsequent publishing works just like stateless streams\n * publish(bar, 43);\n * ```\n * @packageDocumentation\n */\n\nimport { Emitter, StatefulStream, Stream, Subscription, Unsubscribe, subscribe, connect } from './actions'\nimport { RESET, PUBLISH, SUBSCRIBE, VALUE } from './constants'\nimport { tap, noop } from './utils'\n\n/**\n * Constructs a new stateless stream.\n * ```ts\n * const foo = stream<number>();\n * ```\n * @typeParam T the type of values to publish in the stream.\n * @returns a [[Stream]]\n */\nexport function stream<T>(): Stream<T> {\n  const subscriptions = [] as Subscription<T>[]\n\n  return ((action: PUBLISH | SUBSCRIBE | RESET, arg: any) => {\n    switch (action) {\n      case RESET:\n        subscriptions.splice(0, subscriptions.length)\n        return\n      case SUBSCRIBE:\n        subscriptions.push(arg)\n        return () => {\n          const indexOf = subscriptions.indexOf(arg)\n          if (indexOf > -1) {\n            subscriptions.splice(indexOf, 1)\n          }\n        }\n      case PUBLISH:\n        subscriptions.slice().forEach(subscription => {\n          subscription(arg as T)\n        })\n        return\n      default:\n        throw new Error(`unrecognized action ${action}`)\n    }\n  }) as Stream<T>\n}\n\n/**\n * Constructs a new stateful stream.\n * ```ts\n * const foo = statefulStream(42);\n * ```\n * @param initial the initial value in the stream.\n * @typeParam T the type of values to publish in the stream. If omitted, the function infers it from the initial value.\n * @returns a [[StatefulStream]]\n */\nexport function statefulStream<T>(initial: T): StatefulStream<T> {\n  let value: T = initial\n  const innerSubject = stream<T>()\n\n  return ((action: PUBLISH | SUBSCRIBE | RESET | VALUE, arg: any) => {\n    switch (action) {\n      case SUBSCRIBE:\n        const subscription = arg as Subscription<T>\n        subscription(value)\n        break\n      case PUBLISH:\n        value = arg as T\n        break\n      case VALUE:\n        return value\n    }\n    return innerSubject(action as any, arg)\n  }) as StatefulStream<T>\n}\n\n/**\n * Event handlers are special emitters which can have **at most one active subscription**.\n * Subscribing to an event handler unsubscribes the previous subscription, if present.\n * ```ts\n * const foo = stream<number>();\n * const fooEvent = eventHandler(foo);\n *\n * // will be called once with 42\n * subscribe(fooEvent, (value) => console.log(`Sub 1 ${value}`));\n * publish(foo, 42);\n *\n * // unsubscribes sub 1\n * subscribe(fooEvent, (value) => console.log(`Sub 2 ${value}`));\n * publish(foo, 43);\n * ```\n * @param emitter the source emitter.\n * @returns the single-subscription emitter.\n */\nexport function eventHandler<T>(emitter: Emitter<T>) {\n  let unsub: Unsubscribe | undefined\n  let currentSubscription: any\n  let cleanup = () => unsub && unsub()\n\n  return function(action: SUBSCRIBE | RESET, subscription?: Subscription<T>) {\n    switch (action) {\n      case SUBSCRIBE:\n        if (subscription) {\n          if (currentSubscription === subscription) {\n            return\n          }\n          cleanup()\n          currentSubscription = subscription\n          unsub = subscribe(emitter, subscription!)\n          return unsub\n        } else {\n          cleanup()\n          return noop\n        }\n      case RESET:\n        cleanup()\n        currentSubscription = null\n        return\n      default:\n        throw new Error(`unrecognized action ${action}`)\n    }\n  } as Emitter<T>\n}\n\n/**\n * Creates and connects a \"junction\" stream to the specified emitter. Often used with [[pipe]], to avoid the multiple evaluation of operator sets.\n *\n * ```ts\n * const foo = stream<number>();\n *\n * const fooX2 = pipe(\n *   foo,\n *   map((value) => {\n *     console.log(`multiplying ${value}`);\n *     return value * 2;\n *   })\n * );\n *\n * subscribe(fooX2, (value) => console.log(value));\n * subscribe(fooX2, (value) => console.log(value));\n *\n * publish(foo, 42); // executes the map operator twice for each subscription.\n *\n * const sharedFooX2 = streamFromEmitter(pipe(\n *   foo,\n *   map((value) => {\n *     console.log(`shared multiplying ${value}`);\n *     return value * 2;\n *   })\n * ));\n *\n * subscribe(sharedFooX2, (value) => console.log(value));\n * subscribe(sharedFooX2, (value) => console.log(value));\n *\n * publish(foo, 42);\n *```\n * @returns the resulting stream.\n */\nexport function streamFromEmitter<T>(emitter: Emitter<T>): Stream<T> {\n  return tap(stream<T>(), stream => connect(emitter, stream))\n}\n\n/**\n * Creates and connects a \"junction\" stateful stream to the specified emitter. Often used with [[pipe]], to avoid the multiple evaluation of operator sets.\n *\n * ```ts\n * const foo = stream<number>();\n *\n * const fooX2 = pipe(\n *   foo,\n *   map((value) => {\n *     console.log(`multiplying ${value}`);\n *     return value * 2;\n *   })\n * );\n *\n * subscribe(fooX2, (value) => console.log(value));\n * subscribe(fooX2, (value) => console.log(value));\n *\n * publish(foo, 42); // executes the map operator twice for each subscription.\n *\n * const sharedFooX2 = statefulStreamFromEmitter(pipe(\n *   foo,\n *   map((value) => {\n *     console.log(`shared multiplying ${value}`);\n *     return value * 2;\n *   })\n * ), 42);\n *\n * subscribe(sharedFooX2, (value) => console.log(value));\n * subscribe(sharedFooX2, (value) => console.log(value));\n *\n * publish(foo, 42);\n *```\n * @param initial the initial value in the stream.\n * @returns the resulting stateful stream.\n */\nexport function statefulStreamFromEmitter<T>(emitter: Emitter<T>, initial: T): StatefulStream<T> {\n  return tap(statefulStream(initial), stream => connect(emitter, stream))\n}\n","/**\n *\n * Stream values can be transformed and controlled by {@link pipe | **piping**} through **operators**.\n * urx includes several operators like [[map]], [[filter]], [[scan]], and [[throttleTime]].\n * The [[withLatestFrom]] operator allows the combination of values from other streams.\n *\n * ```ts\n * const foo = stream<number>()\n *\n * // create an emitter that first adds 2 to the passed value, then multiplies it by * 2\n * const bar = pipe(foo, map(value => value + 2), map(value => value * 2))\n * subscribe(bar, value => console.log(value))\n * publish(foo, 2) // outputs 8\n * ```\n *\n * ### Implementing Custom Operators\n * To implement your own operators, implement the [[Operator]] interface.\n * @packageDocumentation\n */\nimport { compose, thrush } from './utils'\nimport { Emitter, subscribe, Subscription, reset } from './actions'\nimport { SUBSCRIBE, RESET } from './constants'\n\n/**\n * Operators can transform and control the flow of values.\n * [[pipe]] is used to transform one Emitter into another by stacking operators to its values.\n * To build your own operator that looks like the built-in ones,\n * create a function which returns an operator.\n * The following custom operator multiplies the passed value:\n *\n * ```ts\n * function multiplyBy(multiplier: number): Operator<number> {\n *  return done => value => done(value * multiplier)\n * }\n *\n * const foo = stream<number>()\n * const multipliedFoo = pipe(foo, multiplyBy(3))\n * subscribe(multipliedFoo, value => console.log(value))\n * publish(foo, 42)\n * ```\n */\nexport interface Operator<Input, Output = Input> {\n  (done: (value: Output) => void): (value: Input) => void\n}\n\n/** @internal */\ntype CombineOperatorsReturnType<I, O> = (subscriber: (value: O) => void) => (value: I) => void\n\n/** @internal */\nfunction combineOperators<I>(...operators: Operator<any, any>[]): CombineOperatorsReturnType<I, any> {\n  return (subscriber: (value: any) => void) => {\n    return operators.reduceRight(thrush, subscriber)\n  }\n}\n\n/** @internal */\ntype O<I, OP> = Operator<I, OP>\n\n/**\n * Creates a new emitter from the passed one by piping its values through one or more operators.\n * Operators can perform various actions like filter values, pull values from other emitters, or compute new values.\n *\n * ```ts\n * const foo = stream<number>()\n *\n * // create an emitter that first adds 2 to the passed value, then multiplies it by * 2\n * const bar = pipe(foo, map(value => value + 2), map(value => value * 2))\n * subscribe(bar, value => console.log(value))\n * publish(foo, 2) // outputs 8\n * ```\n * #### Sharing Subscription Calculations\n *\n * `pipe` acts as a proxy for the source emitter, and re-runs the operators for each subscription to the derived emitter.\n * Use [[streamFromEmitter]] or [[statefulStreamFromEmitter]] to avoid that.\n */\nexport function pipe<T>(s: Emitter<T>): Emitter<T> // prettier-ignore\nexport function pipe<T, O1>(s: Emitter<T>, o1: O<T, O1>): Emitter<O1> // prettier-ignore\nexport function pipe<T, O1, O2>(s: Emitter<T>, ...o: [O<T, O1>, O<O1, O2>]): Emitter<O2> // prettier-ignore\nexport function pipe<T, O1, O2, O3>(s: Emitter<T>, ...o: [O<T, O1>, O<O1, O2>, O<O2, O3>]): Emitter<O3> // prettier-ignore\nexport function pipe<T, O1, O2, O3, O4>(s: Emitter<T>, ...o: [O<T, O1>, O<O1, O2>, O<O2, O3>, O<O3, O4>]): Emitter<O4> // prettier-ignore\nexport function pipe<T, O1, O2, O3, O4, O5>(s: Emitter<T>, ...o: [O<T, O1>, O<O1, O2>, O<O2, O3>, O<O3, O4>, O<O4, O5>]): Emitter<O5> // prettier-ignore\nexport function pipe<T, O1, O2, O3, O4, O5, O6>(s: Emitter<T>, ...o: [O<T, O1>, O<O1, O2>, O<O2, O3>, O<O3, O4>, O<O4, O5>, O<O5, O6>]): Emitter<O6> // prettier-ignore\nexport function pipe<T, O1, O2, O3, O4, O5, O6, O7>(s: Emitter<T>, ...o: [O<T, O1>, O<O1, O2>, O<O2, O3>, O<O3, O4>, O<O4, O5>, O<O5, O6>, O<O6, O7>]): Emitter<O7> // prettier-ignore\nexport function pipe<T>(source: Emitter<T>, ...operators: O<any, any>[]): Emitter<any> {\n  // prettier-ignore\n  const project = combineOperators(...operators)\n  return ((action: SUBSCRIBE | RESET, subscription: Subscription<any>) => {\n    switch (action) {\n      case SUBSCRIBE:\n        return subscribe(source, project(subscription))\n      case RESET:\n        reset(source)\n        return\n      default:\n        throw new Error(`unrecognized action ${action}`)\n    }\n  }) as Emitter<any>\n}\n\n/**\n * A function which determines if two values are equal.\n * Implement custom comparators when [[distinctUntilChanged]] needs to work on non-primitive objects.\n * @returns true if values should be considered equal.\n */\nexport interface Comparator<T> {\n  (previous: T, next: T): boolean\n}\n\n/**\n * The default [[Comparator]] for [[distinctUntilChanged]] and [[duc]].\n */\nexport function defaultComparator<T>(previous: T, next: T) {\n  return previous === next\n}\n\n/**\n * Filters out identical values. Pass an optional [[Comparator]] if you need to filter non-primitive values.\n * ```ts\n * const foo = stream<number>()\n *\n * subscribe(\n *  pipe(foo, distinctUntilChanged()),\n *  console.log\n * ) // will be called only once\n *\n * publish(foo, 42)\n * publish(foo, 42)\n * ```\n */\nexport function distinctUntilChanged<T>(comparator: Comparator<T> = defaultComparator): Operator<T> {\n  let current: T\n  return done => next => {\n    if (!comparator(current, next)) {\n      current = next\n      done(next)\n    }\n  }\n}\n\n/**\n * Filters out values for which the predicator does not return `true`-ish.\n * ```ts\n * const foo = stream<number>()\n *\n * subscribe(\n *  pipe(foo, filter(value => value % 2 === 0)),\n *  console.log\n * ) // will be called only with even values\n *\n * publish(foo, 2)\n * publish(foo, 3)\n * publish(foo, 4)\n * publish(foo, 5)\n * ```\n */\nexport function filter<T>(predicate: (value: T) => boolean): Operator<T> {\n  return done => value => {\n    predicate(value) && done(value)\n  }\n}\n\n/**\n * Maps values using the provided project function.\n * ```ts\n * const foo = stream<number>()\n *\n * subscribe(\n *  pipe(foo, map(value => value * 2)),\n *  console.log\n * ) // 4, 6\n *\n * publish(foo, 2)\n * publish(foo, 3)\n * ```\n */\nexport function map<T, K>(project: (value: T) => K): Operator<T, K> {\n  return done => compose(done, project)\n}\n\n/**\n * Maps values to the hard-coded value.\n * ```ts\n * const foo = stream<number>()\n *\n * subscribe(\n *  pipe(foo, mapTo(3)),\n *  console.log\n * ) // 3, 3\n *\n * publish(foo, 1)\n * publish(foo, 2)\n * ```\n */\nexport function mapTo<T>(value: T): Operator<any, T> {\n  return done => () => done(value)\n}\n\n/**\n * Works like Array#reduce.\n * Applies an accumulator function on the emitter, and outputs intermediate result. Starts with the initial value.\n * ```ts\n * const foo = stream<number>()\n *\n * subscribe(\n *  pipe(foo, scan((acc, value) => acc + value, 2),\n *  console.log\n * ) // 3, 5\n *\n * publish(foo, 1)\n * publish(foo, 2)\n * ```\n */\nexport function scan<T, K>(scanner: (current: T, value: K) => T, initial: T): Operator<K, T> {\n  return done => value => done((initial = scanner(initial, value)))\n}\n\n/**\n * Skips the specified amount of values from the emitter.\n * ```ts\n * const foo = stream<number>()\n *\n * subscribe(\n *  pipe(foo, skip(2)),\n *  console.log\n * ) // 3, 4\n *\n * publish(foo, 1) // skipped\n * publish(foo, 2) // skipped\n * publish(foo, 3)\n * publish(foo, 4)\n * ```\n */\nexport function skip<T>(times: number): Operator<T> {\n  return done => value => {\n    times > 0 ? times-- : done(value)\n  }\n}\n\n/**\n * Throttles flowing values at the provided interval in milliseconds.\n * [Throttle VS Debounce in SO](https://stackoverflow.com/questions/25991367/difference-between-throttling-and-debouncing-a-function).\n *\n * ```ts\n *  const foo = stream<number>()\n *  publish(foo, 1)\n *\n *  setTimeout(() => publish(foo, 2), 20)\n *  setTimeout(() => publish(foo, 3), 20)\n *\n *  subscribe(pipe(foo, throttleTime(50)), val => {\n *    console.log(value); // 3\n *  })\n * ```\n */\nexport function throttleTime<T>(interval: number): Operator<T> {\n  let currentValue: T | undefined\n  let timeout: any\n\n  return done => value => {\n    currentValue = value\n\n    if (timeout) {\n      return\n    }\n\n    timeout = setTimeout(() => {\n      timeout = undefined\n      done(currentValue!)\n    }, interval)\n  }\n}\n\n/**\n * Debounces flowing values at the provided interval in milliseconds.\n * [Throttle VS Debounce in SO](https://stackoverflow.com/questions/25991367/difference-between-throttling-and-debouncing-a-function).\n *\n * ```ts\n *  const foo = stream<number>()\n *  publish(foo, 1)\n *\n *  setTimeout(() => publish(foo, 2), 20)\n *  setTimeout(() => publish(foo, 3), 20)\n *\n *  subscribe(pipe(foo, debounceTime(50)), val => {\n *    console.log(value); // 3\n *  })\n * ```\n */\nexport function debounceTime<T>(interval: number): Operator<T> {\n  let currentValue: T | undefined\n  let timeout: any\n\n  return done => value => {\n    currentValue = value\n    if (timeout) {\n      clearTimeout(timeout)\n    }\n\n    timeout = setTimeout(() => {\n      done(currentValue!)\n    }, interval)\n  }\n}\n\n/**\n * Combines the source Emitter with the latest values from the specified Emitters into an array. Outputs only when the source Emitter emits.\n * See [[combineLatest]] for a transformer that outputs when any of the emitters emit.\n *\n * ```ts\n *  const foo = stream<number>()\n *  const bar = stream<number>()\n *  subscribe(\n *    pipe(\n *      foo,\n *      withLatestFrom(bar)\n *    ),\n *    (([foo, bar]) => console.log({ foo, bar }))\n *  )\n *\n *  publish(foo, 1) // nothing happens, bar has not emitted yet\n *  publish(bar, 1) // still nothing\n *  publish(foo, 2) // logs { foo: 2, bar: 1 }\n *  publish(bar, 2)\n *  publish(foo, 3) // logs { foo: 3, bar: 2 }\n * ```\n */\nexport function withLatestFrom<T, R1>(...s: [Emitter<R1>]): Operator<T, [T, R1]> // prettier-ignore\nexport function withLatestFrom<T, R1, R2>(...s: [Emitter<R1>, Emitter<R2>]): Operator<T, [T, R1, R2]> // prettier-ignore\nexport function withLatestFrom<T, R1, R2, R3>( ...s: [Emitter<R1>, Emitter<R2>, Emitter<R3>]): Operator<T, [T, R1, R2, R3]> // prettier-ignore\nexport function withLatestFrom<T, R1, R2, R3, R4>( ...s: [Emitter<R1>, Emitter<R2>, Emitter<R3>, Emitter<R4>]): Operator<T, [T, R1, R2, R3, R4]> // prettier-ignore\nexport function withLatestFrom<T, R1, R2, R3, R4, R5>( ...s: [Emitter<R1>, Emitter<R2>, Emitter<R3>, Emitter<R4>, Emitter<R5>]): Operator<T, [T, R1, R2, R3, R4, R5]> // prettier-ignore\nexport function withLatestFrom<T, R1, R2, R3, R4, R5, R6>( ...s: [Emitter<R1>, Emitter<R2>, Emitter<R3>, Emitter<R4>, Emitter<R5>, Emitter<R6>]): Operator<T, [T, R1, R2, R3, R4, R5, R6]> // prettier-ignore\nexport function withLatestFrom<T, R1, R2, R3, R4, R5, R6, R7>( ...s: [Emitter<R1>, Emitter<R2>, Emitter<R3>, Emitter<R4>, Emitter<R5>, Emitter<R6>, Emitter<R7>]): Operator<T, [T, R1, R2, R3, R4, R5, R6, R7]> // prettier-ignore\nexport function withLatestFrom(...sources: Emitter<any>[]): Operator<any, any> {\n  const values = new Array(sources.length)\n  let called = 0\n  let pendingCall: null | (() => void) = null\n  const allCalled = Math.pow(2, sources.length) - 1\n\n  sources.forEach((source, index) => {\n    const bit = Math.pow(2, index)\n    subscribe(source, value => {\n      let prevCalled = called\n      called = called | bit\n      values[index] = value\n      if (prevCalled !== allCalled && called === allCalled && pendingCall) {\n        pendingCall()\n        pendingCall = null\n      }\n    })\n  })\n\n  return done => value => {\n    let call = () => done([value].concat(values))\n    if (called === allCalled) {\n      call()\n    } else {\n      pendingCall = call\n    }\n  }\n}\n","/**\n * Transformers change and combine streams, similar to operators.\n * urx comes with two combinators - [[combineLatest]] and [[merge]], and one convenience filter - [[duc]].\n *\n * @packageDocumentation\n */\nimport { Emitter, publish, reset, subscribe, Subscription } from './actions'\nimport { RESET, SUBSCRIBE } from './constants'\nimport { Comparator, defaultComparator, distinctUntilChanged, pipe } from './pipe'\nimport { stream } from './streams'\nimport { joinProc } from './utils'\n\n/**\n * Merges one or more emitters from the same type into a new Emitter which emits values from any of the source emitters.\n * ```ts\n * const foo = stream<number>()\n * const bar = stream<number>()\n *\n * subscribe(merge(foo, bar), (value) => console.log(value)) // 42, 43\n *\n * publish(foo, 42)\n * publish(bar, 43)\n * ```\n */\nexport function merge<T>(...sources: Emitter<T>[]): Emitter<T> {\n  return function(action: SUBSCRIBE | RESET, subscription?: Subscription<any>) {\n    switch (action) {\n      case SUBSCRIBE:\n        return joinProc(...sources.map(source => subscribe(source, subscription!)))\n      case RESET:\n        // do nothing, we are stateless\n        return\n      default:\n        throw new Error(`unrecognized action ${action}`)\n    }\n  } as Emitter<T>\n}\n\n/**\n * A convenience wrapper that emits only the distinct values from the passed Emitter. Wraps [[pipe]] and [[distinctUntilChanged]].\n *\n * ```ts\n * const foo = stream<number>()\n *\n * // this line...\n * const a = duc(foo)\n *\n * // is equivalent to this\n * const b = pipe(distinctUntilChanged(foo))\n * ```\n *\n * @param source The source emitter.\n * @param comparator optional custom comparison function for the two values.\n *\n * @typeParam T the type of the value emitted by the source.\n *\n * @returns the resulting emitter.\n */\nexport function duc<T>(source: Emitter<T>, comparator: Comparator<T> = defaultComparator): Emitter<T> {\n  return pipe(source, distinctUntilChanged(comparator))\n}\n\n/**\n * Creates an emitter with the latest values from all passed emitters as an array.\n *\n * `combineLatest` acts as a Depot. Using it on stateless streams persists the last emitted value of each [[Emitter]].\n * Provided that all emitters have emitted at least once, subscribing to the resulting emitter will immediately receive their combined latest values.\n *\n * ```ts\n * const foo = stream<number>()\n * const bar = stream<number>()\n *\n * subscribe(combineLatest(foo, bar), ([foo, bar]) => console.log({ foo, bar }))\n *\n * publish(foo, 42)\n * publish(bar, 43) // { foo: 42, bar: 43 }\n * publish(foo, 44) // { foo: 44, bar: 43 }\n * publish(bar, 45) // { foo: 44, bar: 45 }\n * ```\n */\nexport function combineLatest<O1, O2>(...emitters: [Emitter<O1>, Emitter<O2>]): Emitter<[O1, O2]> // prettier-ignore\nexport function combineLatest<O1, O2, O3>( ...emitters: [Emitter<O1>, Emitter<O2>, Emitter<O3>]): Emitter<[O1, O2, O3]> // prettier-ignore\nexport function combineLatest<O1, O2, O3, O4>( ...emitters: [Emitter<O1>, Emitter<O2>, Emitter<O3>, Emitter<O4>]): Emitter<[O1, O2, O3, O4]> // prettier-ignore\nexport function combineLatest<O1, O2, O3>( ...emitters: [Emitter<O1>, Emitter<O2>, Emitter<O3>]): Emitter<[O1, O2, O3]> // prettier-ignore\nexport function combineLatest<O1, O2, O3, O4, O5>( ...emitters: [Emitter<O1>, Emitter<O2>, Emitter<O3>, Emitter<O4>, Emitter<O5>]): Emitter<[O1, O2, O3, O4, O5]> // prettier-ignore\nexport function combineLatest<O1, O2, O3, O4, O5, O6>( ...emitters: [Emitter<O1>, Emitter<O2>, Emitter<O3>, Emitter<O4>, Emitter<O5>, Emitter<O6>]): Emitter<[O1, O2, O3, O4, O5, O6]> // prettier-ignore\nexport function combineLatest<O1, O2, O3, O4, O5, O6, O7>( ...emitters: [Emitter<O1>, Emitter<O2>, Emitter<O3>, Emitter<O4>, Emitter<O5>, Emitter<O6>, Emitter<O7>]): Emitter<[O1, O2, O3, O4, O5, O6, O7]> // prettier-ignore\nexport function combineLatest<O1, O2, O3, O4, O5, O6, O7, O8>( ...emitters: [Emitter<O1>, Emitter<O2>, Emitter<O3>, Emitter<O4>, Emitter<O5>, Emitter<O6>, Emitter<O7>, Emitter<O8>]): Emitter<[O1, O2, O3, O4, O5, O6, O7, O8]> // prettier-ignore\nexport function combineLatest<O1, O2, O3, O4, O5, O6, O7, O8, O9>( ...emitters: [Emitter<O1>, Emitter<O2>, Emitter<O3>, Emitter<O4>, Emitter<O5>, Emitter<O6>, Emitter<O7>, Emitter<O8>, Emitter<O9>]): Emitter<[O1, O2, O3, O4, O5, O6, O7, O8, O9]> // prettier-ignore\nexport function combineLatest<O1, O2, O3, O4, O5, O6, O7, O8, O9, O10>( ...emitters: [Emitter<O1>, Emitter<O2>, Emitter<O3>, Emitter<O4>, Emitter<O5>, Emitter<O6>, Emitter<O7>, Emitter<O8>, Emitter<O9>, Emitter<O10>]): Emitter<[O1, O2, O3, O4, O5, O6, O7, O8, O9, O10]> // prettier-ignore\nexport function combineLatest<O1, O2, O3, O4, O5, O6, O7, O8, O9, O10, O11>( ...emitters: [Emitter<O1>, Emitter<O2>, Emitter<O3>, Emitter<O4>, Emitter<O5>, Emitter<O6>, Emitter<O7>, Emitter<O8>, Emitter<O9>, Emitter<O10>, Emitter<O11>]): Emitter<[O1, O2, O3, O4, O5, O6, O7, O8, O9, O10, O11]> // prettier-ignore\nexport function combineLatest(...emitters: Emitter<any>[]): Emitter<any> {\n  let innerSubject = stream<any>()\n  const values = new Array(emitters.length)\n  let called = 0\n  const allCalled = Math.pow(2, emitters.length) - 1\n\n  emitters.forEach((source, index) => {\n    const bit = Math.pow(2, index)\n    subscribe(source, value => {\n      values[index] = value\n      called = called | bit\n      if (called === allCalled) {\n        publish(innerSubject, values)\n      }\n    })\n  })\n\n  return function(action: SUBSCRIBE | RESET, subscription?: Subscription<any>) {\n    switch (action) {\n      case SUBSCRIBE:\n        if (called === allCalled) {\n          subscription!(values)\n        }\n        return subscribe(innerSubject, subscription!)\n      case RESET:\n        return reset(innerSubject)\n      default:\n        throw new Error(`unrecognized action ${action}`)\n    }\n  } as Emitter<any>\n}\n","/**\n * ## Thinking in Systems\n * systems are a stateful **data-processing machines** which accept input through **input streams**,\n * init and maintain state in **depots** and, in certain conditions, emit values to subscriptions through **output streams**.\n * Systems can specify other systems as dependencies, and can act as singletons in the resulting dependency tree.\n *\n * ### Depots\n *\n * The first, and probably the most critical part to understand are **the depots**\n * mostly because they are somewhat implicit.\n * Unlike other state management paradigms, the depots are not kept in a single data structure.\n * Insted, depots are defined and maintained as stateful streams, stateful transfomers\n * like [[combineLatest]] or stateful operators like[ []withLatestFrom] or [[scan]].\n *\n * **Depots persist values over time**.\n * If it was not for them, the system had to re-receive its entire input state simultaneously in order to calculate the values for its output stream.\n *\n * Of course, strictly speaking, it is possible to implement a pure, stateless system as a form of a complex map/reduce. urx would not mind that ;).\n *\n * ### Input Streams\n *\n * The system receives updates from the rest of the world through values published in its input streams.\n * The streams used can be either stateless (acting as means to send **signals**) or stateful, where the initial stream state acts as the default value for that system parameter.\n *\n * The effects of the input streams are up to the system data-processing logic. It can change its depots' state, and/or emit values through its output streams.\n *\n * ### Data Processing\n *\n * The actual system behavior is exclusively implemented by **applying transformers and operators** to the input streams, producing the respective output streams.\n * In the final state the system streams are organized in a directed graph, where incoming data is routed through certain edges and nodes.\n * Simple systems like the one in [urx by example](https://urx.virtuoso.dev/docs/urx-by-example) can use a straightforward single-step transformation (in this case, `combineLatest` and `map`),\n * while complex ones can introduce multiple intermediate streams to model their logic.\n *\n * ### Output Streams\n *\n * The system publishes updates to its clients (other systems or an UI bound to it) by publishing data in its output streams.\n * State-reflecting output streams, like `sum` in the [urx by example](https://urx.virtuoso.dev/docs/urx-by-example) should use stateful streams as output streams.\n * Signal-like output should use regular, stateless streams. In general, stateless input streams tend to have a symmetrical stateless streams, and the opposite.\n *\n * @packageDocumentation\n */\nimport { Emitter } from './actions'\n\n/**\n * Systems are a dictionaries of streams. a [[SystemConstructor]] should return a System.\n */\nexport interface System {\n  [key: string]: Emitter<any>\n}\n\n/**\n * a SystemSpec is the result from a [[system]] call. To obtain the [[System]], pass the spec to [[init]].\n */\nexport interface SystemSpec<SS extends SystemSpecs, C extends SystemConstructor<SS>> {\n  id: string\n  constructor: C\n  dependencies: SS\n  singleton: boolean\n}\n\n/** @internal **/\nexport type AnySystemSpec = SystemSpec<any, any>\n\n/** @internal **/\nexport type SystemSpecs = AnySystemSpec[]\n\n/** @internal **/\nexport type SR<E extends AnySystemSpec, R extends System = ReturnType<E['constructor']>> = R\n\n/** @internal **/\nexport type SpecResults<SS extends SystemSpecs, L = SS['length']> = L extends 0\n  ? []\n  : L extends 1\n  ? [SR<SS[0]>]\n  : L extends 2\n  ? [SR<SS[0]>, SR<SS[1]>]\n  : L extends 3\n  ? [SR<SS[0]>, SR<SS[1]>, SR<SS[2]>]\n  : L extends 4\n  ? [SR<SS[0]>, SR<SS[1]>, SR<SS[2]>, SR<SS[3]>]\n  : L extends 5\n  ? [SR<SS[0]>, SR<SS[1]>, SR<SS[2]>, SR<SS[3]>, SR<SS[4]>]\n  : L extends 6\n  ? [SR<SS[0]>, SR<SS[1]>, SR<SS[2]>, SR<SS[3]>, SR<SS[4]>, SR<SS[5]>]\n  : L extends 7\n  ? [SR<SS[0]>, SR<SS[1]>, SR<SS[2]>, SR<SS[3]>, SR<SS[4]>, SR<SS[5]>, SR<SS[6]>]\n  : L extends 8\n  ? [SR<SS[0]>, SR<SS[1]>, SR<SS[2]>, SR<SS[3]>, SR<SS[4]>, SR<SS[5]>, SR<SS[6]>, SR<SS[7]>]\n  : L extends 9\n  ? [SR<SS[0]>, SR<SS[1]>, SR<SS[2]>, SR<SS[3]>, SR<SS[4]>, SR<SS[5]>, SR<SS[6]>, SR<SS[7]>, SR<SS[8]>]\n  : L extends 10\n  ? [SR<SS[0]>, SR<SS[1]>, SR<SS[2]>, SR<SS[3]>, SR<SS[4]>, SR<SS[5]>, SR<SS[6]>, SR<SS[7]>, SR<SS[8]>, SR<SS[9]>]\n  : L extends 11\n  ? [SR<SS[0]>, SR<SS[1]>, SR<SS[2]>, SR<SS[3]>, SR<SS[4]>, SR<SS[5]>, SR<SS[6]>, SR<SS[7]>, SR<SS[8]>, SR<SS[9]>, SR<SS[10]>]\n  : never\n\n/**\n * The system constructor is a function which initializes and connects streams and returns them as a [[System]].\n * If the [[system]] call specifies system dependencies, the constructor receives the dependencies as an array argument.\n */\nexport type SystemConstructor<D extends SystemSpecs> = (dependencies: SpecResults<D>) => System\n\n/**\n * `system` defines a specification of a system - its constructor, dependencies and if it should act as a singleton in a system dependency tree.\n * When called, system returns a [[SystemSpec]], which is then initialized along with its dependencies by passing it to [[init]].\n *\n * ```ts\n * @import { subscribe, publish, system, init, tup, connect, map, pipe } from 'urx'\n *\n * // a simple system with two streams\n * const sys1 = system(() => {\n *  const a = stream<number>()\n *  const b = stream<number>()\n *\n *  connect(pipe(a, map(value => value * 2)), b)\n *  return { a, b }\n * })\n *\n * // a second system which depends on the streams from the first one\n * const sys2 = system(([ {a, b} ]) => {\n *  const c = stream<number>()\n *  connect(pipe(b, map(value => value * 2)), c)\n *  // re-export the `a` stream, keep `b` internal\n *  return { a, c }\n * }, tup(sys1))\n *\n * // init will recursively initialize sys2 dependencies, in this case sys1\n * const { a, c } = init(sys2)\n * subscribe(c, c => console.log(`Value multiplied by 4`, c))\n * publish(a, 2)\n * ```\n *\n * #### Singletons in Dependency Tree\n *\n * By default, systems will be initialized only once if encountered multiple times in the dependency tree.\n * In the below dependency system tree, systems `b` and `c` will receive the same stream instances from system `a` when system `d` is initialized.\n * ```txt\n *   a\n *  / \\\n * b   c\n *  \\ /\n *   d\n * ```\n * If `a` gets `{singleton: false}` as a last argument, `init` creates two separate instances - one for `b` and one for `c`.\n *\n * @param constructor the system constructor function. Initialize and connect the streams in its body.\n *\n * @param dependencies the system dependencies, which the constructor will receive as arguments.\n * Use the [[tup]] utility **For TypeScript type inference to work correctly**.\n * ```ts\n * const sys3 = system(() => { ... }, tup(sys2, sys1))\n * ```\n * @param __namedParameters Options\n * @param singleton determines if the system will act as a singleton in a system dependency tree. `true` by default.\n */\nexport function system<F extends SystemConstructor<D>, D extends SystemSpecs>(\n  constructor: F,\n  dependencies: D = ([] as unknown) as D,\n  { singleton }: { singleton: boolean } = { singleton: true }\n): SystemSpec<D, F> {\n  return {\n    id: id(),\n    constructor,\n    dependencies,\n    singleton,\n  }\n}\n\n/** @internal */\nconst id = () => (Symbol() as unknown) as string\n\n/**\n * Initializes a [[SystemSpec]] by recursively initializing its dependencies.\n *\n * ```ts\n * // a simple system with two streams\n * const sys1 = system(() => {\n *  const a = stream<number>()\n *  const b = stream<number>()\n *\n *  connect(pipe(a, map(value => value * 2)), b)\n *  return { a, b }\n * })\n *\n * const { a, b } = init(sys1)\n * subscribe(b, b => console.log(b))\n * publish(a, 2)\n * ```\n *\n * @returns the [[System]] constructed by the spec constructor.\n * @param systemSpec the system spec to initialize.\n */\nexport function init<SS extends AnySystemSpec>(systemSpec: SS): SR<SS> {\n  const singletons = new Map<string, System>()\n  const _init = <SS extends AnySystemSpec>({ id, constructor, dependencies, singleton }: SS) => {\n    if (singleton && singletons.has(id)) {\n      return singletons.get(id)! as SR<SS>\n    }\n    const system = constructor(dependencies.map((e: AnySystemSpec) => _init(e)))\n    if (singleton) {\n      singletons.set(id, system)\n    }\n    return system as any\n  }\n  return _init(systemSpec)\n}\n"],"names":["PUBLISH","SUBSCRIBE","RESET","VALUE","compose","a","b","arg","thrush","proc","curry2to1","arg1","arg2","curry1to0","prop","property","object","tap","tup","args","call","always","value","joinProc","procs","map","noop","subscribe","emitter","subscription","publish","publisher","reset","getValue","depot","connect","handleNext","unsub","stream","subscriptions","action","splice","length","push","indexOf","slice","forEach","Error","statefulStream","initial","innerSubject","eventHandler","currentSubscription","cleanup","streamFromEmitter","statefulStreamFromEmitter","combineOperators","operators","subscriber","reduceRight","pipe","source","project","defaultComparator","previous","next","distinctUntilChanged","comparator","current","done","filter","predicate","mapTo","scan","scanner","skip","times","throttleTime","interval","currentValue","timeout","setTimeout","undefined","debounceTime","clearTimeout","withLatestFrom","sources","values","Array","called","pendingCall","allCalled","Math","pow","index","bit","prevCalled","concat","merge","duc","combineLatest","emitters","system","constructor","dependencies","singleton","id","Symbol","init","systemSpec","singletons","Map","_init","has","get","e","set"],"mappings":"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"}