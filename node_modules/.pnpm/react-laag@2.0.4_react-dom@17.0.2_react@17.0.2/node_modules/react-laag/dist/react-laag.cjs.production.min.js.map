{"version":3,"file":"react-laag.cjs.production.min.js","sources":["../src/hooks.ts","../src/util.ts","../src/useTrackElements.ts","../src/useGroup.ts","../src/PlacementType.ts","../src/Sides.ts","../src/BoundsOffsets.ts","../src/Bounds.ts","../src/Placement.ts","../src/getArrowStyle.ts","../src/Placements.ts","../src/SubjectsBounds.ts","../src/useLayer.ts","../src/Arrow.ts","../src/useHover.ts","../src/Transition.ts"],"sourcesContent":["import {\n  useRef,\n  useMemo,\n  useLayoutEffect,\n  useEffect,\n  MutableRefObject,\n  useState,\n  MouseEvent\n} from \"react\";\nimport { IBounds } from \"./Bounds\";\n\n/**\n * Utility hook to track the reference of a html-element.\n * It notifies the listener when a change occured, so it can act\n * on the change\n */\nexport function useTrackRef(\n  onRefChange: (element: HTMLElement) => void\n): (node: HTMLElement | null) => void {\n  const storedReference = useRef<HTMLElement | null>(null);\n\n  // this is de function that actually gets passed to the `ref` prop\n  // on the html element. I.e.:\n  // <div ref={setter} />\n  function setter(element: HTMLElement | null) {\n    if (!element || element === storedReference.current) {\n      return;\n    }\n\n    storedReference.current = element;\n    onRefChange(element);\n  }\n\n  return setter;\n}\n\n/**\n * Utility hook that stores mutable state.\n * Since a getter function is used, it will always return the most\n * up-to-date state. This is useful when you want to get certain state within\n * an effect, without triggering the same effect when the same state changes.\n * Note: may be seen as an anti-pattern.\n */\nexport function useMutableStore<State>(initialState: State): readonly [\n  () => State,\n  {\n    (setter: (state: State) => State): void;\n    (setter: State): void;\n  }\n] {\n  const state = useRef<State>(initialState);\n\n  return useMemo(() => {\n    function set(setter: (state: State) => State): void;\n    function set(setter: State): void;\n    function set(setter: any): void {\n      if (typeof setter === \"function\") {\n        state.current = setter(state.current);\n      } else {\n        state.current = setter;\n      }\n    }\n\n    function get() {\n      return state.current;\n    }\n\n    return [get, set] as const;\n  }, []);\n}\n\n/**\n * Utility hook that keeps track of active event listeners and how\n * to remove these listeners\n */\nexport function useEventSubscriptions() {\n  const subscriptions = useRef<Array<() => void>>([]);\n\n  return useMemo(() => {\n    function hasEventSubscriptions() {\n      return subscriptions.current.length > 0;\n    }\n\n    function removeAllEventSubscriptions() {\n      for (const unsubscribe of subscriptions.current!) {\n        unsubscribe();\n      }\n\n      subscriptions.current = [];\n    }\n\n    function addEventSubscription(unsubscriber: () => void) {\n      subscriptions.current.push(unsubscriber);\n    }\n\n    return {\n      hasEventSubscriptions,\n      removeAllEventSubscriptions,\n      addEventSubscription\n    };\n  }, []);\n}\n\n/**\n * SSR-safe effect hook\n */\nexport const useIsomorphicLayoutEffect =\n  typeof window !== \"undefined\" ? useLayoutEffect : useEffect;\n\n/**\n * Utility hook that tracks an state object.\n * If `enabled=false` it will discard changes and reset the lastState to `null`\n */\nexport function useLastState<T extends unknown>(\n  currentState: T,\n  enabled: boolean\n): MutableRefObject<T | null> {\n  const lastState = useRef<T | null>(currentState);\n\n  if (!enabled) {\n    lastState.current = null;\n    return lastState;\n  }\n\n  lastState.current = currentState;\n  return lastState;\n}\n\nexport type UseMousePositionAsTriggerOptions = {\n  /**\n   * @description Should the position be actively tracked?\n   * @default true\n   */\n  enabled?: boolean;\n  /**\n   * @description Should `handleMouseEvent` preventDefault()?\n   * @default true\n   */\n  preventDefault?: boolean;\n};\n\nexport type UseMousePositionAsTriggerProps = {\n  hasMousePosition: boolean;\n  resetMousePosition: () => void;\n  handleMouseEvent: (evt: MouseEvent) => void;\n  trigger: {\n    getBounds: () => IBounds;\n    getParent?: () => HTMLElement;\n  };\n  parentRef: MutableRefObject<any>;\n};\n\nconst EMPTY_BOUNDS: IBounds = {\n  top: 0,\n  left: 0,\n  right: 1,\n  bottom: 1,\n  width: 1,\n  height: 1\n};\n\n/**\n * @description Utility hook that lets you use the mouse-position as source of the trigger.\n * This is useful in scenario's like context-menu's.\n *\n * @example\n * ```tsx\n * const {\n *  hasMousePosition,\n *  resetMousePosition,\n *  handleMouseEvent,\n *  trigger\n *  } = useMousePositionAsTrigger();\n *\n * const { renderLayer, layerProps } = useLayer({\n *  isOpen: hasMousePosition,\n *  trigger,\n *  onOutsideClick: resetMousePosition\n * });\n *\n * return (\n *  <>\n *   {isOpen && renderLayer(<div {...layerProps} />)}\n *   <div onContextMenu={handleMouseEvent} />\n *  </>\n * );\n * ```\n */\nexport function useMousePositionAsTrigger({\n  enabled = true,\n  preventDefault = true\n}: UseMousePositionAsTriggerOptions = {}): UseMousePositionAsTriggerProps {\n  const parentRef = useRef<any>(null);\n\n  const [mouseBounds, setMouseBounds] = useState<IBounds>(EMPTY_BOUNDS);\n\n  function resetMousePosition() {\n    setMouseBounds(EMPTY_BOUNDS);\n  }\n\n  const hasMousePosition = mouseBounds !== EMPTY_BOUNDS;\n\n  function handleMouseEvent(evt: MouseEvent) {\n    if (!enabled) {\n      return;\n    }\n\n    if (preventDefault) {\n      evt.preventDefault();\n    }\n    const { clientX: left, clientY: top } = evt;\n    setMouseBounds({\n      top,\n      left,\n      width: 1,\n      height: 1,\n      right: left + 1,\n      bottom: top + 1\n    });\n  }\n\n  return {\n    hasMousePosition,\n    resetMousePosition,\n    handleMouseEvent,\n    trigger: {\n      getBounds: () => mouseBounds!,\n      getParent: parentRef.current ? () => parentRef.current : undefined\n    },\n    parentRef\n  };\n}\n","/**\n * Convert a pixel value into a numeric value\n * @param value string value (ie. '12px')\n */\nexport function getPixelValue(value: string) {\n  return parseFloat(value.replace(\"px\", \"\"));\n}\n\n/**\n * Returns a numeric value that doesn't exceed min or max\n */\nexport function limit(value: number, min: number, max: number): number {\n  return value < min ? min : value > max ? max : value;\n}\n\n/**\n * Utility function which ensures whether a value is truthy\n */\nexport function isSet<T>(value: T | null | undefined): value is T {\n  return value === null || value === undefined ? false : true;\n}\n\n/**\n * Utility function that let's you assign multiple references to a 'ref' prop\n * @param refs list of MutableRefObject's and / or callbacks\n */\nexport function mergeRefs(...refs: any[]) {\n  return (element: HTMLElement | null) => {\n    for (const ref of refs) {\n      if (!ref) {\n        continue;\n      }\n\n      if (typeof ref === \"function\") {\n        ref(element);\n      } else {\n        ref.current = element!;\n      }\n    }\n  };\n}\n","import { useCallback, useRef, useEffect } from \"react\";\nimport warning from \"tiny-warning\";\nimport { ResizeObserverClass, ScrollOffsets, BorderOffsets } from \"./types\";\nimport {\n  useTrackRef,\n  useMutableStore,\n  useEventSubscriptions,\n  useIsomorphicLayoutEffect\n} from \"./hooks\";\nimport { getPixelValue } from \"./util\";\nimport { IBounds } from \"./Bounds\";\n\n/**\n * Utility to get the correct ResizeObserver class\n */\nexport function getResizeObserver(\n  environment: Window | undefined,\n  polyfill: ResizeObserverClass | undefined\n): ResizeObserverClass | undefined {\n  if (typeof environment === \"undefined\") {\n    return undefined;\n  }\n\n  return polyfill || (environment as any).ResizeObserver;\n}\n\n/**\n * Utility function that given a element traverses up in the html-hierarchy\n * to find and return all ancestors that have scroll behavior\n */\nexport function findScrollContainers(\n  element: HTMLElement | null,\n  environment?: Window\n): HTMLElement[] {\n  const result: HTMLElement[] = [];\n\n  if (!element || !environment || element === document.body) {\n    return result;\n  }\n\n  const { overflow, overflowX, overflowY } =\n    environment.getComputedStyle(element);\n\n  if (\n    [overflow, overflowX, overflowY].some(prop =>\n      [\"auto\", \"scroll\"].includes(prop)\n    )\n  ) {\n    result.push(element);\n  }\n\n  return [\n    ...result,\n    ...findScrollContainers(element.parentElement, environment)\n  ];\n}\n\nfunction createReferenceError(subject: string) {\n  return `react-laag: Could not find a valid reference for the ${subject} element. There might be 2 causes:\n   - Make sure that the 'ref' is set correctly on the ${subject} element when isOpen: true. Also make sure your component forwards the ref with \"forwardRef()\".\n   - Make sure that you are actually rendering the ${subject} when the isOpen prop is set to true`;\n}\n\nexport type OnChangeElements = {\n  layer: HTMLElement;\n  trigger: HTMLElement;\n  arrow: HTMLElement | null;\n  scrollContainers: HTMLElement[];\n};\n\nexport type UseTrackElementsProps = {\n  enabled: boolean;\n  onChange: (\n    elements: OnChangeElements,\n    scrollOffsets: ScrollOffsets,\n    borderOffsets: BorderOffsets\n  ) => void;\n  environment: Window | undefined;\n  ResizeObserverPolyfill: ResizeObserverClass | undefined;\n  overflowContainer: boolean;\n  triggerOption?: {\n    getBounds: () => IBounds;\n    getParent?: () => HTMLElement;\n  };\n};\n\ntype UseTrackElementsReturnValue = {\n  triggerRef: (element: HTMLElement | null) => void;\n  layerRef: (element: HTMLElement | null) => void;\n  arrowRef: React.MutableRefObject<HTMLElement | null>;\n  closestScrollContainer: HTMLElement | null;\n};\n\n/**\n * This hook has the responsibility to track the bounds of:\n * - the trigger element\n * - the layer element\n * - the arrow element\n * - the scroll-containers of which the trigger element is a descendant of\n *\n * It will call the `onChange` callback with a collection of these elements when any\n * of the tracked elements bounds have changed\n *\n * It will detect these changes by listening:\n * - when the reference of the trigger element changes\n * - when the reference of the layer element changes\n * - when the trigger, layer or document body changes in size\n * - when the user scrolls the page, or any of the scroll containers\n */\nexport function useTrackElements({\n  // should we track the bounds?\n  enabled,\n  // call this callback when the bounds have changed\n  onChange,\n  // optional environment (i.e. when using iframes)\n  environment,\n  // optionally inject a polyfill when the browser does not support it\n  // out of the box\n  ResizeObserverPolyfill,\n  // behavior will alter slightly when `overflowContainer` is enabled\n  overflowContainer,\n  // the optional trigger-option provided by the user\n  triggerOption\n}: UseTrackElementsProps): UseTrackElementsReturnValue {\n  // get the correct reference to the ResizeObserver class\n  const ResizeObserver = getResizeObserver(environment, ResizeObserverPolyfill);\n\n  // warn the user when no valid ResizeObserver class could be found\n  useEffect(() => {\n    warning(\n      ResizeObserver,\n      `This browser does not support ResizeObserver out of the box. We recommend to add a polyfill in order to utilize the full capabilities of react-laag. See: https://github.com/everweij/react-laag#resize-observer`\n    );\n  }, [ResizeObserver]);\n\n  // keep reference of the optional arrow-component\n  const arrowRef = useRef<HTMLElement | null>(null);\n\n  // if user has provided the trigger-option we should ingore certain things elsewhere\n  const hasTriggerOption = Boolean(triggerOption);\n\n  // Keep track of mutable element related state\n  // It is generally better to use React.useState, but unfortunately that causes to many re-renders\n  const [get, set] = useMutableStore<{\n    scrollContainers: HTMLElement[];\n    trigger: HTMLElement | null;\n    layer: HTMLElement | null;\n  }>({\n    scrollContainers: [],\n    trigger: null,\n    layer: null\n  });\n\n  // utility to keep track of the scroll and resize listeners and how to unsubscribe them\n  const {\n    hasEventSubscriptions,\n    addEventSubscription,\n    removeAllEventSubscriptions\n  } = useEventSubscriptions();\n\n  // All scroll and resize changes eventually end up here, where the collection of bounds (subjectsBounds) is\n  // constructed in order to notifiy the `onBoundsChange` callback\n  const handleChange = useCallback(\n    function handleChange() {\n      const { layer, trigger, scrollContainers } = get();\n      const closestScrollContainer = scrollContainers[0];\n\n      if (!layer) {\n        throw new Error(createReferenceError(\"layer\"));\n      }\n      // ignore when user has provided the trigger-option\n      if (!trigger && !hasTriggerOption) {\n        throw new Error(createReferenceError(\"trigger\"));\n      }\n\n      let scrollOffsets: ScrollOffsets = { top: 0, left: 0 };\n      if (closestScrollContainer) {\n        const { scrollLeft, scrollTop } = closestScrollContainer;\n        scrollOffsets = {\n          top: scrollTop,\n          left: scrollLeft\n        };\n      } else {\n        const { scrollX, scrollY } = environment!;\n        scrollOffsets = {\n          top: scrollY,\n          left: scrollX\n        };\n      }\n\n      let borderOffsets: BorderOffsets = { left: 0, top: 0 };\n      if (closestScrollContainer) {\n        const { borderLeftWidth, borderTopWidth } =\n          environment!.getComputedStyle(closestScrollContainer);\n\n        borderOffsets = {\n          left: getPixelValue(borderLeftWidth) || 0,\n          top: getPixelValue(borderTopWidth) || 0\n        };\n      }\n\n      onChange(\n        {\n          layer,\n          trigger: trigger!,\n          scrollContainers,\n          arrow: arrowRef.current\n        },\n        scrollOffsets,\n        borderOffsets\n      );\n    },\n    [get, onChange, environment, arrowRef, hasTriggerOption]\n  );\n\n  // responsible for adding the scroll and resize listeners to the correct\n  // html elements\n  const addEventListeners = useCallback(\n    function addEventListeners() {\n      const { trigger, layer, scrollContainers } = get();\n\n      if (!layer) {\n        throw new Error(createReferenceError(\"layer\"));\n      }\n      if (!trigger && !hasTriggerOption) {\n        // ignore when user has provided the trigger-option\n        throw new Error(createReferenceError(\"trigger\"));\n      }\n\n      if (ResizeObserver) {\n        let ignoredInitialCall = false;\n        const observerCallback = () => {\n          if (!ignoredInitialCall) {\n            ignoredInitialCall = true;\n            return;\n          }\n\n          handleChange();\n        };\n\n        const observer = new ResizeObserver(observerCallback);\n        for (const element of [trigger, layer, document.body]) {\n          if (element) observer.observe(element);\n        }\n\n        addEventSubscription(() => {\n          for (const element of [trigger, layer, document.body]) {\n            if (element) observer.unobserve(element);\n          }\n          observer.disconnect();\n        });\n      }\n\n      const listenForScrollElements = [environment!, ...scrollContainers];\n      for (const element of listenForScrollElements) {\n        element.addEventListener(\"scroll\", handleChange);\n\n        addEventSubscription(() =>\n          element.removeEventListener(\"scroll\", handleChange)\n        );\n      }\n    },\n    [\n      get,\n      addEventSubscription,\n      handleChange,\n      environment,\n      ResizeObserver,\n      hasTriggerOption\n    ]\n  );\n\n  // when either the reference to the trigger or layer element changes\n  // we should reset the event listeners and trigger a `onChange`\n  const resetWhenReferenceChangedWhileTracking = useCallback(\n    (previous: HTMLElement | null, next: HTMLElement) => {\n      if (enabled && previous && previous !== next) {\n        removeAllEventSubscriptions();\n        addEventListeners();\n        handleChange();\n      }\n    },\n    [removeAllEventSubscriptions, addEventListeners, handleChange, enabled]\n  );\n\n  // Logic when reference to layer changes\n  const layerRef = useTrackRef(\n    useCallback(\n      layer => {\n        const { layer: previousLayer } = get();\n\n        // store new reference\n        set(state => ({\n          ...state,\n          layer\n        }));\n\n        // check if we should reset the event listeners\n        resetWhenReferenceChangedWhileTracking(previousLayer, layer);\n      },\n      [get, set, resetWhenReferenceChangedWhileTracking]\n    )\n  );\n\n  const getScrollContainers = useCallback(\n    function handleScrollContainers(element: HTMLElement) {\n      const scrollContainers = findScrollContainers(element, environment);\n\n      const closestScrollContainer = scrollContainers[0];\n\n      if (closestScrollContainer) {\n        // Check if we should warn the user about 'position: relative; stuff...'\n        const position = environment!.getComputedStyle(\n          closestScrollContainer\n        ).position;\n\n        const closestScrollContainerHasCorrectStyling =\n          [\"relative\", \"absolute\", \"fixed\"].includes(position) ||\n          overflowContainer;\n\n        if (!closestScrollContainerHasCorrectStyling) {\n          closestScrollContainer.style.position = \"relative\";\n        }\n\n        warning(\n          closestScrollContainerHasCorrectStyling,\n          `react-laag: Set the 'position' style of the nearest scroll-container to 'relative', 'absolute' or 'fixed', or set the 'overflowContainer' prop to true. This is needed in order to position the layer properly. Currently the scroll-container is positioned: \"${position}\". For now, \"position: relative;\" is added for you, but this behavior might be removed in the future. Visit https://react-laag.com/docs/#position-relative for more info.`\n        );\n      }\n      return scrollContainers;\n    },\n    [environment, overflowContainer]\n  );\n\n  // Logic when reference to trigger changes\n  // Note: this will have no effect when user provided the trigger-option\n  const triggerRef = useTrackRef(\n    useCallback(\n      trigger => {\n        // collect list of scroll containers\n        const scrollContainers = getScrollContainers(trigger);\n\n        const { trigger: previousTrigger } = get();\n\n        // store new references\n        set(state => ({\n          ...state,\n          trigger,\n          scrollContainers\n        }));\n\n        // check if we should reset the event listeners\n        resetWhenReferenceChangedWhileTracking(previousTrigger, trigger);\n      },\n      [get, set, resetWhenReferenceChangedWhileTracking, getScrollContainers]\n    )\n  );\n\n  // when user has provided the trigger-option, it monitors the optional parent-element\n  // in order to determine the scroll-containers\n  const triggerOptionParent = triggerOption?.getParent?.();\n  useIsomorphicLayoutEffect(() => {\n    if (!triggerOptionParent) {\n      return;\n    }\n    set(state => ({\n      ...state,\n      scrollContainers: getScrollContainers(triggerOptionParent)\n    }));\n  }, [triggerOptionParent, set, getScrollContainers]);\n\n  useIsomorphicLayoutEffect(() => {\n    if (enabled) {\n      // add event listeners if necessary\n      if (!hasEventSubscriptions()) {\n        addEventListeners();\n      }\n    }\n\n    return () => {\n      if (hasEventSubscriptions()) {\n        removeAllEventSubscriptions();\n      }\n    };\n  }, [\n    enabled,\n    hasEventSubscriptions,\n    addEventListeners,\n    removeAllEventSubscriptions\n  ]);\n\n  // run this effect after every render\n  useIsomorphicLayoutEffect(() => {\n    if (enabled) {\n      // eventually call `handleChange` with latest elements-refs\n      handleChange();\n    }\n  });\n\n  return {\n    triggerRef,\n    layerRef,\n    arrowRef,\n    closestScrollContainer: get().scrollContainers[0] || null\n  };\n}\n","import {\n  ReactNode,\n  createContext,\n  MutableRefObject,\n  useCallback,\n  useRef,\n  useContext,\n  useEffect,\n  createElement\n} from \"react\";\nimport warning from \"tiny-warning\";\n\ntype Registration = {\n  shouldCloseWhenClickedOutside: (event: MouseEvent) => boolean;\n  closeChild: () => void;\n};\n\ntype Registrations = Set<Registration>;\n\ntype RegisterFn = (registration: Registration) => () => void;\n\ntype GroupContextType = {} | RegisterFn;\n\nconst GroupContext = createContext({} as GroupContextType);\n\ntype GroupProviderProps = {\n  children: ReactNode;\n  registrations: MutableRefObject<Registrations>;\n};\n\n// Provider that wraps arround the layer in order to provide other useLayers\n// down in the hiearchy (child layers) with means to communicate with the parent.\n// This provider receives a `registrations` Set which can be used to add and\n// delete registrations.\nexport function GroupProvider({ children, registrations }: GroupProviderProps) {\n  // registration function that is used as 'context payload' for child layers\n  // to call. It returns a function to unregister.\n  const handleRegister = useCallback(\n    function register(registration: Registration) {\n      registrations.current.add(registration);\n\n      return () => registrations.current.delete(registration);\n    },\n    [registrations]\n  );\n\n  return createElement(\n    GroupContext.Provider,\n    { value: handleRegister },\n    children\n  );\n}\n\n// asks child layers if they would close given the documents click event\n// if there's one that signals not to close, return early (false)\nfunction getShouldCloseAccordingToChildren(\n  registrations: Registrations,\n  event: MouseEvent\n) {\n  for (const { shouldCloseWhenClickedOutside } of registrations) {\n    if (!shouldCloseWhenClickedOutside(event)) {\n      return false;\n    }\n  }\n\n  return true;\n}\n\ntype UseGroup = {\n  isOpen: boolean;\n  onOutsideClick?: () => void;\n  onParentClose?: () => void;\n};\n\n/**\n * Responsible for close behavior\n * When the `onOutsideClick` callback is provided by the user, it will listen for clicks\n * in the document, and tell whether the user clicked outside -> not on layer / trigger.\n * It keeps track of nested useLayers a.k.a child layers (`registrations` Set), through which\n * we can ask whether they `shouldCloseWhenClickedOutside`, or tell them to close.\n *\n * Behavior:\n * - `onOutsideClick` only works on the most outer parent, and not on children. The parent will ask\n *   the child layers whether they would close, and will handle accordingly. The parent may\n *   command the children to close indirectly with the help of `onParentClose`\n * - When the parent just was closed, it will make sure that any children will also close\n *   with the help of `onParentClose`\n */\nexport function useGroup({ isOpen, onOutsideClick, onParentClose }: UseGroup) {\n  // store references to the dom-elements\n  // we need these to later determine wether the clicked outside or not\n  const trigger = useRef<HTMLElement>(null!);\n  const layer = useRef<HTMLElement>(null!);\n\n  // a Set which keeps track of callbacks given by the child layers through context\n  const registrations = useRef<Registrations>(new Set());\n\n  // if this instance is a child itself, we should use this function to register\n  // some callbacks to the parent\n  const possibleRegisterFn = useContext(GroupContext);\n\n  // recursively checks whether to close or not. This mechanism has some similarities\n  // with event bubbling.\n  const shouldCloseWhenClickedOutside = useCallback(\n    function shouldCloseWhenClickedOutside(event: MouseEvent) {\n      const target = event.target as HTMLElement;\n\n      const clickedOnTrigger =\n        trigger.current && trigger.current.contains(target);\n      const clickedOnLayer = layer.current && layer.current.contains(target);\n\n      const shouldCloseAccordingToChildren = getShouldCloseAccordingToChildren(\n        registrations.current,\n        event\n      );\n\n      // when clicked on own layer, but the child would have closed ->\n      // let child close\n      if (clickedOnLayer && shouldCloseAccordingToChildren) {\n        registrations.current.forEach(({ closeChild }) => closeChild());\n      }\n\n      return (\n        !clickedOnTrigger && !clickedOnLayer && shouldCloseAccordingToChildren\n      );\n    },\n    [trigger, layer, registrations]\n  );\n\n  // registration stuff\n  useEffect(() => {\n    if (typeof possibleRegisterFn !== \"function\") {\n      return;\n    }\n\n    // 'possibleRegisterFn' will return a function that will unregister\n    // on cleanup\n    return possibleRegisterFn({\n      shouldCloseWhenClickedOutside,\n      closeChild: () => {\n        warning(\n          onParentClose,\n          `react-laag: You are using useLayer() in a nested setting but forgot to set the 'onParentClose()' callback in the options. This could lead to unexpected behavior.`\n        );\n\n        if (onParentClose) {\n          onParentClose();\n        }\n      }\n    });\n  }, [\n    possibleRegisterFn,\n    shouldCloseWhenClickedOutside,\n    onParentClose,\n    registrations\n  ]);\n\n  // document click handling\n  useEffect(() => {\n    const isChild = typeof possibleRegisterFn === \"function\";\n    const shouldNotListen = !isOpen || !onOutsideClick || isChild;\n    if (shouldNotListen) {\n      return;\n    }\n\n    function handleClick(event: MouseEvent) {\n      if (shouldCloseWhenClickedOutside(event)) {\n        onOutsideClick!();\n      }\n    }\n\n    document.addEventListener(\"click\", handleClick, true);\n    return () => document.removeEventListener(\"click\", handleClick, true);\n  }, [\n    isOpen,\n    onOutsideClick,\n    shouldCloseWhenClickedOutside,\n    possibleRegisterFn\n  ]);\n\n  // When this 'useLayer' gets closed -> tell child layers to close as well\n  useEffect(() => {\n    if (!isOpen) {\n      registrations.current.forEach(({ closeChild }) => closeChild());\n    }\n  }, [isOpen]);\n\n  return {\n    closeOnOutsideClickRefs: {\n      trigger,\n      layer\n    },\n    registrations\n  };\n}\n","export const PLACEMENT_TYPES: PlacementType[] = [\n  \"bottom-start\",\n  \"bottom-end\",\n  \"bottom-center\",\n  \"top-start\",\n  \"top-center\",\n  \"top-end\",\n  \"left-end\",\n  \"left-center\",\n  \"left-start\",\n  \"right-end\",\n  \"right-center\",\n  \"right-start\",\n  \"center\"\n];\n\nexport type PlacementType =\n  | \"bottom-start\"\n  | \"bottom-end\"\n  | \"bottom-center\"\n  | \"top-start\"\n  | \"top-center\"\n  | \"top-end\"\n  | \"left-end\"\n  | \"left-center\"\n  | \"left-start\"\n  | \"right-end\"\n  | \"right-center\"\n  | \"right-start\"\n  | \"center\";\n","export type BoundSideProp = \"top\" | \"left\" | \"bottom\" | \"right\";\nexport type SideProp = BoundSideProp | \"center\";\ntype SizeProp = \"width\" | \"height\";\ntype CssProp = \"top\" | \"left\";\n\nconst OPPOSITES: Record<SideProp, SideProp> = {\n  top: \"bottom\",\n  left: \"right\",\n  bottom: \"top\",\n  right: \"left\",\n  center: \"center\"\n};\n\nclass SideBase<T extends SideProp> {\n  constructor(\n    readonly prop: T,\n    readonly opposite: SideBase<T>,\n    readonly isHorizontal: boolean,\n    readonly sizeProp: SizeProp,\n    readonly oppositeSizeProp: SizeProp,\n    readonly cssProp: CssProp,\n    readonly oppositeCssProp: CssProp,\n    readonly isCenter: boolean,\n    readonly isPush: boolean // left | top\n  ) {}\n\n  factor(value: number) {\n    return value * (this.isPush ? 1 : -1);\n  }\n\n  isOppositeDirection(side: SideBase<any>) {\n    return this.isHorizontal !== side.isHorizontal;\n  }\n}\n\nfunction createSide<T extends SideProp>(\n  prop: T,\n  recursive = true\n): SideBase<T> {\n  const isHorizontal = [\"left\", \"right\"].includes(prop);\n\n  return new SideBase<T>(\n    prop,\n    recursive ? createSide<T>((OPPOSITES as any)[prop], false) : null!,\n    isHorizontal,\n    isHorizontal ? \"width\" : \"height\",\n    isHorizontal ? \"height\" : \"width\",\n    isHorizontal ? \"left\" : \"top\",\n    isHorizontal ? \"top\" : \"left\",\n    prop === \"center\",\n    ![\"right\", \"bottom\"].includes(prop)\n  );\n}\n\nexport type BoundSideType = SideBase<BoundSideProp>;\nexport type SideType = SideBase<SideProp>;\n\nexport const BoundSide = {\n  top: createSide(\"top\") as BoundSideType,\n  bottom: createSide(\"bottom\") as BoundSideType,\n  left: createSide(\"left\") as BoundSideType,\n  right: createSide(\"right\") as BoundSideType\n};\n\nexport const Side = {\n  ...(BoundSide as {\n    top: SideType;\n    left: SideType;\n    bottom: SideType;\n    right: SideType;\n  }),\n  center: createSide(\"center\")\n};\n","export interface IBoundsOffsets {\n  top: number;\n  left: number;\n  right: number;\n  bottom: number;\n}\n\nconst SIDES = [\"top\", \"left\", \"bottom\", \"right\"] as (keyof IBoundsOffsets)[];\n\n/**\n * A class containing the positional properties which represent the distance\n * between two Bounds instances for each side\n */\nexport class BoundsOffsets implements IBoundsOffsets {\n  top!: number;\n  left!: number;\n  right!: number;\n  bottom!: number;\n\n  constructor(offsets: IBoundsOffsets) {\n    return Object.assign(this, offsets);\n  }\n\n  /**\n   * Takes multiple BoundsOffets instances and creates a new BoundsOffsets instance\n   * by taking the smallest value for each side\n   * @param boundsOffsets list of BoundsOffsets instances\n   */\n  static mergeSmallestSides(boundsOffsets: BoundsOffsets[]): BoundsOffsets {\n    const [first, ...rest] = boundsOffsets;\n\n    if (!first) {\n      throw new Error(\n        \"Please provide at least 1 bounds objects in order to merge\"\n      );\n    }\n\n    const result: IBoundsOffsets = Object.fromEntries(\n      SIDES.map(side => [side, first[side]])\n    ) as any;\n\n    for (const boundsOffset of rest) {\n      for (const side of SIDES) {\n        result[side] = Math.min(result[side], boundsOffset[side]);\n      }\n    }\n\n    return new BoundsOffsets(result);\n  }\n\n  /**\n   * Checks whether all sides sides are positive, meaning the corresponding Bounds instance\n   * fits perfectly within a parent Bounds instance\n   */\n  get allSidesArePositive(): boolean {\n    return SIDES.every(side => this[side] >= 0);\n  }\n\n  /**\n   * Returns a partial IBoundsOffsets with sides that are negative, meaning sides aren't entirely\n   * visible in respect to a parent Bounds instance\n   */\n  get negativeSides(): Partial<IBoundsOffsets> {\n    return Object.fromEntries(\n      SIDES.filter(side => this[side] < 0).map(side => [side, this[side]])\n    ) as Partial<IBoundsOffsets>;\n  }\n}\n","import { BoundSide, BoundSideProp, BoundSideType } from \"./Sides\";\nimport { BoundsOffsets } from \"./BoundsOffsets\";\nimport { getPixelValue } from \"./util\";\n\n/**\n * Utility function that returns sum of various computed styles\n * @param propertyValues list of computed styles (ie. '12px')\n */\nfunction sumOfPropertyValues(...propertyValues: string[]) {\n  return propertyValues.reduce(\n    (sum, propertyValue) =>\n      sum + (propertyValue ? getPixelValue(propertyValue!) : 0),\n    0\n  );\n}\n\nexport interface IBounds {\n  top: number;\n  left: number;\n  right: number;\n  bottom: number;\n  width: number;\n  height: number;\n}\n\nexport function boundsToObject({\n  top,\n  left,\n  right,\n  bottom,\n  width,\n  height\n}: IBounds): IBounds {\n  return { top, left, right, bottom, width, height };\n}\n\nconst EMPTY: IBounds = {\n  top: 0,\n  left: 0,\n  right: 0,\n  bottom: 0,\n  width: 0,\n  height: 0\n};\n\n/**\n * A class containing the positional properties of the native DOM's ClientRect\n * (`element.getBoundingClientRect()`), together with some utility methods\n */\nexport class Bounds implements IBounds {\n  top!: number;\n  left!: number;\n  right!: number;\n  bottom!: number;\n  width!: number;\n  height!: number;\n\n  /**\n   * Creates a new Bounds class\n   * @param bounds An object that adheres to the `IBounds` interface\n   */\n  static create(bounds: IBounds): Bounds {\n    return new Bounds(bounds);\n  }\n\n  /**\n   * Creates a new Bounds class from a DOM-element\n   * @param element reference to the DOM-element\n   * @param options optional options object\n   */\n  static fromElement(\n    element: HTMLElement,\n    options: {\n      /** should transforms like 'scale' taken into account? Defaults to `true` */\n      withTransform?: boolean;\n      /** reference to the window-object (needed when working with iframes for instance). Defaults to `window` */\n      environment?: Window;\n      /** should the elements scrollbars be included? Defaults to `true` */\n      withScrollbars?: boolean;\n    } = {}\n  ): Bounds {\n    const {\n      withTransform = true,\n      environment = window,\n      withScrollbars = true\n    } = options;\n\n    const plain: IBounds = boundsToObject(element.getBoundingClientRect());\n\n    let bounds: Bounds = new Bounds(plain);\n\n    if (!withTransform) {\n      const {\n        width,\n        height,\n        boxSizing,\n        borderLeft,\n        borderRight,\n        borderTop,\n        borderBottom,\n        paddingLeft,\n        paddingRight,\n        paddingTop,\n        paddingBottom\n      } = environment.getComputedStyle(element);\n\n      const boxWidth =\n        boxSizing === \"border-box\"\n          ? getPixelValue(width!)\n          : sumOfPropertyValues(\n              width,\n              borderLeft,\n              borderRight,\n              paddingLeft,\n              paddingRight\n            );\n\n      const boxHeight =\n        boxSizing === \"border-box\"\n          ? getPixelValue(height!)\n          : sumOfPropertyValues(\n              height,\n              borderTop,\n              borderBottom,\n              paddingTop,\n              paddingBottom\n            );\n\n      bounds = new Bounds({\n        ...bounds,\n        width: boxWidth,\n        height: boxHeight\n      });\n    }\n\n    if (!withScrollbars) {\n      const scrollbarWidth = bounds.width - element.clientWidth;\n      const scrollbarHeight = bounds.height - element.clientHeight;\n      return bounds.substract({\n        right: scrollbarWidth,\n        bottom: scrollbarHeight\n      });\n    }\n\n    return bounds;\n  }\n\n  /**\n   * Creates an empty Bounds class\n   */\n  static empty(): Bounds {\n    return new Bounds();\n  }\n\n  /**\n   * Creates a Bounds class from the window's dimensions\n   * @param environment reference to the window-object (needed when working with iframes for instance). Defaults to `window`\n   */\n  static fromWindow(environment?: Window): Bounds {\n    const scrollingElement =\n      environment?.document.scrollingElement ??\n      environment?.document.documentElement;\n    const { clientWidth: width = 0, clientHeight: height = 0 } =\n      scrollingElement ?? {};\n\n    return new Bounds({ width, height, right: width, bottom: height });\n  }\n\n  protected constructor(bounds: Partial<IBounds> = {}) {\n    return Object.assign(this, EMPTY, bounds);\n  }\n\n  /**\n   * Returns the square surface of the bounds in pixels\n   */\n  get surface(): number {\n    return this.width * this.height;\n  }\n\n  /**\n   * Returns a plain object containing only positional properties\n   */\n  toObject(): IBounds {\n    return boundsToObject(this);\n  }\n\n  /**\n   * Returns a new Bounds instance by merging two bounds\n   * @param bounds partial bounds which should be merged\n   */\n  merge(bounds: Partial<IBounds>): Bounds;\n  /**\n   * Returns a new Bounds instance by merging two bounds\n   * @param mergeFn callback which takes the current bounds and returns new merged bounds\n   */\n  merge(mergeFn: (current: IBounds) => Partial<IBounds>): Bounds;\n  merge(partialBoundsOrMergeFn: unknown): Bounds {\n    const current = this.toObject();\n    return new Bounds({\n      ...current,\n      ...(typeof partialBoundsOrMergeFn === \"function\"\n        ? partialBoundsOrMergeFn(current)\n        : partialBoundsOrMergeFn)\n    });\n  }\n\n  /**\n   * Return a new Bounds instance by subtracting each property of the provided IBounds object\n   * @param bounds partial IBounds object to substract with\n   */\n  substract(bounds: Partial<IBounds>): Bounds {\n    const result = this.toObject();\n\n    const entries = Object.entries(bounds) as [keyof IBounds, number][];\n\n    for (const [prop, value] of entries) {\n      if (prop in BoundSide) {\n        // if `prop` is one of 'top', 'left', 'bottom' or 'right'...\n        const boundSide = BoundSide[prop as BoundSideProp];\n        // decide if we should add or substract\n        result[prop] += boundSide.factor(value);\n        // make sure that the size-properties are also updated\n        result[boundSide.isHorizontal ? \"width\" : \"height\"] -= value;\n      } else {\n        // prop is 'width' or 'height'\n        result[prop] -= value || 0;\n      }\n    }\n\n    return new Bounds(result);\n  }\n\n  /**\n   * Returns a new BoundsOffsets instance by determining the distance for each bound-side:\n   * (child -> parent)\n   * @param child child bounds instance\n   */\n  offsetsTo(child: Bounds): BoundsOffsets {\n    return new BoundsOffsets({\n      top: child.top - this.top,\n      bottom: this.bottom - child.bottom,\n      left: child.left - this.left,\n      right: this.right - child.right\n    });\n  }\n\n  /**\n   * Return a new Bounds instance by mapping over each bound-side\n   * @param mapper callback that takes a boundSide + value in pixels, returning a new value for that side\n   */\n  mapSides(\n    mapper: (boundSide: BoundSideType, value: number) => number\n  ): Bounds {\n    const result = this.toObject();\n    const boundSides = Object.values(BoundSide) as BoundSideType[];\n    for (const boundSide of boundSides) {\n      result[boundSide.prop] = mapper(boundSide, result[boundSide.prop]);\n    }\n    return new Bounds(result);\n  }\n}\n","import { BoundSideType, SideType, BoundSide, BoundSideProp } from \"./Sides\";\nimport { PlacementType } from \"./PlacementType\";\nimport { SubjectsBounds } from \"./SubjectsBounds\";\nimport { PositionConfig, Offsets } from \"./types\";\nimport { Bounds, IBounds } from \"./Bounds\";\nimport { BoundsOffsets } from \"./BoundsOffsets\";\nimport { limit } from \"./util\";\n\n/**\n * Class for various calculations based on a placement-type. I.e 'top-left';\n */\nexport class Placement {\n  protected subjectsBounds!: SubjectsBounds;\n  private _cachedLayerBounds: Bounds | null = null;\n  private _cachedContainerOffsets: BoundsOffsets | null = null;\n\n  constructor(\n    public readonly primary: SideType,\n    public readonly secondary: SideType,\n    subjectBounds: SubjectsBounds,\n    layerDimensions: PositionConfig[\"layerDimensions\"],\n    private readonly offsets: Offsets\n  ) {\n    this.setSubjectsBounds(subjectBounds, layerDimensions);\n  }\n\n  /**\n   * Set subjectsBounds that are specific for this placement\n   * @param subjectBounds original SubjectBounds instance\n   * @param layerDimensions possible config prodvided by the user\n   */\n  private setSubjectsBounds(\n    subjectBounds: SubjectsBounds,\n    layerDimensions: PositionConfig[\"layerDimensions\"]\n  ): void {\n    // if user did not provide any layerDimensions config...\n    if (!layerDimensions) {\n      this.subjectsBounds = subjectBounds;\n      return;\n    }\n\n    // get anticipated layer-dimensions provided by the user\n    const dimensions =\n      // if the user passed a callback, call it with the layerSide corresponding to\n      // the placement\n      typeof layerDimensions === \"function\"\n        ? layerDimensions(this.primary.prop)\n        : layerDimensions;\n\n    // create new SubjectsBounds instance by merging our newly create layer-bounds\n    this.subjectsBounds = subjectBounds.merge({\n      layer: {\n        ...subjectBounds.layer,\n        ...dimensions\n      }\n    });\n  }\n\n  /**\n   * Returns the string respresentation of this placement (ie. 'top-start')\n   */\n  public get type(): PlacementType {\n    return `${this.primary.prop}-${\n      this.secondary.prop === \"center\"\n        ? \"center\"\n        : [\"bottom\", \"right\"].includes(this.secondary.prop)\n        ? \"end\"\n        : \"start\"\n    }` as PlacementType;\n  }\n\n  /**\n   * Calculates the actual boundaries based on the placement\n   * @param secondaryOffset optional offset on the secondary-side\n   */\n  public getLayerBounds(secondaryOffset = 0): Bounds {\n    // return cached version if possible\n    if (this._cachedLayerBounds && secondaryOffset === 0) {\n      return this._cachedLayerBounds;\n    }\n\n    const { primary, secondary, subjectsBounds } = this;\n    const { trigger, layer, arrow } = subjectsBounds;\n    const { isHorizontal, oppositeCssProp, oppositeSizeProp, prop, opposite } =\n      primary as BoundSideType;\n\n    const result = Bounds.empty() as IBounds;\n\n    // let's take the placement 'top-start' as an example...\n    // the offsets are the following:\n    // trigger -> 8px\n    // container -> 10px;\n    // arrow -> 2px;\n\n    // PRIMARY STUFF\n\n    // bottom = trigger.top + 8;\n    result[opposite.prop] =\n      trigger[prop] - primary.factor(this.offsets.trigger);\n\n    // top = bottom - layer.height\n    result[prop] =\n      result[opposite.prop] - primary.factor(layer[primary.sizeProp]);\n\n    // SECONDARY STUFF\n\n    // arrowOffsetBase = 4\n    const arrowOffsetBase = this.offsets.arrow * 2;\n\n    // limitMin = trigger.left - (layer.width - arrow.width) + 4\n    let limitMin =\n      trigger[oppositeCssProp] -\n      (layer[oppositeSizeProp] - arrow[oppositeSizeProp]) +\n      arrowOffsetBase;\n    // limitMax = trigger.left + (trigger.width - arrow.width) - 4\n    let limitMax =\n      trigger[oppositeCssProp] +\n      (trigger[oppositeSizeProp] - arrow[oppositeSizeProp]) -\n      arrowOffsetBase;\n\n    if (!secondary.isPush) {\n      // if secondary is bottom or right -> add the width or height of the layer\n      limitMin += layer[oppositeSizeProp];\n      limitMax += layer[oppositeSizeProp];\n    }\n\n    if (secondary.isCenter) {\n      const propertyA = (isHorizontal ? BoundSide.top : BoundSide.left).prop;\n      const propertyB = (isHorizontal ? BoundSide.bottom : BoundSide.right)\n        .prop;\n\n      // left = limit(\n      //   trigger.left + trigger.width / 2 - layer.width / 2 + secondaryOffset,\n      //   limitMin,\n      //   limitMax\n      // )\n      result[propertyA] = limit(\n        trigger[propertyA] +\n          trigger[oppositeSizeProp] / 2 -\n          layer[oppositeSizeProp] / 2 +\n          secondaryOffset,\n        limitMin,\n        limitMax\n      );\n\n      // right = left + layer.width\n      result[propertyB] = result[propertyA] + layer[oppositeSizeProp];\n    } else {\n      const sec = secondary as BoundSideType;\n\n      const triggerValue = trigger[sec.prop];\n\n      // Under some conditions, when the layer is not able to align with the trigger\n      // due to arrow-size and arrow-offsets, we need to compensate.\n      // Otherwise, the secondary-offset will have no impact\n      const arrowCompensation =\n        triggerValue < limitMin\n          ? limitMin - triggerValue\n          : triggerValue > limitMax\n          ? limitMax - triggerValue\n          : 0;\n\n      // left = limit(\n      //   trigger.left + secondaryOffset + arrowCompensation,\n      //   limitMin,\n      //   limitMax\n      // )\n      result[sec.prop] = limit(\n        triggerValue + secondaryOffset + arrowCompensation,\n        limitMin,\n        limitMax\n      );\n\n      // right = left + layer.width\n      result[sec.opposite.prop] =\n        result[sec.prop] + secondary.factor(layer[oppositeSizeProp]);\n    }\n\n    // set the correct dimensions\n    result.width = result.right - result.left;\n    result.height = result.bottom - result.top;\n\n    // create new bounds object\n    const layerBounds = Bounds.create(result);\n\n    if (secondaryOffset === 0) {\n      this._cachedLayerBounds = layerBounds;\n    }\n\n    return layerBounds;\n  }\n\n  /**\n   * Checks whether the trigger is bigger on the opposite side\n   * ie. placement \"top-start\" -> has trigger a bigger width?\n   */\n  public get triggerIsBigger() {\n    const { isHorizontal } = this.secondary;\n    const { triggerHasBiggerWidth, triggerHasBiggerHeight } =\n      this.subjectsBounds;\n\n    return (\n      (isHorizontal && triggerHasBiggerWidth) ||\n      (!isHorizontal && triggerHasBiggerHeight)\n    );\n  }\n\n  /**\n   * Checks whether the placement fits within all it's container (including container-offset)\n   */\n  public get fitsContainer(): boolean {\n    return this.getContainerOffsets().allSidesArePositive;\n  }\n\n  /**\n   * Returns the surface in square pixels of the visible part of the layer\n   */\n  public get visibleSurface(): number {\n    const layerBounds = this.getLayerBounds();\n    const containerOffsets = this.getContainerOffsets(layerBounds);\n\n    const substract = containerOffsets.negativeSides;\n    for (const side in substract) {\n      // @ts-ignore\n      substract[side] = -substract[side]; // make positive for substraction;\n    }\n\n    return layerBounds.substract(substract).surface;\n  }\n\n  /**\n   * Returns a BoundSide by looking at the most negative offset that is the opposite direction\n   */\n  public get secondaryOffsetSide(): BoundSideType | null {\n    // Given placement 'top-start' and containerOffsets { left: -20, top: -10, right: -10, bottom: 200 }...\n    // the only negative offsets on the opposite side are { left: -20, right: -10 }\n    // since we have to return only 1 side, we pick the most negative, which is 'left'\n\n    const containerOffsets = this.getContainerOffsets();\n\n    const [mostNegativeSide] =\n      Object.entries(containerOffsets.negativeSides)\n        .map(\n          ([side, value]) => [BoundSide[side as BoundSideProp], value] as const\n        )\n        .filter(([side]) => this.primary.isOppositeDirection(side))\n        .sort(([, a], [, b]) => b! - a!)?.[0] ?? [];\n\n    return mostNegativeSide || null;\n  }\n\n  /**\n   * returns getLayerBounds(), including container-offsets\n   */\n  private getLayerCollisionBounds(): Bounds {\n    const { container } = this.offsets;\n\n    return this.getLayerBounds()\n      .mapSides((side, value) => (value -= side.factor(container)))\n      .merge(({ width, height }) => ({\n        width: width + container * 2,\n        height: height + container * 2\n      }));\n  }\n\n  /**\n   * Returns a BoundsOffsets instance containing merged offsets to containers with the most\n   * negative scenario\n   */\n  public getContainerOffsets(layerBounds?: Bounds): BoundsOffsets {\n    if (this._cachedContainerOffsets && !layerBounds) {\n      return this._cachedContainerOffsets;\n    }\n\n    const subjectBounds = this.subjectsBounds.merge({\n      layer: layerBounds || this.getLayerCollisionBounds()\n    });\n\n    const offsets = BoundsOffsets.mergeSmallestSides(\n      subjectBounds.layerOffsetsToScrollContainers\n    );\n\n    if (!layerBounds) {\n      this._cachedContainerOffsets = offsets;\n    }\n\n    return offsets;\n  }\n}\n\nexport class PlacementCenter extends Placement {\n  getLayerBounds(): Bounds {\n    const { trigger, layer } = this.subjectsBounds;\n\n    const result = Bounds.empty() as IBounds;\n\n    result.top = trigger.top + trigger.height / 2 - layer.height / 2;\n    result.bottom = result.top + layer.height;\n    result.left = trigger.left + trigger.width / 2 - layer.width / 2;\n    result.right = result.left + layer.width;\n    result.width = result.right - result.left;\n    result.height = result.bottom - result.top;\n\n    return result as Bounds;\n  }\n}\n","import { limit } from \"./util\";\nimport { SubjectsBounds } from \"./SubjectsBounds\";\nimport { Placement } from \"./Placement\";\n\n// how much pixels is the center of layer removed from edge of trigger?\nfunction getNegativeOffsetBetweenLayerCenterAndTrigger(\n  subjectsBounds: SubjectsBounds,\n  placement: Placement,\n  arrowOffset: number\n) {\n  const { layer, trigger, arrow } = subjectsBounds;\n\n  const sizeProperty = placement.primary.oppositeSizeProp;\n\n  const [sideA, sideB] = !placement.primary.isHorizontal\n    ? ([\"left\", \"right\"] as const)\n    : ([\"top\", \"bottom\"] as const);\n\n  const offsetA =\n    layer[sideA] +\n    layer[sizeProperty] / 2 -\n    trigger[sideA] -\n    arrow[sizeProperty] / 2 -\n    arrowOffset;\n  const offsetB =\n    layer[sideB] -\n    layer[sizeProperty] / 2 -\n    trigger[sideB] +\n    arrow[sizeProperty] / 2 +\n    arrowOffset;\n\n  return (offsetA < 0 ? -offsetA : 0) + (offsetB > 0 ? -offsetB : 0);\n}\n\nconst STYLE_BASE: React.CSSProperties = {\n  position: \"absolute\",\n  willChange: \"top, left\",\n  left: null!,\n  right: null!,\n  top: null!,\n  bottom: null!\n};\n\nexport function getArrowStyle(\n  subjectsBounds: SubjectsBounds,\n  placement: Placement,\n  arrowOffset: number\n): React.CSSProperties {\n  if (placement.primary.isCenter) {\n    return STYLE_BASE;\n  }\n\n  const { layer, trigger, arrow } = subjectsBounds;\n\n  const sizeProperty = placement.primary.oppositeSizeProp;\n  const triggerIsBigger = trigger[sizeProperty] > layer[sizeProperty];\n\n  const min = arrowOffset + arrow[sizeProperty] / 2;\n  const max = layer[sizeProperty] - arrow[sizeProperty] / 2 - arrowOffset;\n\n  const negativeOffset = getNegativeOffsetBetweenLayerCenterAndTrigger(\n    subjectsBounds,\n    placement,\n    arrowOffset\n  );\n\n  const primarySide = placement.primary.prop;\n  const secondarySide = placement.primary.oppositeCssProp;\n\n  const secondaryValue = triggerIsBigger\n    ? layer[sizeProperty] / 2 + negativeOffset\n    : trigger[secondarySide] + trigger[sizeProperty] / 2 - layer[secondarySide];\n\n  return {\n    ...STYLE_BASE,\n    [primarySide]: \"100%\",\n    [secondarySide]: limit(secondaryValue, min, max)\n  };\n}\n","import { CSSProperties } from \"react\";\nimport {\n  BoundSide,\n  Side,\n  BoundSideType,\n  SideType,\n  BoundSideProp,\n  SideProp\n} from \"./Sides\";\nimport { PlacementType } from \"./PlacementType\";\nimport { Placement, PlacementCenter } from \"./Placement\";\nimport { SubjectsBounds } from \"./SubjectsBounds\";\nimport {\n  PositionConfig,\n  Offsets,\n  ScrollOffsets,\n  BorderOffsets,\n  DisappearType,\n  Styles\n} from \"./types\";\nimport { Bounds } from \"./Bounds\";\nimport { getArrowStyle } from \"./getArrowStyle\";\nimport { BoundsOffsets } from \"./BoundsOffsets\";\n\n/**\n * Class mostly concerned about calculating and finding the right placement\n */\nexport class Placements {\n  protected constructor(\n    public readonly placements: Placement[],\n    private config: PositionConfig,\n    private subjectsBounds: SubjectsBounds\n  ) {}\n\n  /**\n   * Converts a placement-type into a primary-side and a secondary-side\n   */\n  static getSidesFromPlacementType(\n    type: PlacementType\n  ): [BoundSideType, SideType] {\n    let [a, b] = type.split(\"-\") as unknown as [\n      keyof typeof BoundSide,\n      \"start\" | \"center\" | \"end\"\n    ];\n\n    const primary = BoundSide[a];\n    let secondary: SideType;\n    if (b === \"center\") {\n      secondary = Side.center;\n    } else if (primary.isHorizontal) {\n      secondary = b === \"start\" ? Side.top : Side.bottom;\n    } else {\n      secondary = b === \"start\" ? Side.left : Side.right;\n    }\n\n    return [primary, secondary];\n  }\n\n  /**\n   * Main static method to create a Placements instance\n   * @param subjectsBounds instance of the SubjectsBounds class\n   * @param config config provided by the user\n   */\n  static create(\n    subjectsBounds: SubjectsBounds,\n    config: PositionConfig\n  ): Placements {\n    // create offsets-object from user config\n    const offsets: Offsets = {\n      arrow: config.arrowOffset,\n      container: config.containerOffset,\n      trigger: config.triggerOffset\n    };\n\n    // function which creates a prioritized list of possible placments\n    // by looking at user-config\n    function getListOfPlacements(preferedPlacement = config.placement) {\n      const [primary, secondary] =\n        Placements.getSidesFromPlacementType(preferedPlacement);\n\n      const preferredSide =\n        BoundSide[primary.isHorizontal ? config.preferY : config.preferX];\n\n      // some priorities may alter when the trigger is bigger\n      const triggerIsBigger =\n        (!primary.isHorizontal && subjectsBounds.triggerHasBiggerWidth) ||\n        (primary.isHorizontal && subjectsBounds.triggerHasBiggerHeight);\n\n      // utility function which constructs a placement by primary and secondary sides\n      function placementFrom(\n        primary: BoundSideType,\n        secondary: SideType\n      ): Placement {\n        return new Placement(\n          primary,\n          secondary,\n          subjectsBounds,\n          config.layerDimensions,\n          offsets\n        );\n      }\n\n      // creating the list\n      let list: Placement[] = [];\n      list[0] = placementFrom(primary, secondary);\n      list[1] = placementFrom(\n        primary,\n        secondary.isCenter ? preferredSide : Side.center\n      );\n      list[2] = placementFrom(\n        primary,\n        Side[\n          (secondary.opposite.isCenter\n            ? preferredSide.opposite\n            : secondary.opposite\n          ).prop\n        ]\n      );\n      list[3] = placementFrom(\n        preferredSide,\n        triggerIsBigger ? primary : Side[primary.opposite.prop]\n      );\n      list[4] = placementFrom(preferredSide, Side.center);\n      list[5] = placementFrom(\n        preferredSide,\n        triggerIsBigger ? Side[primary.opposite.prop] : primary\n      );\n      list[6] = placementFrom(\n        BoundSide[preferredSide.opposite.prop],\n        triggerIsBigger ? primary : Side[primary.opposite.prop]\n      );\n      list[7] = placementFrom(\n        BoundSide[preferredSide.opposite.prop],\n        Side.center\n      );\n      list[8] = placementFrom(\n        BoundSide[preferredSide.opposite.prop],\n        triggerIsBigger ? Side[primary.opposite.prop] : primary\n      );\n      list[9] = placementFrom(BoundSide[primary.opposite.prop], secondary);\n      list[10] = placementFrom(\n        BoundSide[primary.opposite.prop],\n        secondary.isCenter ? preferredSide : Side.center\n      );\n      list[11] = placementFrom(\n        BoundSide[primary.opposite.prop],\n        Side[\n          (secondary.opposite.isCenter\n            ? preferredSide.opposite\n            : secondary.opposite\n          ).prop\n        ]\n      );\n\n      // only include placements that are part of 'possible-placements'\n      list = list.filter(\n        placement =>\n          placement.type === config.placement ||\n          config.possiblePlacements.includes(placement.type)\n      );\n\n      return list;\n    }\n\n    // treat placement 'center' a little bit different\n    if (config.placement === \"center\") {\n      return new Placements(\n        [\n          new PlacementCenter(\n            Side.center,\n            Side.center,\n            subjectsBounds,\n            config.layerDimensions,\n            offsets\n          ),\n          ...getListOfPlacements(\n            `${config.preferY}-${config.preferX}` as PlacementType\n          )\n        ],\n        config,\n        subjectsBounds\n      );\n    }\n\n    return new Placements(getListOfPlacements(), config, subjectsBounds);\n  }\n\n  private filterPlacementsBySide(side: SideType): Placement[] {\n    return this.placements.filter(placement => placement.primary === side);\n  }\n\n  private findFirstPlacementThatFits(): Placement | undefined {\n    return this.placements.find(placement => placement.fitsContainer);\n  }\n\n  private placementWithBiggestVisibleSurface(): Placement {\n    const [{ placement: placementWithBiggestSurface }] = this.placements\n      .map(placement => ({\n        placement,\n        surface: placement.visibleSurface\n      }))\n      // sort -> biggest surface first\n      .sort((a, b) => b.surface - a.surface);\n\n    return placementWithBiggestSurface;\n  }\n\n  private findSuitablePlacement(): Placement {\n    if (!this.config.auto) {\n      return this.placements[0];\n    }\n\n    return (\n      this.findFirstPlacementThatFits() ||\n      this.placementWithBiggestVisibleSurface()\n    );\n  }\n\n  /**\n   * secondary offset: the number of pixels between the edge of the\n   * scroll-container and the current placement, on the side of the layer\n   * that didn't fit.\n   * Eventually this secondary offset gets added / subtracted from the\n   * placement that does fit in order to move the layer closer to the\n   * position of the placement that just would not fit.\n   * This creates the effect that the layer is moving gradually from one\n   * placement to the next as the users scrolls the page or scroll-container\n   */\n  private getSecondaryOffset(placement: Placement): number {\n    const { auto, snap } = this.config;\n\n    // return early when we're not interested...\n    if (!auto || snap || placement instanceof PlacementCenter) {\n      return 0;\n    }\n\n    // if current placement fits and is prefered placement...\n    // return early\n    const placementsOnSameSide = this.filterPlacementsBySide(placement.primary);\n    const currentPlacementHasHighestPriority =\n      placementsOnSameSide.indexOf(placement) === 0;\n    if (currentPlacementHasHighestPriority && placement.fitsContainer) {\n      return 0;\n    }\n\n    const firstPlacementThatDoesNotFit = placementsOnSameSide.find(\n      placement => !placement.fitsContainer\n    );\n    if (!firstPlacementThatDoesNotFit) {\n      return 0;\n    }\n    const secondaryOffsetSide =\n      firstPlacementThatDoesNotFit.secondaryOffsetSide!;\n    if (!secondaryOffsetSide) {\n      return 0;\n    }\n\n    const containerOffsets = placement.getContainerOffsets();\n\n    // determine whether we should add or substract the secondary-offset\n    const { secondary } = placement;\n    let factor: number;\n    if (\n      placement.triggerIsBigger ||\n      firstPlacementThatDoesNotFit === placement\n    ) {\n      factor = secondaryOffsetSide.isPush ? -1 : 1;\n    } else {\n      factor =\n        secondary === Side.left ||\n        ([Side.top, Side.center].includes(secondary) &&\n          secondaryOffsetSide.isPush)\n          ? -1\n          : 1;\n    }\n\n    // get number of pixels between placement that did not fit and current\n    // placement\n    const secondaryOffset = containerOffsets[secondaryOffsetSide!.prop];\n\n    return secondaryOffset * factor;\n  }\n\n  private getStyles(\n    layerBounds: Bounds,\n    placement: Placement,\n    scrollOffsets: ScrollOffsets,\n    borderOffsets: BorderOffsets\n  ): Styles {\n    const layerStyleBase: CSSProperties = {\n      willChange: \"top, left, width, height\"\n    };\n\n    const arrow = getArrowStyle(\n      this.subjectsBounds.merge({ layer: layerBounds }),\n      placement,\n      this.config.arrowOffset\n    );\n\n    const layer: CSSProperties = this.config.overflowContainer\n      ? {\n          ...layerStyleBase,\n          position: \"fixed\",\n          top: layerBounds.top,\n          left: layerBounds.left\n        }\n      : {\n          ...layerStyleBase,\n          position: \"absolute\",\n          top:\n            layerBounds.top -\n            this.subjectsBounds.parent.top +\n            scrollOffsets.top -\n            borderOffsets.top,\n          left:\n            layerBounds.left -\n            this.subjectsBounds.parent.left +\n            scrollOffsets.left -\n            borderOffsets.left\n        };\n\n    return {\n      arrow,\n      layer\n    };\n  }\n\n  private getHasDisappeared(layerBounds: Bounds): DisappearType | null {\n    const subject = this.config.overflowContainer\n      ? this.subjectsBounds.trigger\n      : layerBounds;\n\n    const containerOffsets = BoundsOffsets.mergeSmallestSides(\n      this.subjectsBounds.offsetsToScrollContainers(subject, true)\n    );\n\n    const entries = Object.entries(\n      containerOffsets.negativeSides\n    ) as unknown as [BoundSideProp, number][];\n\n    const hasFullyDisappeared = entries.some(([prop, value]) => {\n      const side = BoundSide[prop];\n      return value <= -subject[side.sizeProp];\n    });\n\n    if (hasFullyDisappeared) {\n      return \"full\";\n    }\n\n    if (!containerOffsets.allSidesArePositive) {\n      return \"partial\";\n    }\n\n    return null;\n  }\n\n  public result(scrollOffsets: ScrollOffsets, borderOffsets: BorderOffsets) {\n    const suitablePlacement = this.findSuitablePlacement();\n    const secondaryOffset = this.getSecondaryOffset(suitablePlacement);\n    const layerBounds = suitablePlacement.getLayerBounds(secondaryOffset);\n    const styles = this.getStyles(\n      layerBounds,\n      suitablePlacement,\n      scrollOffsets,\n      borderOffsets\n    );\n    const layerSide = suitablePlacement.primary.prop as SideProp;\n\n    return {\n      styles,\n      layerSide,\n      placement: suitablePlacement,\n      layerBounds,\n      hasDisappeared: this.getHasDisappeared(layerBounds)\n    };\n  }\n}\n","import { Bounds, IBounds, boundsToObject } from \"./Bounds\";\n\ninterface ISubjectsBounds {\n  trigger: IBounds;\n  layer: IBounds;\n  arrow: IBounds;\n  parent: IBounds;\n  window: IBounds;\n  scrollContainers: IBounds[];\n}\n\nexport class SubjectsBounds implements ISubjectsBounds {\n  public readonly trigger!: Bounds;\n  public readonly layer!: Bounds;\n  public readonly arrow!: Bounds;\n  public readonly parent!: Bounds;\n  public readonly window!: Bounds;\n  public readonly scrollContainers!: Bounds[];\n\n  private constructor(\n    subjectsBounds: ISubjectsBounds,\n    private readonly overflowContainer: boolean\n  ) {\n    Object.assign(this, subjectsBounds);\n  }\n\n  static create(\n    environment: Window,\n    layer: HTMLElement,\n    trigger: HTMLElement,\n    parent: HTMLElement | undefined,\n    arrow: HTMLElement | null,\n    scrollContainers: HTMLElement[],\n    overflowContainer: boolean,\n    getTriggerBounds?: () => IBounds\n  ) {\n    const window = Bounds.fromWindow(environment);\n\n    return new SubjectsBounds(\n      {\n        layer: Bounds.fromElement(layer, {\n          environment,\n          withTransform: false\n        }),\n        trigger: getTriggerBounds\n          ? Bounds.create(boundsToObject(getTriggerBounds()))\n          : Bounds.fromElement(trigger),\n        arrow: arrow ? Bounds.fromElement(arrow) : Bounds.empty(),\n        parent: parent ? Bounds.fromElement(parent) : window,\n        window,\n        scrollContainers: [\n          window,\n          ...scrollContainers.map(container =>\n            Bounds.fromElement(container, { withScrollbars: false })\n          )\n        ]\n      },\n      overflowContainer\n    );\n  }\n\n  merge(subjectsBounds: Partial<ISubjectsBounds>) {\n    return new SubjectsBounds(\n      {\n        ...this,\n        ...subjectsBounds\n      },\n      this.overflowContainer\n    );\n  }\n\n  get layerOffsetsToScrollContainers() {\n    return this.offsetsToScrollContainers(this.layer);\n  }\n\n  get triggerHasBiggerWidth() {\n    return this.trigger.width > this.layer.width;\n  }\n\n  get triggerHasBiggerHeight() {\n    return this.trigger.height > this.layer.height;\n  }\n\n  offsetsToScrollContainers(subject: Bounds, allContainers = false) {\n    const scrollContainers =\n      this.overflowContainer && !allContainers\n        ? [this.window]\n        : this.scrollContainers;\n\n    return scrollContainers.map(scrollContainer =>\n      scrollContainer.offsetsTo(subject)\n    );\n  }\n}\n","import {\n  useCallback,\n  useState,\n  useRef,\n  createElement,\n  ReactNode,\n  ReactPortal,\n  MutableRefObject,\n  CSSProperties,\n  useEffect\n} from \"react\";\nimport { createPortal } from \"react-dom\";\nimport warning from \"tiny-warning\";\nimport {\n  Options,\n  LayerSide,\n  Styles,\n  ScrollOffsets,\n  BorderOffsets,\n  PositionConfig,\n  RefCallback,\n  Container\n} from \"./types\";\nimport { useTrackElements, OnChangeElements } from \"./useTrackElements\";\nimport { useGroup, GroupProvider } from \"./useGroup\";\nimport { PlacementType, PLACEMENT_TYPES } from \"./PlacementType\";\nimport { Placements } from \"./Placements\";\nimport { SubjectsBounds } from \"./SubjectsBounds\";\nimport { useLastState } from \"./hooks\";\nimport { isSet, mergeRefs } from \"./util\";\n\nlet GLOBAL_CONTAINER: HTMLElement | null = null;\n\nexport function setGlobalContainer(container: Container) {\n  if (typeof document === \"undefined\") {\n    return;\n  }\n\n  warning(\n    !(GLOBAL_CONTAINER instanceof HTMLElement),\n    `react-laag: You've called 'setGlobalContainer() previously'. It is recommended to only set the global container once, otherwise this may lead to unexpected behaviour.`\n  );\n\n  if (typeof container === \"function\") {\n    GLOBAL_CONTAINER = container();\n  } else if (typeof container === \"string\") {\n    GLOBAL_CONTAINER = document.getElementById(container);\n  } else {\n    GLOBAL_CONTAINER = container;\n  }\n\n  warning(\n    GLOBAL_CONTAINER instanceof HTMLElement,\n    `react-laag: You've called 'setGlobalContainer()', but it didn't result in a valid html-element`\n  );\n}\n\nexport type LayerProps = { ref: RefCallback; style: Styles[\"layer\"] };\nexport type TriggerProps = { ref: RefCallback };\nexport type UseLayerArrowProps = {\n  ref: MutableRefObject<any> | RefCallback;\n  layerSide: LayerSide;\n  style: Styles[\"arrow\"];\n};\n\nexport type UseLayerProps = {\n  renderLayer: (children: ReactNode) => ReactPortal | null;\n  triggerProps: TriggerProps;\n  layerProps: LayerProps;\n  arrowProps: UseLayerArrowProps;\n  layerSide: LayerSide;\n  triggerBounds: ClientRect | null;\n};\n\ntype State = {\n  layerSide: LayerSide;\n  styles: Styles;\n};\n\nexport const DEFAULT_OPTIONS: Required<\n  Omit<\n    Options,\n    | \"ResizeObserver\"\n    | \"environment\"\n    | \"onParentClose\"\n    | \"onOutsideClick\"\n    | \"onDisappear\"\n    | \"isOpen\"\n    | \"layerDimensions\"\n  >\n> = {\n  auto: false,\n  arrowOffset: 0,\n  containerOffset: 10,\n  triggerOffset: 0,\n  overflowContainer: true,\n  placement: \"top-center\",\n  possiblePlacements: PLACEMENT_TYPES as unknown as PlacementType[],\n  preferX: \"right\",\n  preferY: \"bottom\",\n  snap: false,\n  container: undefined!,\n  trigger: undefined!\n};\n\nexport function useLayer({\n  isOpen = false,\n  overflowContainer = DEFAULT_OPTIONS.overflowContainer,\n  environment = typeof window !== \"undefined\" ? window : undefined,\n  ResizeObserver: ResizeObserverPolyfill,\n  placement = DEFAULT_OPTIONS.placement,\n  possiblePlacements = DEFAULT_OPTIONS.possiblePlacements,\n  preferX = DEFAULT_OPTIONS.preferX,\n  preferY = DEFAULT_OPTIONS.preferY,\n  auto = DEFAULT_OPTIONS.auto,\n  snap = DEFAULT_OPTIONS.snap,\n  triggerOffset = DEFAULT_OPTIONS.triggerOffset,\n  containerOffset = DEFAULT_OPTIONS.containerOffset,\n  arrowOffset = DEFAULT_OPTIONS.arrowOffset,\n  container = DEFAULT_OPTIONS.container,\n  layerDimensions = null,\n  onDisappear,\n  onOutsideClick,\n  onParentClose,\n  trigger: triggerOption\n}: Options): UseLayerProps {\n  // initialize styles\n  const [state, setState] = useState<State>(() => ({\n    layerSide:\n      placement === \"center\"\n        ? \"center\"\n        : Placements.getSidesFromPlacementType(placement)[0].prop,\n    styles: {\n      layer: {\n        position: overflowContainer ? \"fixed\" : \"absolute\",\n        top: 0,\n        left: 0\n      },\n      arrow: {\n        position: \"absolute\",\n        top: 0,\n        left: 0\n      }\n    }\n  }));\n\n  const triggerBoundsRef = useRef<HTMLElement>(null!);\n\n  // tracks state in order for us to use read inside functions that require dependencies,\n  // like `useCallback`, without triggering an update\n  const lastState = useLastState(state, isOpen);\n\n  // track invalidations for scheduled position updates\n  const repositioningToken = useRef({ cancelled: false });\n  useEffect(() => {\n    return () => {\n      // when this hook unmounts, make sure to cancel any scheduled position updates\n      repositioningToken.current.cancelled = true;\n    };\n  }, []);\n\n  // Most important function regarding positioning\n  // It receives boundaries collected by `useTrackElements`, does some calculations,\n  // sets new styles, and handles when a layer has disappeared.\n  const handlePositioning = useCallback(\n    function handlePositioning(\n      { arrow, layer, scrollContainers, trigger }: OnChangeElements,\n      scrollOffsets: ScrollOffsets,\n      borderOffsets: BorderOffsets\n    ) {\n      const parent = scrollContainers[0];\n\n      const subjectsBounds = SubjectsBounds.create(\n        environment!,\n        layer,\n        trigger,\n        parent,\n        arrow,\n        scrollContainers,\n        overflowContainer,\n        triggerOption?.getBounds\n      );\n\n      const config: PositionConfig = {\n        placement,\n        possiblePlacements,\n        auto,\n        layerDimensions,\n        arrowOffset,\n        containerOffset,\n        triggerOffset,\n        preferX,\n        preferY,\n        snap,\n        overflowContainer\n      };\n\n      const { hasDisappeared, layerSide, styles } = Placements.create(\n        subjectsBounds,\n        config\n      ).result(scrollOffsets, borderOffsets);\n\n      const newState: State = {\n        layerSide,\n        styles\n      };\n\n      if (!lastState.current || didStateChange(lastState.current, newState)) {\n        lastState.current = newState; // optimistically update lastState to prevent infinite loop\n\n        /**\n         * Throttle state updates slightly by delaying them using an immediately\n         * resolved promise, only applying them if there is no later update.\n         * This helps for multiple updates that happens synchronously one after another.\n         */\n        repositioningToken.current.cancelled = true;\n        const token = { cancelled: false };\n        repositioningToken.current = token;\n\n        Promise.resolve().then(() => {\n          if (!token.cancelled) {\n            setState(newState);\n          }\n        });\n      }\n\n      if (isSet(hasDisappeared) && isSet(onDisappear)) {\n        onDisappear(hasDisappeared);\n      }\n    },\n    [\n      arrowOffset,\n      auto,\n      containerOffset,\n      environment,\n      layerDimensions,\n      onDisappear,\n      overflowContainer,\n      placement,\n      possiblePlacements,\n      preferX,\n      preferY,\n      snap,\n      triggerOffset,\n      lastState,\n      triggerOption\n    ]\n  );\n\n  const { triggerRef, layerRef, arrowRef, closestScrollContainer } =\n    useTrackElements({\n      ResizeObserverPolyfill,\n      environment,\n      enabled: isOpen,\n      overflowContainer,\n      onChange: handlePositioning,\n      triggerOption\n    });\n\n  const { closeOnOutsideClickRefs, registrations } = useGroup({\n    isOpen,\n    onOutsideClick,\n    onParentClose\n  });\n\n  const props: UseLayerProps = {\n    triggerProps: Boolean(triggerOption)\n      ? ({} as any) // when using the `trigger` option, make `triggerProps` useless\n      : {\n          ref: mergeRefs(\n            triggerRef,\n            closeOnOutsideClickRefs.trigger,\n            triggerBoundsRef\n          )\n        },\n    layerProps: {\n      ref: mergeRefs(layerRef, closeOnOutsideClickRefs.layer),\n      style: state.styles.layer\n    },\n    arrowProps: {\n      ref: arrowRef,\n      style: state.styles.arrow,\n      layerSide: state.layerSide\n    },\n    layerSide: state.layerSide,\n    triggerBounds: isOpen\n      ? triggerOption\n        ? triggerOption.getBounds()\n        : triggerBoundsRef.current?.getBoundingClientRect()\n      : null,\n    renderLayer: children =>\n      typeof document !== \"undefined\"\n        ? createPortal(\n            createElement(GroupProvider, { registrations, children }),\n            overflowContainer || !closestScrollContainer\n              ? getContainerElement(container)\n              : closestScrollContainer\n          )\n        : null\n  };\n\n  return props;\n}\n\nfunction didStateChange(previous: State, next: State): boolean {\n  if (previous.layerSide !== next.layerSide) {\n    return true;\n  }\n\n  const styleProps: Array<keyof CSSProperties> = [\n    \"position\",\n    \"top\",\n    \"left\",\n    \"right\",\n    \"bottom\"\n  ];\n  for (const prop of styleProps) {\n    if (\n      previous.styles.layer[prop] !== next.styles.layer[prop] ||\n      previous.styles.arrow[prop] !== next.styles.arrow[prop]\n    ) {\n      return true;\n    }\n  }\n\n  return false;\n}\n\nconst DEFAULT_CONTAINER_ID = \"layers\";\n\nfunction getContainerElement(container?: Container): HTMLElement {\n  let element: HTMLElement;\n\n  if (typeof container === \"function\") {\n    element = container();\n    if (!element || !(element instanceof HTMLElement)) {\n      throw new Error(\n        `react-laag: You've passed a function to the 'container' prop, but it returned no valid HTMLElement`\n      );\n    }\n  } else if (container instanceof HTMLElement) {\n    element = container;\n  } else if (typeof container === \"string\") {\n    element = document.getElementById(container)!;\n    if (!element) {\n      throw new Error(\n        `react-laag: You've passed element with id '${container}' to the 'container' prop, but it returned no valid HTMLElement`\n      );\n    }\n  } else if (GLOBAL_CONTAINER instanceof HTMLElement) {\n    return GLOBAL_CONTAINER;\n  } else {\n    element = document.getElementById(DEFAULT_CONTAINER_ID)!;\n    if (!element) {\n      element = document.createElement(\"div\");\n      element.id = DEFAULT_CONTAINER_ID;\n      element.style.cssText = `\n        position: absolute;\n        top: 0px;\n        left: 0px;\n        right: 0px;\n      `;\n      document.body.appendChild(element);\n    }\n  }\n\n  return element;\n}\n","import { createElement, forwardRef } from \"react\";\nimport { BoundSide, BoundSideType } from \"./Sides\";\nimport { LayerSide } from \"./types\";\n\nconst LEFT = \"left\";\nconst TOP = \"top\";\nconst BOTTOM = \"bottom\";\nconst RIGHT = \"right\";\n\nfunction getWidthBasedOnAngle(angle: number, size: number) {\n  return Math.tan(angle * (Math.PI / 180)) * size;\n}\n\nfunction getViewBox(\n  sizeA: number,\n  sizeB: number,\n  side: BoundSideType,\n  borderWidth: number\n) {\n  const map = {\n    [BOTTOM]: `0 ${-borderWidth} ${sizeB} ${sizeA}`,\n    [TOP]: `0 0 ${sizeB} ${sizeA + borderWidth}`,\n    [RIGHT]: `${-borderWidth} 0 ${sizeA} ${sizeB}`,\n    [LEFT]: `0 0 ${sizeA + borderWidth} ${sizeB}`\n  };\n\n  return map[side.prop];\n}\n\nfunction getTrianglePath(\n  sizeA: number,\n  sizeB: number,\n  side: BoundSideType,\n  roundness: number,\n  angle: number\n) {\n  const relativeRoundness = (roundness / 10) * sizeA * 2;\n\n  const A = {\n    [BOTTOM]: [0, sizeA],\n    [TOP]: [0, 0],\n    [RIGHT]: [sizeA, sizeB],\n    [LEFT]: [0, sizeB]\n  }[side.prop].join(\" \");\n\n  const B = side.isHorizontal ? `V 0` : `H ${sizeB}`;\n\n  const cPoint = sizeB / 2;\n  const c1A = sizeB / 2 + getWidthBasedOnAngle(angle, sizeA / 8);\n  const c1B = sizeA / 8;\n\n  const C = {\n    [BOTTOM]: [\"C\", c1A, c1B, cPoint + relativeRoundness, 0, cPoint, 0],\n    [TOP]: [\n      \"C\",\n      c1A,\n      sizeA - c1B,\n      cPoint + relativeRoundness,\n      sizeA,\n      cPoint,\n      sizeA\n    ],\n    [RIGHT]: [\"C\", c1B, sizeB - c1A, 0, cPoint - relativeRoundness, 0, cPoint],\n    [LEFT]: [\n      \"C\",\n      sizeA - c1B,\n      sizeB - c1A,\n      sizeA,\n      cPoint - relativeRoundness,\n      sizeA,\n      cPoint\n    ]\n  }[side.prop].join(\" \");\n\n  const d1A = sizeB / 2 - getWidthBasedOnAngle(angle, sizeA / 8);\n  const d1B = sizeA / 8;\n\n  const D = {\n    [BOTTOM]: [\"C\", cPoint - relativeRoundness, 0, d1A, d1B, A],\n    [TOP]: [\"C\", cPoint - relativeRoundness, sizeA, d1A, sizeA - d1B, A],\n    [RIGHT]: [\"C\", 0, cPoint + relativeRoundness, d1B, sizeB - d1A, A],\n    [LEFT]: [\n      \"C\",\n      sizeA,\n      cPoint + relativeRoundness,\n      sizeA - d1B,\n      sizeB - d1A,\n      A\n    ]\n  }[side.prop].join(\" \");\n\n  return [\"M\", A, B, C, D].join(\" \");\n}\n\nfunction getBorderMaskPath(\n  sizeA: number,\n  sizeB: number,\n  borderWidth: number,\n  side: BoundSideType,\n  angle: number\n) {\n  const borderOffset = getWidthBasedOnAngle(angle, borderWidth);\n\n  const [A, B] = !side.isPush ? [sizeA, sizeA - borderWidth] : [0, borderWidth];\n\n  if (side.isHorizontal) {\n    return [\n      \"M\",\n      A,\n      borderWidth,\n      \"V\",\n      sizeB - borderWidth,\n      \"L\",\n      B,\n      sizeB - borderWidth - borderOffset,\n      \"V\",\n      borderOffset + borderWidth,\n      \"Z\"\n    ].join(\" \");\n  }\n\n  return [\n    \"M\",\n    borderWidth,\n    A,\n    \"H\",\n    sizeB - borderWidth,\n    \"L\",\n    sizeB - borderWidth - borderOffset,\n    B,\n    \"H\",\n    borderOffset + borderWidth,\n    \"Z\"\n  ].join(\" \");\n}\n\nexport type ArrowProps = React.ComponentPropsWithoutRef<\"svg\"> & {\n  /**\n   * angle of triangle\n   * default is `45`\n   */\n  angle?: number;\n  /**\n   * distance in pixels between point of triangle and layer\n   * default is `8`\n   */\n  size?: number;\n  /**\n   * roundness of the point of the arrow\n   * range: 0 - 1\n   * default is `0`\n   */\n  roundness?: number;\n  /**\n   * width of the layers border\n   * default is `0`\n   */\n  borderWidth?: number;\n  /**\n   * color of the layers border\n   * default is `\"black\"`\n   */\n  borderColor?: string;\n  /**\n   * background-color of the layer\n   * default is `\"white\"`\n   */\n  backgroundColor?: string;\n  /**\n   * Given by `useLayer()` and determines the direction the arrow should\n   * be pointing to\n   */\n  layerSide?: LayerSide;\n};\n\nexport const Arrow = forwardRef<SVGSVGElement, ArrowProps>(function Arrow(\n  {\n    size = 8,\n    angle = 45,\n    borderWidth = 0,\n    borderColor = \"black\",\n    roundness = 0,\n    backgroundColor = \"white\",\n    layerSide = \"top\",\n    style = {},\n    ...rest\n  },\n  ref\n) {\n  if (layerSide === \"center\") {\n    return null;\n  }\n\n  const side = BoundSide[layerSide];\n  const sizeA = size;\n  const sizeB = getWidthBasedOnAngle(angle, size) * 2;\n\n  const maxSize = Math.max(sizeA, sizeB);\n\n  return createElement(\n    \"svg\",\n    {\n      ref,\n      ...rest,\n      style: {\n        ...style,\n        transform: `translate${side.isHorizontal ? \"Y\" : \"X\"}(-50%)`\n      },\n      width: maxSize,\n      height: maxSize,\n      preserveAspectRatio: side.isPush ? \"xMinYMin\" : \"xMaxYMax\",\n      viewBox: getViewBox(sizeA, sizeB, side, borderWidth)\n    },\n    createElement(\"path\", {\n      fill: backgroundColor,\n      strokeWidth: borderWidth,\n      stroke: borderColor,\n      d: getTrianglePath(sizeA, sizeB, side, roundness, angle)\n    }),\n    createElement(\"path\", {\n      fill: backgroundColor,\n      d: getBorderMaskPath(sizeA, sizeB, borderWidth, side, angle)\n    })\n  );\n});\n","import { useState, useRef, useCallback, useEffect, MouseEvent } from \"react\";\n\nexport type UseHoverOptions = {\n  /**\n   * Amount of milliseconds to wait while hovering before opening.\n   * Default is `0`\n   */\n  delayEnter?: number;\n  /**\n   * Amount of milliseconds to wait when mouse has left the trigger before closing.\n   * Default is `0`\n   */\n  delayLeave?: number;\n  /**\n   * Determines whether the layer should hide when the user starts scrolling.\n   * Default is `true`\n   */\n  hideOnScroll?: boolean;\n};\n\nexport type PlainCallback = (...args: any[]) => void;\n\nexport type UseHoverProps = {\n  onMouseEnter: PlainCallback;\n  onMouseLeave: PlainCallback;\n  onTouchStart: PlainCallback;\n  onTouchMove: PlainCallback;\n  onTouchEnd: PlainCallback;\n};\n\nenum Status {\n  ENTERING,\n  LEAVING,\n  IDLE\n}\n\nexport function useHover({\n  delayEnter = 0,\n  delayLeave = 0,\n  hideOnScroll = true\n}: UseHoverOptions = {}): readonly [boolean, UseHoverProps, () => void] {\n  const [show, setShow] = useState(false);\n\n  const timeout = useRef<number | null>(null);\n\n  const status = useRef<Status>(Status.IDLE);\n\n  const hasTouchMoved = useRef<boolean>(false);\n\n  const removeTimeout = useCallback(function removeTimeout() {\n    clearTimeout(timeout.current!);\n    timeout.current = null;\n    status.current = Status.IDLE;\n  }, []);\n\n  function onMouseEnter() {\n    // if was leaving, stop leaving\n    if (status.current === Status.LEAVING && timeout.current) {\n      removeTimeout();\n    }\n\n    if (show) {\n      return;\n    }\n\n    status.current = Status.ENTERING;\n    timeout.current = window.setTimeout(() => {\n      setShow(true);\n      timeout.current = null;\n      status.current = Status.IDLE;\n    }, delayEnter);\n  }\n\n  function onMouseLeave(_: MouseEvent<any>, immediate?: boolean) {\n    // if was waiting for entering,\n    // clear timeout\n    if (status.current === Status.ENTERING && timeout.current) {\n      removeTimeout();\n    }\n\n    if (!show) {\n      return;\n    }\n\n    if (immediate) {\n      setShow(false);\n      timeout.current = null;\n      status.current = Status.IDLE;\n      return;\n    }\n\n    status.current = Status.LEAVING;\n    timeout.current = window.setTimeout(() => {\n      setShow(false);\n      timeout.current = null;\n      status.current = Status.IDLE;\n    }, delayLeave);\n  }\n\n  // make sure to clear timeout on unmount\n  useEffect(() => {\n    function onScroll() {\n      if (show && hideOnScroll) {\n        removeTimeout();\n        setShow(false);\n      }\n    }\n\n    window.addEventListener(\"scroll\", onScroll, true);\n\n    return () => {\n      window.removeEventListener(\"scroll\", onScroll, true);\n\n      if (timeout.current) {\n        clearTimeout(timeout.current);\n      }\n    };\n  }, [show, hideOnScroll, removeTimeout]);\n\n  const hoverProps: UseHoverProps = {\n    onMouseEnter,\n    onMouseLeave,\n    onTouchStart: () => {\n      hasTouchMoved.current = false;\n    },\n    onTouchMove: () => {\n      hasTouchMoved.current = true;\n    },\n    onTouchEnd: () => {\n      if (!hasTouchMoved.current && !show) {\n        setShow(true);\n      }\n\n      hasTouchMoved.current = false;\n    }\n  };\n\n  return [show, hoverProps, () => onMouseLeave(null!, true)] as const;\n}\n","import { useState, useRef, useEffect } from \"react\";\nimport warning from \"tiny-warning\";\n\nexport type TransitionProps = {\n  isOpen: boolean;\n  children: (\n    isOpen: boolean,\n    onTransitionEnd: any,\n    isLeaving: boolean\n  ) => React.ReactElement;\n};\n\n/**\n * @deprecated\n * Note: this component is marked as deprecated and will be removed and a possible\n * future release\n */\nexport function Transition({\n  isOpen: isOpenExternal,\n  children\n}: TransitionProps) {\n  const [state, setState] = useState({\n    isOpenInternal: isOpenExternal,\n    isLeaving: false\n  });\n\n  const didMount = useRef(false);\n\n  useEffect(() => {\n    if (isOpenExternal) {\n      setState({\n        isOpenInternal: true,\n        isLeaving: false\n      });\n    } else if (didMount.current) {\n      setState({\n        isOpenInternal: false,\n        isLeaving: true\n      });\n    }\n  }, [isOpenExternal, setState]);\n\n  useEffect(() => {\n    warning(\n      children,\n      `react-laag: You are using 'Transition'. Note that this component is marked as deprecated and will be removed at future releases`\n    );\n  }, [children]);\n\n  useEffect(() => {\n    didMount.current = true;\n  }, []);\n\n  if (!isOpenExternal && !state.isOpenInternal && !state.isLeaving) {\n    return null;\n  }\n\n  return children(\n    state.isOpenInternal,\n    () => {\n      if (!state.isOpenInternal) {\n        setState(s => ({ ...s, isLeaving: false }));\n      }\n    },\n    state.isLeaving\n  );\n}\n"],"names":["useTrackRef","onRefChange","storedReference","useRef","element","current","useIsomorphicLayoutEffect","window","useLayoutEffect","useEffect","EMPTY_BOUNDS","top","left","right","bottom","width","height","getPixelValue","value","parseFloat","replace","limit","min","max","isSet","mergeRefs","refs","ref","findScrollContainers","environment","result","document","body","getComputedStyle","overflow","overflowX","overflowY","some","prop","includes","push","parentElement","createReferenceError","subject","useTrackElements","enabled","onChange","overflowContainer","triggerOption","ResizeObserver","polyfill","getResizeObserver","ResizeObserverPolyfill","warning","state","subscriptions","arrowRef","hasTriggerOption","Boolean","scrollContainers","trigger","layer","useMemo","setter","get","set","hasEventSubscriptions","length","removeAllEventSubscriptions","unsubscribe","addEventSubscription","unsubscriber","handleChange","useCallback","scrollOffsets","closestScrollContainer","Error","scrollTop","scrollLeft","scrollY","scrollX","borderOffsets","borderTopWidth","borderLeftWidth","arrow","addEventListeners","ignoredInitialCall","observer","observe","unobserve","disconnect","addEventListener","removeEventListener","resetWhenReferenceChangedWhileTracking","previous","next","layerRef","previousLayer","getScrollContainers","position","closestScrollContainerHasCorrectStyling","style","triggerRef","previousTrigger","triggerOptionParent","getParent","GroupContext","createContext","GroupProvider","children","registrations","handleRegister","registration","add","delete","createElement","Provider","PLACEMENT_TYPES","OPPOSITES","center","SideBase","opposite","isHorizontal","sizeProp","oppositeSizeProp","cssProp","oppositeCssProp","isCenter","isPush","factor","this","isOppositeDirection","side","createSide","recursive","BoundSide","Side","SIDES","BoundsOffsets","offsets","Object","assign","mergeSmallestSides","boundsOffsets","first","rest","fromEntries","map","boundsOffset","Math","every","_this","filter","_this2","sumOfPropertyValues","propertyValues","reduce","sum","propertyValue","boundsToObject","EMPTY","Bounds","bounds","create","fromElement","options","withTransform","withScrollbars","getBoundingClientRect","boxSizing","borderLeft","borderRight","borderTop","borderBottom","paddingLeft","paddingRight","paddingTop","paddingBottom","substract","clientWidth","clientHeight","empty","fromWindow","scrollingElement","documentElement","toObject","merge","partialBoundsOrMergeFn","entries","boundSide","offsetsTo","child","mapSides","mapper","values","Placement","primary","secondary","subjectBounds","layerDimensions","subjectsBounds","_cachedLayerBounds","_cachedContainerOffsets","setSubjectsBounds","dimensions","getLayerBounds","secondaryOffset","arrowOffsetBase","limitMin","limitMax","propertyA","propertyB","sec","triggerValue","layerBounds","getLayerCollisionBounds","container","getContainerOffsets","layerOffsetsToScrollContainers","triggerHasBiggerWidth","triggerHasBiggerHeight","allSidesArePositive","negativeSides","surface","containerOffsets","sort","_Object$entries$map$f2","PlacementCenter","STYLE_BASE","willChange","Placements","placements","config","getSidesFromPlacementType","type","split","b","arrowOffset","containerOffset","triggerOffset","getListOfPlacements","preferedPlacement","placement","preferredSide","preferY","preferX","triggerIsBigger","placementFrom","list","possiblePlacements","filterPlacementsBySide","findFirstPlacementThatFits","find","fitsContainer","placementWithBiggestVisibleSurface","visibleSurface","a","findSuitablePlacement","auto","getSecondaryOffset","snap","placementsOnSameSide","indexOf","firstPlacementThatDoesNotFit","secondaryOffsetSide","getStyles","sizeProperty","negativeOffset","sideA","sideB","offsetA","offsetB","getNegativeOffsetBetweenLayerCenterAndTrigger","secondarySide","secondaryValue","getArrowStyle","parent","getHasDisappeared","offsetsToScrollContainers","suitablePlacement","styles","layerSide","hasDisappeared","SubjectsBounds","getTriggerBounds","allContainers","scrollContainer","GLOBAL_CONTAINER","DEFAULT_OPTIONS","undefined","getWidthBasedOnAngle","angle","size","tan","PI","getViewBox","sizeA","sizeB","borderWidth","getTrianglePath","roundness","relativeRoundness","A","join","B","cPoint","c1A","c1B","C","d1A","d1B","getBorderMaskPath","borderOffset","Status","Arrow","forwardRef","borderColor","backgroundColor","maxSize","transform","preserveAspectRatio","viewBox","fill","strokeWidth","stroke","d","isOpenExternal","isOpen","useState","isOpenInternal","isLeaving","setState","didMount","s","HTMLElement","getElementById","delayEnter","delayLeave","hideOnScroll","show","setShow","timeout","status","IDLE","hasTouchMoved","removeTimeout","clearTimeout","onMouseLeave","_","immediate","ENTERING","LEAVING","setTimeout","onScroll","onMouseEnter","onTouchStart","onTouchMove","onTouchEnd","onDisappear","onOutsideClick","onParentClose","triggerBoundsRef","lastState","currentState","useLastState","repositioningToken","cancelled","handlePositioning","getBounds","newState","didStateChange","token","Promise","resolve","then","Set","possibleRegisterFn","useContext","shouldCloseWhenClickedOutside","event","target","clickedOnTrigger","contains","clickedOnLayer","shouldCloseAccordingToChildren","getShouldCloseAccordingToChildren","forEach","closeChild","handleClick","closeOnOutsideClickRefs","useGroup","triggerProps","layerProps","arrowProps","triggerBounds","_triggerBoundsRef$cur","renderLayer","createPortal","id","cssText","appendChild","getContainerElement","preventDefault","parentRef","mouseBounds","setMouseBounds","hasMousePosition","resetMousePosition","handleMouseEvent","evt","clientX","clientY"],"mappings":"oiDAgBgBA,EACdC,OAEMC,EAAkBC,SAA2B,sBAKnCC,GACTA,GAAWA,IAAYF,EAAgBG,UAI5CH,EAAgBG,QAAUD,EAC1BH,EAAYG,KA4ET,IAAME,EACO,oBAAXC,OAAyBC,kBAAkBC,YA6C9CC,EAAwB,CAC5BC,IAAK,EACLC,KAAM,EACNC,MAAO,EACPC,OAAQ,EACRC,MAAO,EACPC,OAAQ,YC1JMC,EAAcC,UACrBC,WAAWD,EAAME,QAAQ,KAAM,cAMxBC,EAAMH,EAAeI,EAAaC,UACzCL,EAAQI,EAAMA,EAAMJ,EAAQK,EAAMA,EAAML,WAMjCM,EAASN,UAChBA,MAAAA,WAOOO,+BAAaC,2BAAAA,yBACpB,SAACtB,iBACYsB,kBAAM,KAAbC,UACJA,IAIc,mBAARA,EACTA,EAAIvB,GAEJuB,EAAItB,QAAUD,cCNNwB,EACdxB,EACAyB,OAEMC,EAAwB,OAEzB1B,IAAYyB,GAAezB,IAAY2B,SAASC,YAC5CF,QAIPD,EAAYI,iBAAiB7B,SAG7B,GAJM8B,WAAUC,YAAWC,WAIMC,MAAK,SAAAC,SACpC,CAAC,OAAQ,UAAUC,SAASD,OAG9BR,EAAOU,KAAKpC,aAIT0B,EACAF,EAAqBxB,EAAQqC,cAAeZ,IAInD,SAASa,EAAqBC,iEACmCA,+FACTA,yJACHA,kDAiDrCC,SAEdC,IAAAA,QAEAC,IAAAA,SAEAjB,IAAAA,YAKAkB,IAAAA,kBAEAC,IAAAA,cAGMC,WA7GNpB,EACAqB,WAE2B,IAAhBrB,SAIJqB,GAAarB,EAAoBoB,eAsGjBE,CAAkBtB,IAPzCuB,wBAUA3C,aAAU,gDACR4C,UACEJ,wNAGD,CAACA,QFnFEK,EA0BAC,EE4DAC,EAAWrD,SAA2B,MAGtCsD,EAAmBC,QAAQV,MFzF3BM,EAAQnD,SEiGX,CACDwD,iBAAkB,GAClBC,QAAS,KACTC,MAAO,OFlGFC,WAAQ,iBAeN,mBAHER,EAAMjD,kBATF0D,GAETT,EAAMjD,QADc,mBAAX0D,EACOA,EAAOT,EAAMjD,SAEb0D,MASnB,KE2EIC,OAAKC,UFnENV,EAAgBpD,SAA0B,IAEzC2D,WAAQ,iBAiBN,CACLI,wCAhBOX,EAAclD,QAAQ8D,OAAS,GAiBtCC,qDAb0Bb,EAAclD,yBACtCgE,aAGFd,EAAclD,QAAU,IAUxBiE,8BAP4BC,GAC5BhB,EAAclD,QAAQmC,KAAK+B,OAQ5B,KEuDDL,IAAAA,sBACAI,IAAAA,qBACAF,IAAAA,4BAKII,EAAeC,eACnB,eAYMC,IAXyCV,IAArCH,IAAAA,MAAOD,IAAAA,QAASD,IAAAA,iBAClBgB,EAAyBhB,EAAiB,OAE3CE,QACG,IAAIe,MAAMlC,EAAqB,cAGlCkB,IAAYH,QACT,IAAImB,MAAMlC,EAAqB,YAMrCgC,EAFEC,EAEc,CACdhE,IAFgCgE,EAAdE,UAGlBjE,KAHgC+D,EAA1BG,YAOQ,CACdnE,IAF2BkB,EAAZkD,QAGfnE,KAH2BiB,EAArBmD,aAONC,EAA+B,CAAErE,KAAM,EAAGD,IAAK,MAC/CgE,EAAwB,OAExB9C,EAAaI,iBAAiB0C,GADPO,IAAAA,eAGzBD,EAAgB,CACdrE,KAAMK,IAJAkE,kBAIkC,EACxCxE,IAAKM,EAAciE,IAAmB,GAI1CpC,EACE,CACEe,MAAAA,EACAD,QAASA,EACTD,iBAAAA,EACAyB,MAAO5B,EAASnD,SAElBqE,EACAO,KAGJ,CAACjB,EAAKlB,EAAUjB,EAAa2B,EAAUC,IAKnC4B,EAAoBZ,eACxB,iBAC+CT,IAArCJ,IAAAA,QAASC,IAAAA,MAAOF,IAAAA,qBAEnBE,QACG,IAAIe,MAAMlC,EAAqB,cAElCkB,IAAYH,QAET,IAAImB,MAAMlC,EAAqB,eAGnCO,EAAgB,SACdqC,GAAqB,EAUnBC,EAAW,IAAItC,GATI,WAClBqC,EAKLd,IAJEc,GAAqB,WAQH,CAAC1B,EAASC,EAAO9B,SAASC,qBAAO,KAA5C5B,OACLA,GAASmF,EAASC,QAAQpF,GAGhCkE,GAAqB,yBACG,CAACV,EAASC,EAAO9B,SAASC,qBAAO,KAA5C5B,OACLA,GAASmF,EAASE,UAAUrF,GAElCmF,EAASG,2CAKFtF,UACTA,EAAQuF,iBAAiB,SAAUnB,GAEnCF,GAAqB,kBACnBlE,EAAQwF,oBAAoB,SAAUpB,YALT3C,UAAiB8B,yBASpD,CACEK,EACAM,EACAE,EACA3C,EACAoB,EACAQ,IAMEoC,EAAyCpB,eAC7C,SAACqB,EAA8BC,GACzBlD,GAAWiD,GAAYA,IAAaC,IACtC3B,IACAiB,IACAb,OAGJ,CAACJ,EAA6BiB,EAAmBb,EAAc3B,IAI3DmD,EAAWhG,EACfyE,eACE,SAAAZ,OACiBoC,EAAkBjC,IAAzBH,MAGRI,GAAI,SAAAX,eACCA,GACHO,MAAAA,OAIFgC,EAAuCI,EAAepC,KAExD,CAACG,EAAKC,EAAK4B,KAITK,EAAsBzB,eAC1B,SAAgCrE,OACxBuD,EAAmB/B,EAAqBxB,EAASyB,GAEjD8C,EAAyBhB,EAAiB,MAE5CgB,EAAwB,KAEpBwB,EAAWtE,EAAaI,iBAC5B0C,GACAwB,SAEIC,EACJ,CAAC,WAAY,WAAY,SAAS7D,SAAS4D,IAC3CpD,EAEGqD,IACHzB,EAAuB0B,MAAMF,SAAW,iDAG1C9C,UACE+C,qQACkQD,sLAG/PxC,IAET,CAAC9B,EAAakB,IAKVuD,EAAatG,EACjByE,eACE,SAAAb,OAEQD,EAAmBuC,EAAoBtC,GAE5B2C,EAAoBvC,IAA7BJ,QAGRK,GAAI,SAAAX,eACCA,GACHM,QAAAA,EACAD,iBAAAA,OAIFkC,EAAuCU,EAAiB3C,KAE1D,CAACI,EAAKC,EAAK4B,EAAwCK,KAMjDM,QAAsBxD,SAAAA,EAAeyD,iBAAfzD,EAAeyD,mBAC3CnG,GAA0B,WACnBkG,GAGLvC,GAAI,SAAAX,eACCA,GACHK,iBAAkBuC,EAAoBM,UAEvC,CAACA,EAAqBvC,EAAKiC,IAE9B5F,GAA0B,kBACpBuC,IAEGqB,KACHmB,KAIG,WACDnB,KACFE,OAGH,CACDvB,EACAqB,EACAmB,EACAjB,IAIF9D,GAA0B,WACpBuC,GAEF2B,OAIG,CACL8B,WAAAA,EACAN,SAAAA,EACAxC,SAAAA,EACAmB,uBAAwBX,IAAML,iBAAiB,IAAM,MC5XzD,IAAM+C,EAAeC,gBAAc,aAWnBC,SAAgBC,IAAAA,SAAUC,IAAAA,cAGlCC,EAAiBtC,eACrB,SAAkBuC,UAChBF,EAAczG,QAAQ4G,IAAID,GAEnB,kBAAMF,EAAczG,QAAQ6G,OAAOF,MAE5C,CAACF,WAGIK,gBACLT,EAAaU,SACb,CAAElG,MAAO6F,GACTF,OCjDSQ,EAAmC,CAC9C,eACA,aACA,gBACA,YACA,aACA,UACA,WACA,cACA,aACA,YACA,eACA,cACA,UCRIC,EAAwC,CAC5C3G,IAAK,SACLC,KAAM,QACNE,OAAQ,MACRD,MAAO,OACP0G,OAAQ,UAGJC,wBAEOlF,EACAmF,EACAC,EACAC,EACAC,EACAC,EACAC,EACAC,EACAC,QARA1F,iBACAmF,qBACAC,yBACAC,qBACAC,6BACAC,oBACAC,4BACAC,qBACAC,wBARA1F,gBACAmF,oBACAC,gBACAC,wBACAC,eACAC,uBACAC,gBACAC,cACAC,6BAGXC,OAAA,SAAO/G,UACEA,GAASgH,KAAKF,OAAS,GAAK,MAGrCG,oBAAA,SAAoBC,UACXF,KAAKR,eAAiBU,EAAKV,mBAItC,SAASW,EACP/F,EACAgG,YAAAA,IAAAA,GAAY,OAENZ,EAAe,CAAC,OAAQ,SAASnF,SAASD,UAEzC,IAAIkF,EACTlF,EACAgG,EAAYD,EAAef,EAAkBhF,IAAO,GAAS,KAC7DoF,EACAA,EAAe,QAAU,SACzBA,EAAe,SAAW,QAC1BA,EAAe,OAAS,MACxBA,EAAe,MAAQ,OACd,WAATpF,GACC,CAAC,QAAS,UAAUC,SAASD,IAO3B,IAAMiG,EAAY,CACvB5H,IAAK0H,EAAW,OAChBvH,OAAQuH,EAAW,UACnBzH,KAAMyH,EAAW,QACjBxH,MAAOwH,EAAW,UAGPG,OACPD,GAMJhB,OAAQc,EAAW,YChEfI,EAAQ,CAAC,MAAO,OAAQ,SAAU,SAM3BC,wBAMCC,eALZhI,gBACAC,iBACAC,kBACAC,cAGS8H,OAAOC,OAAOX,KAAMS,YAQtBG,mBAAP,SAA0BC,OACjBC,EAAkBD,KAARE,EAAQF,eAEpBC,QACG,IAAIpE,MACR,wEAIE9C,EAAyB8G,OAAOM,YACpCT,EAAMU,KAAI,SAAAf,SAAQ,CAACA,EAAMY,EAAMZ,YAGNa,4BAAhBG,cACUX,kBAAO,KAAfL,UACTtG,EAAOsG,GAAQiB,KAAK/H,IAAIQ,EAAOsG,GAAOgB,EAAahB,WAIhD,IAAIM,EAAc5G,wCAO3B,6BACS2G,EAAMa,OAAM,SAAAlB,UAAQmB,EAAKnB,IAAS,gCAO3C,6BACSQ,OAAOM,YACZT,EAAMe,QAAO,SAAApB,UAAQqB,EAAKrB,GAAQ,KAAGe,KAAI,SAAAf,SAAQ,CAACA,EAAMqB,EAAKrB,iBCxDnE,SAASsB,+BAAuBC,2BAAAA,yBACvBA,EAAeC,QACpB,SAACC,EAAKC,UACJD,GAAOC,EAAgB7I,EAAc6I,GAAkB,KACzD,YAaYC,WAQP,CAAEpJ,MAPTA,IAOcC,OANdA,KAMoBC,QALpBA,MAK2BC,SAJ3BA,OAImCC,QAHnCA,MAG0CC,SAF1CA,QAKF,IAAMgJ,EAAiB,CACrBrJ,IAAK,EACLC,KAAM,EACNC,MAAO,EACPC,OAAQ,EACRC,MAAO,EACPC,OAAQ,GAOGiJ,wBAuHWC,mBAAAA,IAAAA,EAA2B,SAtHjDvJ,gBACAC,iBACAC,kBACAC,mBACAC,kBACAC,cAkHS4H,OAAOC,OAAOX,KAAM8B,EAAOE,KA5G7BC,OAAP,SAAcD,UACL,IAAID,EAAOC,MAQbE,YAAP,SACEhK,EACAiK,YAAAA,IAAAA,EAOI,UAMAA,EAHFC,cAAAA,kBAGED,EAFFxI,YAAAA,aAActB,WAEZ8J,EADFE,eAAAA,gBAKEL,EAAiB,IAAID,EAFFF,EAAe3J,EAAQoK,8BAIzCF,EAAe,OAadzI,EAAYI,iBAAiB7B,GAX/BW,IAAAA,MACAC,IAAAA,OACAyJ,IAAAA,UACAC,IAAAA,WACAC,IAAAA,YACAC,IAAAA,UACAC,IAAAA,aACAC,IAAAA,YACAC,IAAAA,aACAC,IAAAA,WACAC,IAAAA,cAyBFf,EAAS,IAAID,OACRC,GACHnJ,MAvBc,eAAd0J,EACIxJ,EAAcF,GACd2I,EACE3I,EACA2J,EACAC,EACAG,EACAC,GAiBN/J,OAbc,eAAdyJ,EACIxJ,EAAcD,GACd0I,EACE1I,EACA4J,EACAC,EACAG,EACAC,aAULV,EASEL,EANEA,EAAOgB,UAAU,CACtBrK,MAHqBqJ,EAAOnJ,MAAQX,EAAQ+K,YAI5CrK,OAHsBoJ,EAAOlJ,OAASZ,EAAQgL,kBAa7CC,MAAP,kBACS,IAAIpB,KAONqB,WAAP,SAAkBzJ,SACV0J,iBACJ1J,SAAAA,EAAaE,SAASwJ,0BACtB1J,SAAAA,EAAaE,SAASyJ,wBAEtBD,EAAAA,EAAoB,OADdJ,YAAapK,aAAQ,QAAGqK,aAAcpK,aAAS,WAGhD,IAAIiJ,EAAO,CAAElJ,MAAAA,EAAOC,OAAAA,EAAQH,MAAOE,EAAOD,OAAQE,gCAiB3DyK,SAAA,kBACS1B,EAAe7B,SAaxBwD,MAAA,SAAMC,OACEtL,EAAU6H,KAAKuD,kBACd,IAAIxB,OACN5J,EACmC,mBAA3BsL,EACPA,EAAuBtL,GACvBsL,OAQRT,UAAA,SAAUhB,WACFpI,EAASoG,KAAKuD,iBAEJ7C,OAAOgD,QAAQ1B,kBAEM,YAAzB5H,OAAMpB,UACZoB,KAAQiG,EAAW,KAEfsD,EAAYtD,EAAUjG,GAE5BR,EAAOQ,IAASuJ,EAAU5D,OAAO/G,GAEjCY,EAAO+J,EAAUnE,aAAe,QAAU,WAAaxG,OAGvDY,EAAOQ,IAASpB,GAAS,SAItB,IAAI+I,EAAOnI,MAQpBgK,UAAA,SAAUC,UACD,IAAIrD,EAAc,CACvB/H,IAAKoL,EAAMpL,IAAMuH,KAAKvH,IACtBG,OAAQoH,KAAKpH,OAASiL,EAAMjL,OAC5BF,KAAMmL,EAAMnL,KAAOsH,KAAKtH,KACxBC,MAAOqH,KAAKrH,MAAQkL,EAAMlL,WAQ9BmL,SAAA,SACEC,WAEMnK,EAASoG,KAAKuD,iBACD7C,OAAOsD,OAAO3D,kBACG,KAAzBsD,OACT/J,EAAO+J,EAAUvJ,MAAQ2J,EAAOJ,EAAW/J,EAAO+J,EAAUvJ,cAEvD,IAAI2H,EAAOnI,4BAnFpB,kBACSoG,KAAKnH,MAAQmH,KAAKlH,gBCrKhBmL,wBAMOC,EACAC,EAChBC,EACAC,EACiB5D,QAJDyD,oBACAC,sBAGC1D,oBATT6D,2BACFC,mBAAoC,UACpCC,wBAAgD,kBAGtCN,iBACAC,eAGC1D,OAEZgE,kBAAkBL,EAAeC,8BAQhCI,kBAAA,SACNL,EACAC,MAGKA,OAMCK,EAGuB,mBAApBL,EACHA,EAAgBrE,KAAKkE,QAAQ9J,MAC7BiK,OAGDC,eAAiBF,EAAcZ,MAAM,CACxC7H,WACKyI,EAAczI,MACd+I,eAhBAJ,eAAiBF,KAsCnBO,eAAA,SAAeC,eAAAA,IAAAA,EAAkB,GAElC5E,KAAKuE,oBAA0C,IAApBK,SACtB5E,KAAKuE,uBAGNL,EAAuClE,KAAvCkE,QAASC,EAA8BnE,KAA9BmE,UAAWG,EAAmBtE,KAAnBsE,eACpB5I,EAA0B4I,EAA1B5I,QAASC,EAAiB2I,EAAjB3I,MAAOuB,EAAUoH,EAAVpH,MAChBsC,EACN0E,EADM1E,aAAcI,EACpBsE,EADoBtE,gBAAiBF,EACrCwE,EADqCxE,iBAAkBtF,EACvD8J,EADuD9J,KAAMmF,EAC7D2E,EAD6D3E,SAGzD3F,EAASmI,EAAOoB,QAWtBvJ,EAAO2F,EAASnF,MACdsB,EAAQtB,GAAQ8J,EAAQnE,OAAOC,KAAKS,QAAQ/E,SAG9C9B,EAAOQ,GACLR,EAAO2F,EAASnF,MAAQ8J,EAAQnE,OAAOpE,EAAMuI,EAAQzE,eAKjDoF,EAAuC,EAArB7E,KAAKS,QAAQvD,MAGjC4H,EACFpJ,EAAQkE,IACPjE,EAAM+D,GAAoBxC,EAAMwC,IACjCmF,EAEEE,EACFrJ,EAAQkE,IACPlE,EAAQgE,GAAoBxC,EAAMwC,IACnCmF,KAEGV,EAAUrE,SAEbgF,GAAYnJ,EAAM+D,GAClBqF,GAAYpJ,EAAM+D,IAGhByE,EAAUtE,SAAU,KAChBmF,GAAaxF,EAAea,EAAU5H,IAAM4H,EAAU3H,MAAM0B,KAC5D6K,GAAazF,EAAea,EAAUzH,OAASyH,EAAU1H,OAC5DyB,KAOHR,EAAOoL,GAAa7L,EAClBuC,EAAQsJ,GACNtJ,EAAQgE,GAAoB,EAC5B/D,EAAM+D,GAAoB,EAC1BkF,EACFE,EACAC,GAIFnL,EAAOqL,GAAarL,EAAOoL,GAAarJ,EAAM+D,OACzC,KACCwF,EAAMf,EAENgB,EAAezJ,EAAQwJ,EAAI9K,MAiBjCR,EAAOsL,EAAI9K,MAAQjB,EACjBgM,EAAeP,GAZfO,EAAeL,EACXA,EAAWK,EACXA,EAAeJ,EACfA,EAAWI,EACX,GASJL,EACAC,GAIFnL,EAAOsL,EAAI3F,SAASnF,MAClBR,EAAOsL,EAAI9K,MAAQ+J,EAAUpE,OAAOpE,EAAM+D,IAI9C9F,EAAOf,MAAQe,EAAOjB,MAAQiB,EAAOlB,KACrCkB,EAAOd,OAASc,EAAOhB,OAASgB,EAAOnB,QAGjC2M,EAAcrD,EAAOE,OAAOrI,UAEV,IAApBgL,SACGL,mBAAqBa,GAGrBA,KAiEDC,wBAAA,eACEC,EAActF,KAAKS,QAAnB6E,iBAEDtF,KAAK2E,iBACTb,UAAS,SAAC5D,EAAMlH,UAAWA,EAASkH,EAAKH,OAAOuF,MAChD9B,OAAM,kBAAwB,CAC7B3K,QADQA,MACmB,EAAZyM,EACfxM,SAFeA,OAEc,EAAZwM,SAQhBC,oBAAA,SAAoBH,MACrBpF,KAAKwE,0BAA4BY,SAC5BpF,KAAKwE,4BAGRJ,EAAgBpE,KAAKsE,eAAed,MAAM,CAC9C7H,MAAOyJ,GAAepF,KAAKqF,4BAGvB5E,EAAUD,EAAcI,mBAC5BwD,EAAcoB,uCAGXJ,SACEZ,wBAA0B/D,GAG1BA,wBAjOT,kBACYT,KAAKkE,QAAQ9J,UACG,WAAxB4F,KAAKmE,UAAU/J,KACX,SACA,CAAC,SAAU,SAASC,SAAS2F,KAAKmE,UAAU/J,MAC5C,MACA,sCAiIR,eACUoF,EAAiBQ,KAAKmE,UAAtB3E,eAENQ,KAAKsE,sBAGJ9E,KAJKiG,wBAKJjG,KAL2BkG,kDAYjC,kBACS1F,KAAKuF,sBAAsBI,gDAMpC,eACQP,EAAcpF,KAAK2E,iBAGnB3B,EAFmBhD,KAAKuF,oBAAoBH,GAEfQ,kBAC9B,IAAM1F,KAAQ8C,EAEjBA,EAAU9C,IAAS8C,EAAU9C,UAGxBkF,EAAYpC,UAAUA,GAAW6C,yCAM1C,0BAKQC,EAAmB9F,KAAKuF,+CAG5B7E,OAAOgD,QAAQoC,EAAiBF,eAC7B3E,KACC,kBAAmB,CAACZ,iBAErBiB,QAAO,mBAAYD,EAAK6C,QAAQjE,6BAChC8F,MAAK,0CALRC,EAKqC,MAAM,QAElB,cA0ClBC,2KACXtB,eAAA,iBAC6B3E,KAAKsE,eAAxB5I,IAAAA,QAASC,IAAAA,MAEX/B,EAASmI,EAAOoB,eAEtBvJ,EAAOnB,IAAMiD,EAAQjD,IAAMiD,EAAQ5C,OAAS,EAAI6C,EAAM7C,OAAS,EAC/Dc,EAAOhB,OAASgB,EAAOnB,IAAMkD,EAAM7C,OACnCc,EAAOlB,KAAOgD,EAAQhD,KAAOgD,EAAQ7C,MAAQ,EAAI8C,EAAM9C,MAAQ,EAC/De,EAAOjB,MAAQiB,EAAOlB,KAAOiD,EAAM9C,MACnCe,EAAOf,MAAQe,EAAOjB,MAAQiB,EAAOlB,KACrCkB,EAAOd,OAASc,EAAOhB,OAASgB,EAAOnB,IAEhCmB,MAb0BqK,GChQ/BiC,EAAkC,CACtCjI,SAAU,WACVkI,WAAY,YACZzN,KAAM,KACNC,MAAO,KACPF,IAAK,KACLG,OAAQ,MCbGwN,wBAEOC,EACRC,EACAhC,QAFQ+B,uBACRC,mBACAhC,sCAFQ+B,cACRC,sBACAhC,IAMHiC,0BAAP,SACEC,SAEaA,EAAKC,MAAM,KAAhBC,OAKFxC,EAAU7D,cAUT,CAAC6D,EARE,WAANwC,EACUpG,EAAKjB,OACR6E,EAAQ1E,aACC,UAANkH,EAAgBpG,EAAK7H,IAAM6H,EAAK1H,OAE1B,UAAN8N,EAAgBpG,EAAK5H,KAAO4H,EAAK3H,UAW1CsJ,OAAP,SACEqC,EACAgC,OAGM7F,EAAmB,CACvBvD,MAAOoJ,EAAOK,YACdrB,UAAWgB,EAAOM,gBAClBlL,QAAS4K,EAAOO,wBAKTC,EAAoBC,YAAAA,IAAAA,EAAoBT,EAAOU,iBAEpDZ,EAAWG,0BAA0BQ,GADhC7C,OAASC,OAGV8C,EACJ5G,EAAU6D,EAAQ1E,aAAe8G,EAAOY,QAAUZ,EAAOa,SAGrDC,GACFlD,EAAQ1E,cAAgB8E,EAAemB,uBACxCvB,EAAQ1E,cAAgB8E,EAAeoB,gCAGjC2B,EACPnD,EACAC,UAEO,IAAIF,EACTC,EACAC,EACAG,EACAgC,EAAOjC,gBACP5D,OAKA6G,EAAoB,UACxBA,EAAK,GAAKD,EAAcnD,EAASC,GACjCmD,EAAK,GAAKD,EACRnD,EACAC,EAAUtE,SAAWoH,EAAgB3G,EAAKjB,QAE5CiI,EAAK,GAAKD,EACRnD,EACA5D,GACG6D,EAAU5E,SAASM,SAChBoH,EAAc1H,SACd4E,EAAU5E,UACZnF,OAGNkN,EAAK,GAAKD,EACRJ,EACAG,EAAkBlD,EAAU5D,EAAK4D,EAAQ3E,SAASnF,OAEpDkN,EAAK,GAAKD,EAAcJ,EAAe3G,EAAKjB,QAC5CiI,EAAK,GAAKD,EACRJ,EACAG,EAAkB9G,EAAK4D,EAAQ3E,SAASnF,MAAQ8J,GAElDoD,EAAK,GAAKD,EACRhH,EAAU4G,EAAc1H,SAASnF,MACjCgN,EAAkBlD,EAAU5D,EAAK4D,EAAQ3E,SAASnF,OAEpDkN,EAAK,GAAKD,EACRhH,EAAU4G,EAAc1H,SAASnF,MACjCkG,EAAKjB,QAEPiI,EAAK,GAAKD,EACRhH,EAAU4G,EAAc1H,SAASnF,MACjCgN,EAAkB9G,EAAK4D,EAAQ3E,SAASnF,MAAQ8J,GAElDoD,EAAK,GAAKD,EAAchH,EAAU6D,EAAQ3E,SAASnF,MAAO+J,GAC1DmD,EAAK,IAAMD,EACThH,EAAU6D,EAAQ3E,SAASnF,MAC3B+J,EAAUtE,SAAWoH,EAAgB3G,EAAKjB,QAE5CiI,EAAK,IAAMD,EACThH,EAAU6D,EAAQ3E,SAASnF,MAC3BkG,GACG6D,EAAU5E,SAASM,SAChBoH,EAAc1H,SACd4E,EAAU5E,UACZnF,OAKCkN,EAAKhG,QACV,SAAA0F,UACEA,EAAUR,OAASF,EAAOU,WAC1BV,EAAOiB,mBAAmBlN,SAAS2M,EAAUR,gBAQ1C,IAAIJ,EADY,WAArBE,EAAOU,WAGL,IAAIf,EACF3F,EAAKjB,OACLiB,EAAKjB,OACLiF,EACAgC,EAAOjC,gBACP5D,WAECqG,EACER,EAAOY,YAAWZ,EAAOa,UAQdL,IALlBR,EACAhC,+BAOEkD,uBAAA,SAAuBtH,UACtBF,KAAKqG,WAAW/E,QAAO,SAAA0F,UAAaA,EAAU9C,UAAYhE,QAG3DuH,2BAAA,kBACCzH,KAAKqG,WAAWqB,MAAK,SAAAV,UAAaA,EAAUW,oBAG7CC,mCAAA,kBAC+C5H,KAAKqG,WACvDpF,KAAI,SAAA+F,SAAc,CACjBA,UAAAA,EACAnB,QAASmB,EAAUa,mBAGpB9B,MAAK,SAAC+B,EAAGpB,UAAMA,EAAEb,QAAUiC,EAAEjC,cANvBmB,aAWHe,sBAAA,kBACD/H,KAAKsG,OAAO0B,KAKfhI,KAAKyH,8BACLzH,KAAK4H,qCALE5H,KAAKqG,WAAW,MAmBnB4B,mBAAA,SAAmBjB,SACFhH,KAAKsG,aAApB0B,QAAME,MAGOlB,aAAqBf,SACjC,MAKHkC,EAAuBnI,KAAKwH,uBAAuBR,EAAU9C,YAErB,IAA5CiE,EAAqBC,QAAQpB,IACWA,EAAUW,qBAC3C,MAGHU,EAA+BF,EAAqBT,MACxD,SAAAV,UAAcA,EAAUW,qBAErBU,SACI,MAEHC,EACJD,EAA6BC,wBAC1BA,SACI,MAOLvI,EAJE+F,EAAmBkB,EAAUzB,sBAG3BpB,EAAc6C,EAAd7C,iBAMNpE,EAHAiH,EAAUI,iBACViB,IAAiCrB,EAExBsB,EAAoBxI,QAAU,EAAI,EAGzCqE,IAAc7D,EAAK5H,MAClB,CAAC4H,EAAK7H,IAAK6H,EAAKjB,QAAQhF,SAAS8J,IAChCmE,EAAoBxI,QACjB,EACD,EAKgBgG,EAAiBwC,EAAqBlO,MAErC2F,KAGnBwI,UAAA,SACNnD,EACA4B,EACAxK,EACAO,SAkCO,CACLG,eDtRJoH,EACA0C,EACAL,YAEIK,EAAU9C,QAAQrE,gBACbqG,MAGDvK,EAA0B2I,EAA1B3I,MAAOD,EAAmB4I,EAAnB5I,QAASwB,EAAUoH,EAAVpH,MAElBsL,EAAexB,EAAU9C,QAAQxE,iBACjC0H,EAAkB1L,EAAQ8M,GAAgB7M,EAAM6M,GAEhDpP,EAAMuN,EAAczJ,EAAMsL,GAAgB,EAC1CnP,EAAMsC,EAAM6M,GAAgBtL,EAAMsL,GAAgB,EAAI7B,EAEtD8B,EAvDR,SACEnE,EACA0C,EACAL,OAEQhL,EAA0B2I,EAA1B3I,MAAOD,EAAmB4I,EAAnB5I,QAASwB,EAAUoH,EAAVpH,MAElBsL,EAAexB,EAAU9C,QAAQxE,mBAEfsH,EAAU9C,QAAQ1E,aAErC,CAAC,MAAO,UADR,CAAC,OAAQ,SADPkJ,OAAOC,OAIRC,EACJjN,EAAM+M,GACN/M,EAAM6M,GAAgB,EACtB9M,EAAQgN,GACRxL,EAAMsL,GAAgB,EACtB7B,EACIkC,EACJlN,EAAMgN,GACNhN,EAAM6M,GAAgB,EACtB9M,EAAQiN,GACRzL,EAAMsL,GAAgB,EACtB7B,SAEMiC,EAAU,GAAKA,EAAU,IAAMC,EAAU,GAAKA,EAAU,GA6BzCC,CACrBxE,EACA0C,EACAL,GAIIoC,EAAgB/B,EAAU9C,QAAQtE,gBAElCoJ,EAAiB5B,EACnBzL,EAAM6M,GAAgB,EAAIC,EAC1B/M,EAAQqN,GAAiBrN,EAAQ8M,GAAgB,EAAI7M,EAAMoN,eAG1D7C,UARec,EAAU9C,QAAQ9J,MASrB,SACd2O,GAAgB5P,EAAM6P,EAAgB5P,EAAKC,OCyN9B4P,CACZjJ,KAAKsE,eAAed,MAAM,CAAE7H,MAAOyJ,IACnC4B,EACAhH,KAAKsG,OAAOK,aA2BZhL,WAlCoC,CACpCwK,WAAY,4BASenG,KAAKsG,OAAOzL,mBAGnCoD,SAAU,QACVxF,IAAK2M,EAAY3M,IACjBC,KAAM0M,EAAY1M,OAIlBuF,SAAU,WACVxF,IACE2M,EAAY3M,IACZuH,KAAKsE,eAAe4E,OAAOzQ,IAC3B+D,EAAc/D,IACdsE,EAActE,IAChBC,KACE0M,EAAY1M,KACZsH,KAAKsE,eAAe4E,OAAOxQ,KAC3B8D,EAAc9D,KACdqE,EAAcrE,WAShByQ,kBAAA,SAAkB/D,OAClB3K,EAAUuF,KAAKsG,OAAOzL,kBACxBmF,KAAKsE,eAAe5I,QACpB0J,EAEEU,EAAmBtF,EAAcI,mBACrCZ,KAAKsE,eAAe8E,0BAA0B3O,GAAS,WAGzCiG,OAAOgD,QACrBoC,EAAiBF,eAGiBzL,MAAK,0BAEtBM,EADJ4F,QACiBZ,aAIvB,OAGJqG,EAAiBH,oBAIf,KAHE,aAMJ/L,OAAA,SAAO4C,EAA8BO,OACpCsM,EAAoBrJ,KAAK+H,wBACzBnD,EAAkB5E,KAAKiI,mBAAmBoB,GAC1CjE,EAAciE,EAAkB1E,eAAeC,SAS9C,CACL0E,OATatJ,KAAKuI,UAClBnD,EACAiE,EACA7M,EACAO,GAMAwM,UAJgBF,EAAkBnF,QAAQ9J,KAK1C4M,UAAWqC,EACXjE,YAAAA,EACAoE,eAAgBxJ,KAAKmJ,kBAAkB/D,UC1WhCqE,wBASTnF,EACiBzJ,QAAAA,8BATHa,oBACAC,kBACAuB,kBACAgM,mBACA7Q,mBACAoD,+CAIGZ,EAEjB6F,OAAOC,OAAOX,KAAMsE,KAGfrC,OAAP,SACEtI,EACAgC,EACAD,EACAwN,EACAhM,EACAzB,EACAZ,EACA6O,OAEMrR,EAAS0J,EAAOqB,WAAWzJ,UAE1B,IAAI8P,EACT,CACE9N,MAAOoG,EAAOG,YAAYvG,EAAO,CAC/BhC,YAAAA,EACAyI,eAAe,IAEjB1G,QAASgO,EACL3H,EAAOE,OAAOJ,EAAe6H,MAC7B3H,EAAOG,YAAYxG,GACvBwB,MAAOA,EAAQ6E,EAAOG,YAAYhF,GAAS6E,EAAOoB,QAClD+F,OAAQA,EAASnH,EAAOG,YAAYgH,GAAU7Q,EAC9CA,OAAAA,EACAoD,kBACEpD,UACGoD,EAAiBwF,KAAI,SAAAqE,UACtBvD,EAAOG,YAAYoD,EAAW,CAAEjD,gBAAgB,SAItDxH,+BAIJ2I,MAAA,SAAMc,UACG,IAAImF,OAEJzJ,KACAsE,GAELtE,KAAKnF,sBAgBTuO,0BAAA,SAA0B3O,EAAiBkP,mBAAAA,IAAAA,GAAgB,IAEvD3J,KAAKnF,oBAAsB8O,EACvB,CAAC3J,KAAK3H,QACN2H,KAAKvE,kBAEawF,KAAI,SAAA2I,UAC1BA,EAAgBhG,UAAUnJ,sDAnB9B,kBACSuF,KAAKoJ,0BAA0BpJ,KAAKrE,0CAG7C,kBACSqE,KAAKtE,QAAQ7C,MAAQmH,KAAKrE,MAAM9C,0CAGzC,kBACSmH,KAAKtE,QAAQ5C,OAASkH,KAAKrE,MAAM7C,gBCjDxC+Q,EAAuC,KAgD9BC,EAWT,CACF9B,MAAM,EACNrB,YAAa,EACbC,gBAAiB,GACjBC,cAAe,EACfhM,mBAAmB,EACnBmM,UAAW,aACXO,mBAAoBpI,EACpBgI,QAAS,QACTD,QAAS,SACTgB,MAAM,EACN5C,eAAWyE,EACXrO,aAASqO,oGC7FX,SAASC,EAAqBC,EAAeC,UACpC/I,KAAKgJ,IAAIF,GAAS9I,KAAKiJ,GAAK,MAAQF,EAG7C,SAASG,EACPC,EACAC,EACArK,EACAsK,uBAES,aACSA,MAAeD,MAASD,IADjC,WAEOC,OAASD,EAAQE,KAFxB,OAGMA,QAAiBF,MAASC,IAHhC,aAIQD,EAAQE,OAAeD,KAG7BrK,EAAK9F,MAGlB,SAASqQ,EACPH,EACAC,EACArK,EACAwK,EACAT,aAEMU,EAAqBD,EAAY,GAAMJ,EAAQ,EAE/CM,UAAI,OACE,CAAC,EAAGN,KADN,IAED,CAAC,EAAG,KAFH,MAGC,CAACA,EAAOC,KAHT,KAIA,CAAC,EAAGA,MACZrK,EAAK9F,MAAMyQ,KAAK,KAEZC,EAAI5K,EAAKV,wBAA4B+K,EAErCQ,EAASR,EAAQ,EACjBS,EAAMT,EAAQ,EAAIP,EAAqBC,EAAOK,EAAQ,GACtDW,EAAMX,EAAQ,EAEdY,UAAI,OACE,CAAC,IAAKF,EAAKC,EAAKF,EAASJ,EAAmB,EAAGI,EAAQ,KADzD,IAED,CACL,IACAC,EACAV,EAAQW,EACRF,EAASJ,EACTL,EACAS,EACAT,KATM,MAWC,CAAC,IAAKW,EAAKV,EAAQS,EAAK,EAAGD,EAASJ,EAAmB,EAAGI,KAX3D,KAYA,CACN,IACAT,EAAQW,EACRV,EAAQS,EACRV,EACAS,EAASJ,EACTL,EACAS,MAEF7K,EAAK9F,MAAMyQ,KAAK,KAEZM,EAAMZ,EAAQ,EAAIP,EAAqBC,EAAOK,EAAQ,GACtDc,EAAMd,EAAQ,QAgBb,CAAC,IAAKM,EAAGE,EAAGI,UAdT,OACE,CAAC,IAAKH,EAASJ,EAAmB,EAAGQ,EAAKC,EAAKR,KADjD,IAED,CAAC,IAAKG,EAASJ,EAAmBL,EAAOa,EAAKb,EAAQc,EAAKR,KAF1D,MAGC,CAAC,IAAK,EAAGG,EAASJ,EAAmBS,EAAKb,EAAQY,EAAKP,KAHxD,KAIA,CACN,IACAN,EACAS,EAASJ,EACTL,EAAQc,EACRb,EAAQY,EACRP,MAEF1K,EAAK9F,MAAMyQ,KAAK,MAEOA,KAAK,KAGhC,SAASQ,EACPf,EACAC,EACAC,EACAtK,EACA+J,OAEMqB,EAAetB,EAAqBC,EAAOO,KAEjCtK,EAAKJ,OAAwC,CAAC,EAAG0K,GAAnC,CAACF,EAAOA,EAAQE,GAAvCI,OAAGE,cAEN5K,EAAKV,aACA,CACL,IACAoL,EACAJ,EACA,IACAD,EAAQC,EACR,IACAM,EACAP,EAAQC,EAAcc,EACtB,IACAA,EAAed,EACf,KACAK,KAAK,KAGF,CACL,IACAL,EACAI,EACA,IACAL,EAAQC,EACR,IACAD,EAAQC,EAAcc,EACtBR,EACA,IACAQ,EAAed,EACf,KACAK,KAAK,SCvGJU,EDiJQC,EAAQC,cAAsC,WAYzDhS,WAVEyQ,KAAAA,aAAO,QACPD,MAAAA,aAAQ,SACRO,YAAAA,aAAc,QACdkB,YAAAA,aAAc,cACdhB,UAAAA,aAAY,QACZiB,gBAAAA,aAAkB,cAClBpC,UAAAA,aAAY,YACZpL,MAAAA,aAAQ,KACL4C,6IAIa,WAAdwI,SACK,SAGHrJ,EAAOG,EAAUkJ,GACjBe,EAAQJ,EACRK,EAA4C,EAApCP,EAAqBC,EAAOC,GAEpC0B,EAAUzK,KAAK9H,IAAIiR,EAAOC,UAEzBtL,gBACL,SAEExF,IAAAA,GACGsH,GACH5C,WACKA,GACH0N,uBAAuB3L,EAAKV,aAAe,IAAM,gBAEnD3G,MAAO+S,EACP9S,OAAQ8S,EACRE,oBAAqB5L,EAAKJ,OAAS,WAAa,WAChDiM,QAAS1B,EAAWC,EAAOC,EAAOrK,EAAMsK,KAE1CvL,gBAAc,OAAQ,CACpB+M,KAAML,EACNM,YAAazB,EACb0B,OAAQR,EACRS,EAAG1B,EAAgBH,EAAOC,EAAOrK,EAAMwK,EAAWT,KAEpDhL,gBAAc,OAAQ,CACpB+M,KAAML,EACNQ,EAAGd,EAAkBf,EAAOC,EAAOC,EAAatK,EAAM+J,UC/L5D,SAAKsB,GACHA,2BACAA,yBACAA,mBAHF,CAAKA,IAAAA,8GCZKa,IAARC,OACA1N,IAAAA,WAE0B2N,WAAS,CACjCC,eAAgBH,EAChBI,WAAW,IAFNpR,OAAOqR,OAKRC,EAAWzU,UAAO,UAExBM,aAAU,WACJ6T,EACFK,EAAS,CACPF,gBAAgB,EAChBC,WAAW,IAEJE,EAASvU,SAClBsU,EAAS,CACPF,gBAAgB,EAChBC,WAAW,MAGd,CAACJ,EAAgBK,IAEpBlU,aAAU,gDACR4C,UACEwD,uIAGD,CAACA,IAEJpG,aAAU,WACRmU,EAASvU,SAAU,IAClB,IAEEiU,GAAmBhR,EAAMmR,gBAAmBnR,EAAMoR,UAIhD7N,EACLvD,EAAMmR,gBACN,WACOnR,EAAMmR,gBACTE,GAAS,SAAAE,eAAWA,GAAGH,WAAW,SAGtCpR,EAAMoR,WAVC,8DHrBwBlH,GACT,oBAAbzL,gDAIXsB,YACI0O,aAA4B+C,uLAK9B/C,EADuB,mBAAdvE,EACUA,IACW,iBAAdA,EACGzL,SAASgT,eAAevH,GAExBA,uCAGrBnK,UACE0O,aAA4B+C,8JEZX,SAHnBE,WAAAA,aAAa,QACbC,WAAAA,aAAa,QACbC,aAAAA,kBAEwBV,YAAS,GAA1BW,OAAMC,OAEPC,EAAUlV,SAAsB,MAEhCmV,EAASnV,SAAesT,EAAO8B,MAE/BC,EAAgBrV,UAAgB,GAEhCsV,EAAgBhR,eAAY,WAChCiR,aAAaL,EAAQhV,SACrBgV,EAAQhV,QAAU,KAClBiV,EAAOjV,QAAUoT,EAAO8B,OACvB,aAoBMI,EAAaC,EAAoBC,MAGpCP,EAAOjV,UAAYoT,EAAOqC,UAAYT,EAAQhV,SAChDoV,IAGGN,MAIDU,SACFT,GAAQ,GACRC,EAAQhV,QAAU,UAClBiV,EAAOjV,QAAUoT,EAAO8B,MAI1BD,EAAOjV,QAAUoT,EAAOsC,QACxBV,EAAQhV,QAAUE,OAAOyV,YAAW,WAClCZ,GAAQ,GACRC,EAAQhV,QAAU,KAClBiV,EAAOjV,QAAUoT,EAAO8B,OACvBN,WAILxU,aAAU,oBACCwV,IACHd,GAAQD,IACVO,IACAL,GAAQ,WAIZ7U,OAAOoF,iBAAiB,SAAUsQ,GAAU,GAErC,WACL1V,OAAOqF,oBAAoB,SAAUqQ,GAAU,GAE3CZ,EAAQhV,SACVqV,aAAaL,EAAQhV,YAGxB,CAAC8U,EAAMD,EAAcO,IAoBjB,CAACN,EAlB0B,CAChCe,wBA/DIZ,EAAOjV,UAAYoT,EAAOsC,SAAWV,EAAQhV,SAC/CoV,IAGEN,IAIJG,EAAOjV,QAAUoT,EAAOqC,SACxBT,EAAQhV,QAAUE,OAAOyV,YAAW,WAClCZ,GAAQ,GACRC,EAAQhV,QAAU,KAClBiV,EAAOjV,QAAUoT,EAAO8B,OACvBP,KAmDHW,aAAAA,EACAQ,aAAc,WACZX,EAAcnV,SAAU,GAE1B+V,YAAa,WACXZ,EAAcnV,SAAU,GAE1BgW,WAAY,WACLb,EAAcnV,SAAY8U,GAC7BC,GAAQ,GAGVI,EAAcnV,SAAU,IAIF,kBAAMsV,EAAa,GAAO,6CF/BpDpB,OAAAA,oBACAxR,kBAAAA,aAAoBiP,EAAgBjP,wBACpClB,YAAAA,aAAgC,oBAAXtB,OAAyBA,YAAS0R,IACvC7O,IAAhBH,mBACAiM,UAAAA,aAAY8C,EAAgB9C,gBAC5BO,mBAAAA,aAAqBuC,EAAgBvC,yBACrCJ,QAAAA,aAAU2C,EAAgB3C,cAC1BD,QAAAA,aAAU4C,EAAgB5C,cAC1Bc,KAAAA,aAAO8B,EAAgB9B,WACvBE,KAAAA,aAAO4B,EAAgB5B,WACvBrB,cAAAA,aAAgBiD,EAAgBjD,oBAChCD,gBAAAA,aAAkBkD,EAAgBlD,sBAClCD,YAAAA,aAAcmD,EAAgBnD,kBAC9BrB,UAAAA,aAAYwE,EAAgBxE,gBAC5BjB,gBAAAA,aAAkB,OAClB+J,IAAAA,YACAC,IAAAA,eACAC,IAAAA,cACSxT,IAATY,UAG0B4Q,YAAgB,iBAAO,CAC/C/C,UACgB,WAAdvC,EACI,SACAZ,EAAWG,0BAA0BS,GAAW,GAAG5M,KACzDkP,OAAQ,CACN3N,MAAO,CACLsC,SAAUpD,EAAoB,QAAU,WACxCpC,IAAK,EACLC,KAAM,GAERwE,MAAO,CACLe,SAAU,WACVxF,IAAK,EACLC,KAAM,QAdL0C,OAAOqR,OAmBR8B,EAAmBtW,SAAoB,MAIvCuW,WZpCNC,EACA9T,OAEM6T,EAAYvW,SAAiBwW,UAE9B9T,GAKL6T,EAAUrW,QAAUsW,EACbD,IALLA,EAAUrW,QAAU,KACbqW,GY6BSE,CAAatT,EAAOiR,GAGhCsC,EAAqB1W,SAAO,CAAE2W,WAAW,IAC/CrW,aAAU,kBACD,WAELoW,EAAmBxW,QAAQyW,WAAY,KAExC,QAKGC,GAAoBtS,eACxB,WAEEC,EACAO,OAFgBtB,IAAAA,iBAMV6I,EAAiBmF,EAAexH,OACpCtI,IAPOgC,QAAyBD,QAInBD,EAAiB,KAJ9ByB,MAYAzB,EACAZ,QACAC,SAAAA,EAAegU,aAiB6B1I,EAAWnE,OACvDqC,EAf6B,CAC7B0C,UAAAA,EACAO,mBAAAA,EACAS,KAAAA,EACA3D,gBAAAA,EACAsC,YAAAA,EACAC,gBAAAA,EACAC,cAAAA,EACAM,QAAAA,EACAD,QAAAA,EACAgB,KAAAA,EACArN,kBAAAA,IAMAjB,OAAO4C,EAAeO,GAHhByM,IAAAA,eAKFuF,EAAkB,CACtBxF,YANsBA,UAOtBD,SAPiCA,YAU9BkF,EAAUrW,SAiGrB,SAAwByF,EAAiBC,MACnCD,EAAS2L,YAAc1L,EAAK0L,iBACvB,gBAGsC,CAC7C,WACA,MACA,OACA,QACA,yBAE6B,KAApBnP,UAEPwD,EAAS0L,OAAO3N,MAAMvB,KAAUyD,EAAKyL,OAAO3N,MAAMvB,IAClDwD,EAAS0L,OAAOpM,MAAM9C,KAAUyD,EAAKyL,OAAOpM,MAAM9C,UAE3C,SAIJ,EAtHuB4U,CAAeR,EAAUrW,QAAS4W,GAAW,CACrEP,EAAUrW,QAAU4W,EAOpBJ,EAAmBxW,QAAQyW,WAAY,MACjCK,EAAQ,CAAEL,WAAW,GAC3BD,EAAmBxW,QAAU8W,EAE7BC,QAAQC,UAAUC,MAAK,WAChBH,EAAML,WACTnC,EAASsC,MAKXzV,EAAMkQ,IAAmBlQ,EAAM8U,IACjCA,EAAY5E,KAGhB,CACE7C,EACAqB,EACApB,EACAjN,EACA0K,EACA+J,EACAvT,EACAmM,EACAO,EACAJ,EACAD,EACAgB,EACArB,EACA2H,EACA1T,OAKFJ,EAAiB,CACfQ,uBAAAA,EACAvB,YAAAA,EACAgB,QAAS0R,EACTxR,kBAAAA,EACAD,SAAUiU,GACV/T,cAAAA,IAPIsD,MAAAA,WAAYN,MAAAA,SAAUxC,MAAAA,SAAUmB,MAAAA,0CTjKf4P,IAAAA,OAAQgC,IAAAA,eAAgBC,IAAAA,cAG3C5S,EAAUzD,SAAoB,MAC9B0D,EAAQ1D,SAAoB,MAG5B2G,EAAgB3G,SAAsB,IAAIoX,KAI1CC,EAAqBC,aAAW/Q,GAIhCgR,EAAgCjT,eACpC,SAAuCkT,OAC/BC,EAASD,EAAMC,OAEfC,EACJjU,EAAQvD,SAAWuD,EAAQvD,QAAQyX,SAASF,GACxCG,EAAiBlU,EAAMxD,SAAWwD,EAAMxD,QAAQyX,SAASF,GAEzDI,EAxDZ,SACElR,EACA6Q,iBAEgD7Q,uBACzC4Q,UADMA,+BACwBC,UAC1B,SAIJ,EA8CoCM,CACrCnR,EAAczG,QACdsX,UAKEI,GAAkBC,GACpBlR,EAAczG,QAAQ6X,SAAQ,mBAAoBC,IAAjBA,kBAIhCN,IAAqBE,GAAkBC,IAG5C,CAACpU,EAASC,EAAOiD,WAInBrG,aAAU,cAC0B,mBAAvB+W,SAMJA,EAAmB,CACxBE,8BAAAA,EACAS,WAAY,gDACV9U,UACEmT,uKAIEA,GACFA,SAIL,CACDgB,EACAE,EACAlB,EACA1P,IAIFrG,aAAU,cAEiB8T,GAAWgC,GADU,mBAAvBiB,SAYvBzV,SAAS4D,iBAAiB,QAASyS,GAAa,GACzC,kBAAMrW,SAAS6D,oBAAoB,QAASwS,GAAa,aAPvDA,EAAYT,GACfD,EAA8BC,IAChCpB,OAMH,CACDhC,EACAgC,EACAmB,EACAF,IAIF/W,aAAU,WACH8T,GACHzN,EAAczG,QAAQ6X,SAAQ,mBAAoBC,IAAjBA,mBAElC,CAAC5D,IAEG,CACL8D,wBAAyB,CACvBzU,QAAAA,EACAC,MAAAA,GAEFiD,cAAAA,GSmEiDwR,CAAS,CAC1D/D,OAAAA,EACAgC,eAAAA,EACAC,cAAAA,IAHM6B,MAAAA,wBAAyBvR,MAAAA,oBAMJ,CAC3ByR,aAAc7U,QAAQV,GACjB,GACD,CACErB,IAAKF,EACH6E,GACA+R,GAAwBzU,QACxB6S,IAGR+B,WAAY,CACV7W,IAAKF,EAAUuE,GAAUqS,GAAwBxU,OACjDwC,MAAO/C,EAAMkO,OAAO3N,OAEtB4U,WAAY,CACV9W,IAAK6B,GACL6C,MAAO/C,EAAMkO,OAAOpM,MACpBqM,UAAWnO,EAAMmO,WAEnBA,UAAWnO,EAAMmO,UACjBiH,cAAenE,EACXvR,EACEA,EAAcgU,qBACdP,EAAiBpW,gBAAjBsY,EAA0BnO,wBAC5B,KACJoO,YAAa,SAAA/R,SACS,oBAAb9E,SACH8W,eACE1R,gBAAcP,EAAe,CAAEE,cAAAA,GAAeD,SAAAA,IAC9C9D,IAAsB4B,GAoClC,SAA6B6I,OACvBpN,KAEqB,mBAAdoN,SACTpN,EAAUoN,MACQpN,aAAmB0U,mBAC7B,IAAIlQ,iHAIP,GAAI4I,aAAqBsH,YAC9B1U,EAAUoN,OACL,GAAyB,iBAAdA,QAChBpN,EAAU2B,SAASgT,eAAevH,UAE1B,IAAI5I,oDACsC4I,yEAG7C,CAAA,GAAIuE,aAA4B+C,mBAC9B/C,GAEP3R,EAAU2B,SAASgT,eAxBM,cA0BvB3U,EAAU2B,SAASoF,cAAc,QACzB2R,GA3Be,SA4BvB1Y,EAAQiG,MAAM0S,4GAMdhX,SAASC,KAAKgX,YAAY5Y,WAIvBA,EAvEO6Y,CAAoBzL,GACpB7I,IAEN,uEZ3G4B,SAFpC9B,QAAAA,oBACAqW,eAAAA,gBAEMC,EAAYhZ,SAAY,QAEQqU,WAAkB9T,GAAjD0Y,OAAaC,aA2Bb,CACLC,iBAtBuBF,IAAgB1Y,EAuBvC6Y,8BA1BAF,EAAe3Y,IA2Bf8Y,0BAtBwBC,MACnB5W,GAIDqW,GACFO,EAAIP,qBAEWtY,EAAuB6Y,EAAhCC,QAAwB/Y,EAAQ8Y,EAAjBE,QACvBN,EAAe,CACb1Y,IAAAA,EACAC,KAAAA,EACAG,MAAO,EACPC,OAAQ,EACRH,MAAOD,EAAO,EACdE,OAAQH,EAAM,MAQhBiD,QAAS,CACPoT,UAAW,kBAAMoC,GACjB3S,UAAW0S,EAAU9Y,QAAU,kBAAM8Y,EAAU9Y,cAAU4R,GAE3DkH,UAAAA"}