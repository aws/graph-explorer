{"version":3,"file":"react-laag.esm.js","sources":["../src/hooks.ts","../src/util.ts","../src/useTrackElements.ts","../src/useGroup.ts","../src/PlacementType.ts","../src/Sides.ts","../src/BoundsOffsets.ts","../src/Bounds.ts","../src/Placement.ts","../src/getArrowStyle.ts","../src/Placements.ts","../src/SubjectsBounds.ts","../src/useLayer.ts","../src/Arrow.ts","../src/useHover.ts","../src/Transition.ts"],"sourcesContent":["import {\n  useRef,\n  useMemo,\n  useLayoutEffect,\n  useEffect,\n  MutableRefObject,\n  useState,\n  MouseEvent\n} from \"react\";\nimport { IBounds } from \"./Bounds\";\n\n/**\n * Utility hook to track the reference of a html-element.\n * It notifies the listener when a change occured, so it can act\n * on the change\n */\nexport function useTrackRef(\n  onRefChange: (element: HTMLElement) => void\n): (node: HTMLElement | null) => void {\n  const storedReference = useRef<HTMLElement | null>(null);\n\n  // this is de function that actually gets passed to the `ref` prop\n  // on the html element. I.e.:\n  // <div ref={setter} />\n  function setter(element: HTMLElement | null) {\n    if (!element || element === storedReference.current) {\n      return;\n    }\n\n    storedReference.current = element;\n    onRefChange(element);\n  }\n\n  return setter;\n}\n\n/**\n * Utility hook that stores mutable state.\n * Since a getter function is used, it will always return the most\n * up-to-date state. This is useful when you want to get certain state within\n * an effect, without triggering the same effect when the same state changes.\n * Note: may be seen as an anti-pattern.\n */\nexport function useMutableStore<State>(initialState: State): readonly [\n  () => State,\n  {\n    (setter: (state: State) => State): void;\n    (setter: State): void;\n  }\n] {\n  const state = useRef<State>(initialState);\n\n  return useMemo(() => {\n    function set(setter: (state: State) => State): void;\n    function set(setter: State): void;\n    function set(setter: any): void {\n      if (typeof setter === \"function\") {\n        state.current = setter(state.current);\n      } else {\n        state.current = setter;\n      }\n    }\n\n    function get() {\n      return state.current;\n    }\n\n    return [get, set] as const;\n  }, []);\n}\n\n/**\n * Utility hook that keeps track of active event listeners and how\n * to remove these listeners\n */\nexport function useEventSubscriptions() {\n  const subscriptions = useRef<Array<() => void>>([]);\n\n  return useMemo(() => {\n    function hasEventSubscriptions() {\n      return subscriptions.current.length > 0;\n    }\n\n    function removeAllEventSubscriptions() {\n      for (const unsubscribe of subscriptions.current!) {\n        unsubscribe();\n      }\n\n      subscriptions.current = [];\n    }\n\n    function addEventSubscription(unsubscriber: () => void) {\n      subscriptions.current.push(unsubscriber);\n    }\n\n    return {\n      hasEventSubscriptions,\n      removeAllEventSubscriptions,\n      addEventSubscription\n    };\n  }, []);\n}\n\n/**\n * SSR-safe effect hook\n */\nexport const useIsomorphicLayoutEffect =\n  typeof window !== \"undefined\" ? useLayoutEffect : useEffect;\n\n/**\n * Utility hook that tracks an state object.\n * If `enabled=false` it will discard changes and reset the lastState to `null`\n */\nexport function useLastState<T extends unknown>(\n  currentState: T,\n  enabled: boolean\n): MutableRefObject<T | null> {\n  const lastState = useRef<T | null>(currentState);\n\n  if (!enabled) {\n    lastState.current = null;\n    return lastState;\n  }\n\n  lastState.current = currentState;\n  return lastState;\n}\n\nexport type UseMousePositionAsTriggerOptions = {\n  /**\n   * @description Should the position be actively tracked?\n   * @default true\n   */\n  enabled?: boolean;\n  /**\n   * @description Should `handleMouseEvent` preventDefault()?\n   * @default true\n   */\n  preventDefault?: boolean;\n};\n\nexport type UseMousePositionAsTriggerProps = {\n  hasMousePosition: boolean;\n  resetMousePosition: () => void;\n  handleMouseEvent: (evt: MouseEvent) => void;\n  trigger: {\n    getBounds: () => IBounds;\n    getParent?: () => HTMLElement;\n  };\n  parentRef: MutableRefObject<any>;\n};\n\nconst EMPTY_BOUNDS: IBounds = {\n  top: 0,\n  left: 0,\n  right: 1,\n  bottom: 1,\n  width: 1,\n  height: 1\n};\n\n/**\n * @description Utility hook that lets you use the mouse-position as source of the trigger.\n * This is useful in scenario's like context-menu's.\n *\n * @example\n * ```tsx\n * const {\n *  hasMousePosition,\n *  resetMousePosition,\n *  handleMouseEvent,\n *  trigger\n *  } = useMousePositionAsTrigger();\n *\n * const { renderLayer, layerProps } = useLayer({\n *  isOpen: hasMousePosition,\n *  trigger,\n *  onOutsideClick: resetMousePosition\n * });\n *\n * return (\n *  <>\n *   {isOpen && renderLayer(<div {...layerProps} />)}\n *   <div onContextMenu={handleMouseEvent} />\n *  </>\n * );\n * ```\n */\nexport function useMousePositionAsTrigger({\n  enabled = true,\n  preventDefault = true\n}: UseMousePositionAsTriggerOptions = {}): UseMousePositionAsTriggerProps {\n  const parentRef = useRef<any>(null);\n\n  const [mouseBounds, setMouseBounds] = useState<IBounds>(EMPTY_BOUNDS);\n\n  function resetMousePosition() {\n    setMouseBounds(EMPTY_BOUNDS);\n  }\n\n  const hasMousePosition = mouseBounds !== EMPTY_BOUNDS;\n\n  function handleMouseEvent(evt: MouseEvent) {\n    if (!enabled) {\n      return;\n    }\n\n    if (preventDefault) {\n      evt.preventDefault();\n    }\n    const { clientX: left, clientY: top } = evt;\n    setMouseBounds({\n      top,\n      left,\n      width: 1,\n      height: 1,\n      right: left + 1,\n      bottom: top + 1\n    });\n  }\n\n  return {\n    hasMousePosition,\n    resetMousePosition,\n    handleMouseEvent,\n    trigger: {\n      getBounds: () => mouseBounds!,\n      getParent: parentRef.current ? () => parentRef.current : undefined\n    },\n    parentRef\n  };\n}\n","/**\n * Convert a pixel value into a numeric value\n * @param value string value (ie. '12px')\n */\nexport function getPixelValue(value: string) {\n  return parseFloat(value.replace(\"px\", \"\"));\n}\n\n/**\n * Returns a numeric value that doesn't exceed min or max\n */\nexport function limit(value: number, min: number, max: number): number {\n  return value < min ? min : value > max ? max : value;\n}\n\n/**\n * Utility function which ensures whether a value is truthy\n */\nexport function isSet<T>(value: T | null | undefined): value is T {\n  return value === null || value === undefined ? false : true;\n}\n\n/**\n * Utility function that let's you assign multiple references to a 'ref' prop\n * @param refs list of MutableRefObject's and / or callbacks\n */\nexport function mergeRefs(...refs: any[]) {\n  return (element: HTMLElement | null) => {\n    for (const ref of refs) {\n      if (!ref) {\n        continue;\n      }\n\n      if (typeof ref === \"function\") {\n        ref(element);\n      } else {\n        ref.current = element!;\n      }\n    }\n  };\n}\n","import { useCallback, useRef, useEffect } from \"react\";\nimport warning from \"tiny-warning\";\nimport { ResizeObserverClass, ScrollOffsets, BorderOffsets } from \"./types\";\nimport {\n  useTrackRef,\n  useMutableStore,\n  useEventSubscriptions,\n  useIsomorphicLayoutEffect\n} from \"./hooks\";\nimport { getPixelValue } from \"./util\";\nimport { IBounds } from \"./Bounds\";\n\n/**\n * Utility to get the correct ResizeObserver class\n */\nexport function getResizeObserver(\n  environment: Window | undefined,\n  polyfill: ResizeObserverClass | undefined\n): ResizeObserverClass | undefined {\n  if (typeof environment === \"undefined\") {\n    return undefined;\n  }\n\n  return polyfill || (environment as any).ResizeObserver;\n}\n\n/**\n * Utility function that given a element traverses up in the html-hierarchy\n * to find and return all ancestors that have scroll behavior\n */\nexport function findScrollContainers(\n  element: HTMLElement | null,\n  environment?: Window\n): HTMLElement[] {\n  const result: HTMLElement[] = [];\n\n  if (!element || !environment || element === document.body) {\n    return result;\n  }\n\n  const { overflow, overflowX, overflowY } =\n    environment.getComputedStyle(element);\n\n  if (\n    [overflow, overflowX, overflowY].some(prop =>\n      [\"auto\", \"scroll\"].includes(prop)\n    )\n  ) {\n    result.push(element);\n  }\n\n  return [\n    ...result,\n    ...findScrollContainers(element.parentElement, environment)\n  ];\n}\n\nfunction createReferenceError(subject: string) {\n  return `react-laag: Could not find a valid reference for the ${subject} element. There might be 2 causes:\n   - Make sure that the 'ref' is set correctly on the ${subject} element when isOpen: true. Also make sure your component forwards the ref with \"forwardRef()\".\n   - Make sure that you are actually rendering the ${subject} when the isOpen prop is set to true`;\n}\n\nexport type OnChangeElements = {\n  layer: HTMLElement;\n  trigger: HTMLElement;\n  arrow: HTMLElement | null;\n  scrollContainers: HTMLElement[];\n};\n\nexport type UseTrackElementsProps = {\n  enabled: boolean;\n  onChange: (\n    elements: OnChangeElements,\n    scrollOffsets: ScrollOffsets,\n    borderOffsets: BorderOffsets\n  ) => void;\n  environment: Window | undefined;\n  ResizeObserverPolyfill: ResizeObserverClass | undefined;\n  overflowContainer: boolean;\n  triggerOption?: {\n    getBounds: () => IBounds;\n    getParent?: () => HTMLElement;\n  };\n};\n\ntype UseTrackElementsReturnValue = {\n  triggerRef: (element: HTMLElement | null) => void;\n  layerRef: (element: HTMLElement | null) => void;\n  arrowRef: React.MutableRefObject<HTMLElement | null>;\n  closestScrollContainer: HTMLElement | null;\n};\n\n/**\n * This hook has the responsibility to track the bounds of:\n * - the trigger element\n * - the layer element\n * - the arrow element\n * - the scroll-containers of which the trigger element is a descendant of\n *\n * It will call the `onChange` callback with a collection of these elements when any\n * of the tracked elements bounds have changed\n *\n * It will detect these changes by listening:\n * - when the reference of the trigger element changes\n * - when the reference of the layer element changes\n * - when the trigger, layer or document body changes in size\n * - when the user scrolls the page, or any of the scroll containers\n */\nexport function useTrackElements({\n  // should we track the bounds?\n  enabled,\n  // call this callback when the bounds have changed\n  onChange,\n  // optional environment (i.e. when using iframes)\n  environment,\n  // optionally inject a polyfill when the browser does not support it\n  // out of the box\n  ResizeObserverPolyfill,\n  // behavior will alter slightly when `overflowContainer` is enabled\n  overflowContainer,\n  // the optional trigger-option provided by the user\n  triggerOption\n}: UseTrackElementsProps): UseTrackElementsReturnValue {\n  // get the correct reference to the ResizeObserver class\n  const ResizeObserver = getResizeObserver(environment, ResizeObserverPolyfill);\n\n  // warn the user when no valid ResizeObserver class could be found\n  useEffect(() => {\n    warning(\n      ResizeObserver,\n      `This browser does not support ResizeObserver out of the box. We recommend to add a polyfill in order to utilize the full capabilities of react-laag. See: https://github.com/everweij/react-laag#resize-observer`\n    );\n  }, [ResizeObserver]);\n\n  // keep reference of the optional arrow-component\n  const arrowRef = useRef<HTMLElement | null>(null);\n\n  // if user has provided the trigger-option we should ingore certain things elsewhere\n  const hasTriggerOption = Boolean(triggerOption);\n\n  // Keep track of mutable element related state\n  // It is generally better to use React.useState, but unfortunately that causes to many re-renders\n  const [get, set] = useMutableStore<{\n    scrollContainers: HTMLElement[];\n    trigger: HTMLElement | null;\n    layer: HTMLElement | null;\n  }>({\n    scrollContainers: [],\n    trigger: null,\n    layer: null\n  });\n\n  // utility to keep track of the scroll and resize listeners and how to unsubscribe them\n  const {\n    hasEventSubscriptions,\n    addEventSubscription,\n    removeAllEventSubscriptions\n  } = useEventSubscriptions();\n\n  // All scroll and resize changes eventually end up here, where the collection of bounds (subjectsBounds) is\n  // constructed in order to notifiy the `onBoundsChange` callback\n  const handleChange = useCallback(\n    function handleChange() {\n      const { layer, trigger, scrollContainers } = get();\n      const closestScrollContainer = scrollContainers[0];\n\n      if (!layer) {\n        throw new Error(createReferenceError(\"layer\"));\n      }\n      // ignore when user has provided the trigger-option\n      if (!trigger && !hasTriggerOption) {\n        throw new Error(createReferenceError(\"trigger\"));\n      }\n\n      let scrollOffsets: ScrollOffsets = { top: 0, left: 0 };\n      if (closestScrollContainer) {\n        const { scrollLeft, scrollTop } = closestScrollContainer;\n        scrollOffsets = {\n          top: scrollTop,\n          left: scrollLeft\n        };\n      } else {\n        const { scrollX, scrollY } = environment!;\n        scrollOffsets = {\n          top: scrollY,\n          left: scrollX\n        };\n      }\n\n      let borderOffsets: BorderOffsets = { left: 0, top: 0 };\n      if (closestScrollContainer) {\n        const { borderLeftWidth, borderTopWidth } =\n          environment!.getComputedStyle(closestScrollContainer);\n\n        borderOffsets = {\n          left: getPixelValue(borderLeftWidth) || 0,\n          top: getPixelValue(borderTopWidth) || 0\n        };\n      }\n\n      onChange(\n        {\n          layer,\n          trigger: trigger!,\n          scrollContainers,\n          arrow: arrowRef.current\n        },\n        scrollOffsets,\n        borderOffsets\n      );\n    },\n    [get, onChange, environment, arrowRef, hasTriggerOption]\n  );\n\n  // responsible for adding the scroll and resize listeners to the correct\n  // html elements\n  const addEventListeners = useCallback(\n    function addEventListeners() {\n      const { trigger, layer, scrollContainers } = get();\n\n      if (!layer) {\n        throw new Error(createReferenceError(\"layer\"));\n      }\n      if (!trigger && !hasTriggerOption) {\n        // ignore when user has provided the trigger-option\n        throw new Error(createReferenceError(\"trigger\"));\n      }\n\n      if (ResizeObserver) {\n        let ignoredInitialCall = false;\n        const observerCallback = () => {\n          if (!ignoredInitialCall) {\n            ignoredInitialCall = true;\n            return;\n          }\n\n          handleChange();\n        };\n\n        const observer = new ResizeObserver(observerCallback);\n        for (const element of [trigger, layer, document.body]) {\n          if (element) observer.observe(element);\n        }\n\n        addEventSubscription(() => {\n          for (const element of [trigger, layer, document.body]) {\n            if (element) observer.unobserve(element);\n          }\n          observer.disconnect();\n        });\n      }\n\n      const listenForScrollElements = [environment!, ...scrollContainers];\n      for (const element of listenForScrollElements) {\n        element.addEventListener(\"scroll\", handleChange);\n\n        addEventSubscription(() =>\n          element.removeEventListener(\"scroll\", handleChange)\n        );\n      }\n    },\n    [\n      get,\n      addEventSubscription,\n      handleChange,\n      environment,\n      ResizeObserver,\n      hasTriggerOption\n    ]\n  );\n\n  // when either the reference to the trigger or layer element changes\n  // we should reset the event listeners and trigger a `onChange`\n  const resetWhenReferenceChangedWhileTracking = useCallback(\n    (previous: HTMLElement | null, next: HTMLElement) => {\n      if (enabled && previous && previous !== next) {\n        removeAllEventSubscriptions();\n        addEventListeners();\n        handleChange();\n      }\n    },\n    [removeAllEventSubscriptions, addEventListeners, handleChange, enabled]\n  );\n\n  // Logic when reference to layer changes\n  const layerRef = useTrackRef(\n    useCallback(\n      layer => {\n        const { layer: previousLayer } = get();\n\n        // store new reference\n        set(state => ({\n          ...state,\n          layer\n        }));\n\n        // check if we should reset the event listeners\n        resetWhenReferenceChangedWhileTracking(previousLayer, layer);\n      },\n      [get, set, resetWhenReferenceChangedWhileTracking]\n    )\n  );\n\n  const getScrollContainers = useCallback(\n    function handleScrollContainers(element: HTMLElement) {\n      const scrollContainers = findScrollContainers(element, environment);\n\n      const closestScrollContainer = scrollContainers[0];\n\n      if (closestScrollContainer) {\n        // Check if we should warn the user about 'position: relative; stuff...'\n        const position = environment!.getComputedStyle(\n          closestScrollContainer\n        ).position;\n\n        const closestScrollContainerHasCorrectStyling =\n          [\"relative\", \"absolute\", \"fixed\"].includes(position) ||\n          overflowContainer;\n\n        if (!closestScrollContainerHasCorrectStyling) {\n          closestScrollContainer.style.position = \"relative\";\n        }\n\n        warning(\n          closestScrollContainerHasCorrectStyling,\n          `react-laag: Set the 'position' style of the nearest scroll-container to 'relative', 'absolute' or 'fixed', or set the 'overflowContainer' prop to true. This is needed in order to position the layer properly. Currently the scroll-container is positioned: \"${position}\". For now, \"position: relative;\" is added for you, but this behavior might be removed in the future. Visit https://react-laag.com/docs/#position-relative for more info.`\n        );\n      }\n      return scrollContainers;\n    },\n    [environment, overflowContainer]\n  );\n\n  // Logic when reference to trigger changes\n  // Note: this will have no effect when user provided the trigger-option\n  const triggerRef = useTrackRef(\n    useCallback(\n      trigger => {\n        // collect list of scroll containers\n        const scrollContainers = getScrollContainers(trigger);\n\n        const { trigger: previousTrigger } = get();\n\n        // store new references\n        set(state => ({\n          ...state,\n          trigger,\n          scrollContainers\n        }));\n\n        // check if we should reset the event listeners\n        resetWhenReferenceChangedWhileTracking(previousTrigger, trigger);\n      },\n      [get, set, resetWhenReferenceChangedWhileTracking, getScrollContainers]\n    )\n  );\n\n  // when user has provided the trigger-option, it monitors the optional parent-element\n  // in order to determine the scroll-containers\n  const triggerOptionParent = triggerOption?.getParent?.();\n  useIsomorphicLayoutEffect(() => {\n    if (!triggerOptionParent) {\n      return;\n    }\n    set(state => ({\n      ...state,\n      scrollContainers: getScrollContainers(triggerOptionParent)\n    }));\n  }, [triggerOptionParent, set, getScrollContainers]);\n\n  useIsomorphicLayoutEffect(() => {\n    if (enabled) {\n      // add event listeners if necessary\n      if (!hasEventSubscriptions()) {\n        addEventListeners();\n      }\n    }\n\n    return () => {\n      if (hasEventSubscriptions()) {\n        removeAllEventSubscriptions();\n      }\n    };\n  }, [\n    enabled,\n    hasEventSubscriptions,\n    addEventListeners,\n    removeAllEventSubscriptions\n  ]);\n\n  // run this effect after every render\n  useIsomorphicLayoutEffect(() => {\n    if (enabled) {\n      // eventually call `handleChange` with latest elements-refs\n      handleChange();\n    }\n  });\n\n  return {\n    triggerRef,\n    layerRef,\n    arrowRef,\n    closestScrollContainer: get().scrollContainers[0] || null\n  };\n}\n","import {\n  ReactNode,\n  createContext,\n  MutableRefObject,\n  useCallback,\n  useRef,\n  useContext,\n  useEffect,\n  createElement\n} from \"react\";\nimport warning from \"tiny-warning\";\n\ntype Registration = {\n  shouldCloseWhenClickedOutside: (event: MouseEvent) => boolean;\n  closeChild: () => void;\n};\n\ntype Registrations = Set<Registration>;\n\ntype RegisterFn = (registration: Registration) => () => void;\n\ntype GroupContextType = {} | RegisterFn;\n\nconst GroupContext = createContext({} as GroupContextType);\n\ntype GroupProviderProps = {\n  children: ReactNode;\n  registrations: MutableRefObject<Registrations>;\n};\n\n// Provider that wraps arround the layer in order to provide other useLayers\n// down in the hiearchy (child layers) with means to communicate with the parent.\n// This provider receives a `registrations` Set which can be used to add and\n// delete registrations.\nexport function GroupProvider({ children, registrations }: GroupProviderProps) {\n  // registration function that is used as 'context payload' for child layers\n  // to call. It returns a function to unregister.\n  const handleRegister = useCallback(\n    function register(registration: Registration) {\n      registrations.current.add(registration);\n\n      return () => registrations.current.delete(registration);\n    },\n    [registrations]\n  );\n\n  return createElement(\n    GroupContext.Provider,\n    { value: handleRegister },\n    children\n  );\n}\n\n// asks child layers if they would close given the documents click event\n// if there's one that signals not to close, return early (false)\nfunction getShouldCloseAccordingToChildren(\n  registrations: Registrations,\n  event: MouseEvent\n) {\n  for (const { shouldCloseWhenClickedOutside } of registrations) {\n    if (!shouldCloseWhenClickedOutside(event)) {\n      return false;\n    }\n  }\n\n  return true;\n}\n\ntype UseGroup = {\n  isOpen: boolean;\n  onOutsideClick?: () => void;\n  onParentClose?: () => void;\n};\n\n/**\n * Responsible for close behavior\n * When the `onOutsideClick` callback is provided by the user, it will listen for clicks\n * in the document, and tell whether the user clicked outside -> not on layer / trigger.\n * It keeps track of nested useLayers a.k.a child layers (`registrations` Set), through which\n * we can ask whether they `shouldCloseWhenClickedOutside`, or tell them to close.\n *\n * Behavior:\n * - `onOutsideClick` only works on the most outer parent, and not on children. The parent will ask\n *   the child layers whether they would close, and will handle accordingly. The parent may\n *   command the children to close indirectly with the help of `onParentClose`\n * - When the parent just was closed, it will make sure that any children will also close\n *   with the help of `onParentClose`\n */\nexport function useGroup({ isOpen, onOutsideClick, onParentClose }: UseGroup) {\n  // store references to the dom-elements\n  // we need these to later determine wether the clicked outside or not\n  const trigger = useRef<HTMLElement>(null!);\n  const layer = useRef<HTMLElement>(null!);\n\n  // a Set which keeps track of callbacks given by the child layers through context\n  const registrations = useRef<Registrations>(new Set());\n\n  // if this instance is a child itself, we should use this function to register\n  // some callbacks to the parent\n  const possibleRegisterFn = useContext(GroupContext);\n\n  // recursively checks whether to close or not. This mechanism has some similarities\n  // with event bubbling.\n  const shouldCloseWhenClickedOutside = useCallback(\n    function shouldCloseWhenClickedOutside(event: MouseEvent) {\n      const target = event.target as HTMLElement;\n\n      const clickedOnTrigger =\n        trigger.current && trigger.current.contains(target);\n      const clickedOnLayer = layer.current && layer.current.contains(target);\n\n      const shouldCloseAccordingToChildren = getShouldCloseAccordingToChildren(\n        registrations.current,\n        event\n      );\n\n      // when clicked on own layer, but the child would have closed ->\n      // let child close\n      if (clickedOnLayer && shouldCloseAccordingToChildren) {\n        registrations.current.forEach(({ closeChild }) => closeChild());\n      }\n\n      return (\n        !clickedOnTrigger && !clickedOnLayer && shouldCloseAccordingToChildren\n      );\n    },\n    [trigger, layer, registrations]\n  );\n\n  // registration stuff\n  useEffect(() => {\n    if (typeof possibleRegisterFn !== \"function\") {\n      return;\n    }\n\n    // 'possibleRegisterFn' will return a function that will unregister\n    // on cleanup\n    return possibleRegisterFn({\n      shouldCloseWhenClickedOutside,\n      closeChild: () => {\n        warning(\n          onParentClose,\n          `react-laag: You are using useLayer() in a nested setting but forgot to set the 'onParentClose()' callback in the options. This could lead to unexpected behavior.`\n        );\n\n        if (onParentClose) {\n          onParentClose();\n        }\n      }\n    });\n  }, [\n    possibleRegisterFn,\n    shouldCloseWhenClickedOutside,\n    onParentClose,\n    registrations\n  ]);\n\n  // document click handling\n  useEffect(() => {\n    const isChild = typeof possibleRegisterFn === \"function\";\n    const shouldNotListen = !isOpen || !onOutsideClick || isChild;\n    if (shouldNotListen) {\n      return;\n    }\n\n    function handleClick(event: MouseEvent) {\n      if (shouldCloseWhenClickedOutside(event)) {\n        onOutsideClick!();\n      }\n    }\n\n    document.addEventListener(\"click\", handleClick, true);\n    return () => document.removeEventListener(\"click\", handleClick, true);\n  }, [\n    isOpen,\n    onOutsideClick,\n    shouldCloseWhenClickedOutside,\n    possibleRegisterFn\n  ]);\n\n  // When this 'useLayer' gets closed -> tell child layers to close as well\n  useEffect(() => {\n    if (!isOpen) {\n      registrations.current.forEach(({ closeChild }) => closeChild());\n    }\n  }, [isOpen]);\n\n  return {\n    closeOnOutsideClickRefs: {\n      trigger,\n      layer\n    },\n    registrations\n  };\n}\n","export const PLACEMENT_TYPES: PlacementType[] = [\n  \"bottom-start\",\n  \"bottom-end\",\n  \"bottom-center\",\n  \"top-start\",\n  \"top-center\",\n  \"top-end\",\n  \"left-end\",\n  \"left-center\",\n  \"left-start\",\n  \"right-end\",\n  \"right-center\",\n  \"right-start\",\n  \"center\"\n];\n\nexport type PlacementType =\n  | \"bottom-start\"\n  | \"bottom-end\"\n  | \"bottom-center\"\n  | \"top-start\"\n  | \"top-center\"\n  | \"top-end\"\n  | \"left-end\"\n  | \"left-center\"\n  | \"left-start\"\n  | \"right-end\"\n  | \"right-center\"\n  | \"right-start\"\n  | \"center\";\n","export type BoundSideProp = \"top\" | \"left\" | \"bottom\" | \"right\";\nexport type SideProp = BoundSideProp | \"center\";\ntype SizeProp = \"width\" | \"height\";\ntype CssProp = \"top\" | \"left\";\n\nconst OPPOSITES: Record<SideProp, SideProp> = {\n  top: \"bottom\",\n  left: \"right\",\n  bottom: \"top\",\n  right: \"left\",\n  center: \"center\"\n};\n\nclass SideBase<T extends SideProp> {\n  constructor(\n    readonly prop: T,\n    readonly opposite: SideBase<T>,\n    readonly isHorizontal: boolean,\n    readonly sizeProp: SizeProp,\n    readonly oppositeSizeProp: SizeProp,\n    readonly cssProp: CssProp,\n    readonly oppositeCssProp: CssProp,\n    readonly isCenter: boolean,\n    readonly isPush: boolean // left | top\n  ) {}\n\n  factor(value: number) {\n    return value * (this.isPush ? 1 : -1);\n  }\n\n  isOppositeDirection(side: SideBase<any>) {\n    return this.isHorizontal !== side.isHorizontal;\n  }\n}\n\nfunction createSide<T extends SideProp>(\n  prop: T,\n  recursive = true\n): SideBase<T> {\n  const isHorizontal = [\"left\", \"right\"].includes(prop);\n\n  return new SideBase<T>(\n    prop,\n    recursive ? createSide<T>((OPPOSITES as any)[prop], false) : null!,\n    isHorizontal,\n    isHorizontal ? \"width\" : \"height\",\n    isHorizontal ? \"height\" : \"width\",\n    isHorizontal ? \"left\" : \"top\",\n    isHorizontal ? \"top\" : \"left\",\n    prop === \"center\",\n    ![\"right\", \"bottom\"].includes(prop)\n  );\n}\n\nexport type BoundSideType = SideBase<BoundSideProp>;\nexport type SideType = SideBase<SideProp>;\n\nexport const BoundSide = {\n  top: createSide(\"top\") as BoundSideType,\n  bottom: createSide(\"bottom\") as BoundSideType,\n  left: createSide(\"left\") as BoundSideType,\n  right: createSide(\"right\") as BoundSideType\n};\n\nexport const Side = {\n  ...(BoundSide as {\n    top: SideType;\n    left: SideType;\n    bottom: SideType;\n    right: SideType;\n  }),\n  center: createSide(\"center\")\n};\n","export interface IBoundsOffsets {\n  top: number;\n  left: number;\n  right: number;\n  bottom: number;\n}\n\nconst SIDES = [\"top\", \"left\", \"bottom\", \"right\"] as (keyof IBoundsOffsets)[];\n\n/**\n * A class containing the positional properties which represent the distance\n * between two Bounds instances for each side\n */\nexport class BoundsOffsets implements IBoundsOffsets {\n  top!: number;\n  left!: number;\n  right!: number;\n  bottom!: number;\n\n  constructor(offsets: IBoundsOffsets) {\n    return Object.assign(this, offsets);\n  }\n\n  /**\n   * Takes multiple BoundsOffets instances and creates a new BoundsOffsets instance\n   * by taking the smallest value for each side\n   * @param boundsOffsets list of BoundsOffsets instances\n   */\n  static mergeSmallestSides(boundsOffsets: BoundsOffsets[]): BoundsOffsets {\n    const [first, ...rest] = boundsOffsets;\n\n    if (!first) {\n      throw new Error(\n        \"Please provide at least 1 bounds objects in order to merge\"\n      );\n    }\n\n    const result: IBoundsOffsets = Object.fromEntries(\n      SIDES.map(side => [side, first[side]])\n    ) as any;\n\n    for (const boundsOffset of rest) {\n      for (const side of SIDES) {\n        result[side] = Math.min(result[side], boundsOffset[side]);\n      }\n    }\n\n    return new BoundsOffsets(result);\n  }\n\n  /**\n   * Checks whether all sides sides are positive, meaning the corresponding Bounds instance\n   * fits perfectly within a parent Bounds instance\n   */\n  get allSidesArePositive(): boolean {\n    return SIDES.every(side => this[side] >= 0);\n  }\n\n  /**\n   * Returns a partial IBoundsOffsets with sides that are negative, meaning sides aren't entirely\n   * visible in respect to a parent Bounds instance\n   */\n  get negativeSides(): Partial<IBoundsOffsets> {\n    return Object.fromEntries(\n      SIDES.filter(side => this[side] < 0).map(side => [side, this[side]])\n    ) as Partial<IBoundsOffsets>;\n  }\n}\n","import { BoundSide, BoundSideProp, BoundSideType } from \"./Sides\";\nimport { BoundsOffsets } from \"./BoundsOffsets\";\nimport { getPixelValue } from \"./util\";\n\n/**\n * Utility function that returns sum of various computed styles\n * @param propertyValues list of computed styles (ie. '12px')\n */\nfunction sumOfPropertyValues(...propertyValues: string[]) {\n  return propertyValues.reduce(\n    (sum, propertyValue) =>\n      sum + (propertyValue ? getPixelValue(propertyValue!) : 0),\n    0\n  );\n}\n\nexport interface IBounds {\n  top: number;\n  left: number;\n  right: number;\n  bottom: number;\n  width: number;\n  height: number;\n}\n\nexport function boundsToObject({\n  top,\n  left,\n  right,\n  bottom,\n  width,\n  height\n}: IBounds): IBounds {\n  return { top, left, right, bottom, width, height };\n}\n\nconst EMPTY: IBounds = {\n  top: 0,\n  left: 0,\n  right: 0,\n  bottom: 0,\n  width: 0,\n  height: 0\n};\n\n/**\n * A class containing the positional properties of the native DOM's ClientRect\n * (`element.getBoundingClientRect()`), together with some utility methods\n */\nexport class Bounds implements IBounds {\n  top!: number;\n  left!: number;\n  right!: number;\n  bottom!: number;\n  width!: number;\n  height!: number;\n\n  /**\n   * Creates a new Bounds class\n   * @param bounds An object that adheres to the `IBounds` interface\n   */\n  static create(bounds: IBounds): Bounds {\n    return new Bounds(bounds);\n  }\n\n  /**\n   * Creates a new Bounds class from a DOM-element\n   * @param element reference to the DOM-element\n   * @param options optional options object\n   */\n  static fromElement(\n    element: HTMLElement,\n    options: {\n      /** should transforms like 'scale' taken into account? Defaults to `true` */\n      withTransform?: boolean;\n      /** reference to the window-object (needed when working with iframes for instance). Defaults to `window` */\n      environment?: Window;\n      /** should the elements scrollbars be included? Defaults to `true` */\n      withScrollbars?: boolean;\n    } = {}\n  ): Bounds {\n    const {\n      withTransform = true,\n      environment = window,\n      withScrollbars = true\n    } = options;\n\n    const plain: IBounds = boundsToObject(element.getBoundingClientRect());\n\n    let bounds: Bounds = new Bounds(plain);\n\n    if (!withTransform) {\n      const {\n        width,\n        height,\n        boxSizing,\n        borderLeft,\n        borderRight,\n        borderTop,\n        borderBottom,\n        paddingLeft,\n        paddingRight,\n        paddingTop,\n        paddingBottom\n      } = environment.getComputedStyle(element);\n\n      const boxWidth =\n        boxSizing === \"border-box\"\n          ? getPixelValue(width!)\n          : sumOfPropertyValues(\n              width,\n              borderLeft,\n              borderRight,\n              paddingLeft,\n              paddingRight\n            );\n\n      const boxHeight =\n        boxSizing === \"border-box\"\n          ? getPixelValue(height!)\n          : sumOfPropertyValues(\n              height,\n              borderTop,\n              borderBottom,\n              paddingTop,\n              paddingBottom\n            );\n\n      bounds = new Bounds({\n        ...bounds,\n        width: boxWidth,\n        height: boxHeight\n      });\n    }\n\n    if (!withScrollbars) {\n      const scrollbarWidth = bounds.width - element.clientWidth;\n      const scrollbarHeight = bounds.height - element.clientHeight;\n      return bounds.substract({\n        right: scrollbarWidth,\n        bottom: scrollbarHeight\n      });\n    }\n\n    return bounds;\n  }\n\n  /**\n   * Creates an empty Bounds class\n   */\n  static empty(): Bounds {\n    return new Bounds();\n  }\n\n  /**\n   * Creates a Bounds class from the window's dimensions\n   * @param environment reference to the window-object (needed when working with iframes for instance). Defaults to `window`\n   */\n  static fromWindow(environment?: Window): Bounds {\n    const scrollingElement =\n      environment?.document.scrollingElement ??\n      environment?.document.documentElement;\n    const { clientWidth: width = 0, clientHeight: height = 0 } =\n      scrollingElement ?? {};\n\n    return new Bounds({ width, height, right: width, bottom: height });\n  }\n\n  protected constructor(bounds: Partial<IBounds> = {}) {\n    return Object.assign(this, EMPTY, bounds);\n  }\n\n  /**\n   * Returns the square surface of the bounds in pixels\n   */\n  get surface(): number {\n    return this.width * this.height;\n  }\n\n  /**\n   * Returns a plain object containing only positional properties\n   */\n  toObject(): IBounds {\n    return boundsToObject(this);\n  }\n\n  /**\n   * Returns a new Bounds instance by merging two bounds\n   * @param bounds partial bounds which should be merged\n   */\n  merge(bounds: Partial<IBounds>): Bounds;\n  /**\n   * Returns a new Bounds instance by merging two bounds\n   * @param mergeFn callback which takes the current bounds and returns new merged bounds\n   */\n  merge(mergeFn: (current: IBounds) => Partial<IBounds>): Bounds;\n  merge(partialBoundsOrMergeFn: unknown): Bounds {\n    const current = this.toObject();\n    return new Bounds({\n      ...current,\n      ...(typeof partialBoundsOrMergeFn === \"function\"\n        ? partialBoundsOrMergeFn(current)\n        : partialBoundsOrMergeFn)\n    });\n  }\n\n  /**\n   * Return a new Bounds instance by subtracting each property of the provided IBounds object\n   * @param bounds partial IBounds object to substract with\n   */\n  substract(bounds: Partial<IBounds>): Bounds {\n    const result = this.toObject();\n\n    const entries = Object.entries(bounds) as [keyof IBounds, number][];\n\n    for (const [prop, value] of entries) {\n      if (prop in BoundSide) {\n        // if `prop` is one of 'top', 'left', 'bottom' or 'right'...\n        const boundSide = BoundSide[prop as BoundSideProp];\n        // decide if we should add or substract\n        result[prop] += boundSide.factor(value);\n        // make sure that the size-properties are also updated\n        result[boundSide.isHorizontal ? \"width\" : \"height\"] -= value;\n      } else {\n        // prop is 'width' or 'height'\n        result[prop] -= value || 0;\n      }\n    }\n\n    return new Bounds(result);\n  }\n\n  /**\n   * Returns a new BoundsOffsets instance by determining the distance for each bound-side:\n   * (child -> parent)\n   * @param child child bounds instance\n   */\n  offsetsTo(child: Bounds): BoundsOffsets {\n    return new BoundsOffsets({\n      top: child.top - this.top,\n      bottom: this.bottom - child.bottom,\n      left: child.left - this.left,\n      right: this.right - child.right\n    });\n  }\n\n  /**\n   * Return a new Bounds instance by mapping over each bound-side\n   * @param mapper callback that takes a boundSide + value in pixels, returning a new value for that side\n   */\n  mapSides(\n    mapper: (boundSide: BoundSideType, value: number) => number\n  ): Bounds {\n    const result = this.toObject();\n    const boundSides = Object.values(BoundSide) as BoundSideType[];\n    for (const boundSide of boundSides) {\n      result[boundSide.prop] = mapper(boundSide, result[boundSide.prop]);\n    }\n    return new Bounds(result);\n  }\n}\n","import { BoundSideType, SideType, BoundSide, BoundSideProp } from \"./Sides\";\nimport { PlacementType } from \"./PlacementType\";\nimport { SubjectsBounds } from \"./SubjectsBounds\";\nimport { PositionConfig, Offsets } from \"./types\";\nimport { Bounds, IBounds } from \"./Bounds\";\nimport { BoundsOffsets } from \"./BoundsOffsets\";\nimport { limit } from \"./util\";\n\n/**\n * Class for various calculations based on a placement-type. I.e 'top-left';\n */\nexport class Placement {\n  protected subjectsBounds!: SubjectsBounds;\n  private _cachedLayerBounds: Bounds | null = null;\n  private _cachedContainerOffsets: BoundsOffsets | null = null;\n\n  constructor(\n    public readonly primary: SideType,\n    public readonly secondary: SideType,\n    subjectBounds: SubjectsBounds,\n    layerDimensions: PositionConfig[\"layerDimensions\"],\n    private readonly offsets: Offsets\n  ) {\n    this.setSubjectsBounds(subjectBounds, layerDimensions);\n  }\n\n  /**\n   * Set subjectsBounds that are specific for this placement\n   * @param subjectBounds original SubjectBounds instance\n   * @param layerDimensions possible config prodvided by the user\n   */\n  private setSubjectsBounds(\n    subjectBounds: SubjectsBounds,\n    layerDimensions: PositionConfig[\"layerDimensions\"]\n  ): void {\n    // if user did not provide any layerDimensions config...\n    if (!layerDimensions) {\n      this.subjectsBounds = subjectBounds;\n      return;\n    }\n\n    // get anticipated layer-dimensions provided by the user\n    const dimensions =\n      // if the user passed a callback, call it with the layerSide corresponding to\n      // the placement\n      typeof layerDimensions === \"function\"\n        ? layerDimensions(this.primary.prop)\n        : layerDimensions;\n\n    // create new SubjectsBounds instance by merging our newly create layer-bounds\n    this.subjectsBounds = subjectBounds.merge({\n      layer: {\n        ...subjectBounds.layer,\n        ...dimensions\n      }\n    });\n  }\n\n  /**\n   * Returns the string respresentation of this placement (ie. 'top-start')\n   */\n  public get type(): PlacementType {\n    return `${this.primary.prop}-${\n      this.secondary.prop === \"center\"\n        ? \"center\"\n        : [\"bottom\", \"right\"].includes(this.secondary.prop)\n        ? \"end\"\n        : \"start\"\n    }` as PlacementType;\n  }\n\n  /**\n   * Calculates the actual boundaries based on the placement\n   * @param secondaryOffset optional offset on the secondary-side\n   */\n  public getLayerBounds(secondaryOffset = 0): Bounds {\n    // return cached version if possible\n    if (this._cachedLayerBounds && secondaryOffset === 0) {\n      return this._cachedLayerBounds;\n    }\n\n    const { primary, secondary, subjectsBounds } = this;\n    const { trigger, layer, arrow } = subjectsBounds;\n    const { isHorizontal, oppositeCssProp, oppositeSizeProp, prop, opposite } =\n      primary as BoundSideType;\n\n    const result = Bounds.empty() as IBounds;\n\n    // let's take the placement 'top-start' as an example...\n    // the offsets are the following:\n    // trigger -> 8px\n    // container -> 10px;\n    // arrow -> 2px;\n\n    // PRIMARY STUFF\n\n    // bottom = trigger.top + 8;\n    result[opposite.prop] =\n      trigger[prop] - primary.factor(this.offsets.trigger);\n\n    // top = bottom - layer.height\n    result[prop] =\n      result[opposite.prop] - primary.factor(layer[primary.sizeProp]);\n\n    // SECONDARY STUFF\n\n    // arrowOffsetBase = 4\n    const arrowOffsetBase = this.offsets.arrow * 2;\n\n    // limitMin = trigger.left - (layer.width - arrow.width) + 4\n    let limitMin =\n      trigger[oppositeCssProp] -\n      (layer[oppositeSizeProp] - arrow[oppositeSizeProp]) +\n      arrowOffsetBase;\n    // limitMax = trigger.left + (trigger.width - arrow.width) - 4\n    let limitMax =\n      trigger[oppositeCssProp] +\n      (trigger[oppositeSizeProp] - arrow[oppositeSizeProp]) -\n      arrowOffsetBase;\n\n    if (!secondary.isPush) {\n      // if secondary is bottom or right -> add the width or height of the layer\n      limitMin += layer[oppositeSizeProp];\n      limitMax += layer[oppositeSizeProp];\n    }\n\n    if (secondary.isCenter) {\n      const propertyA = (isHorizontal ? BoundSide.top : BoundSide.left).prop;\n      const propertyB = (isHorizontal ? BoundSide.bottom : BoundSide.right)\n        .prop;\n\n      // left = limit(\n      //   trigger.left + trigger.width / 2 - layer.width / 2 + secondaryOffset,\n      //   limitMin,\n      //   limitMax\n      // )\n      result[propertyA] = limit(\n        trigger[propertyA] +\n          trigger[oppositeSizeProp] / 2 -\n          layer[oppositeSizeProp] / 2 +\n          secondaryOffset,\n        limitMin,\n        limitMax\n      );\n\n      // right = left + layer.width\n      result[propertyB] = result[propertyA] + layer[oppositeSizeProp];\n    } else {\n      const sec = secondary as BoundSideType;\n\n      const triggerValue = trigger[sec.prop];\n\n      // Under some conditions, when the layer is not able to align with the trigger\n      // due to arrow-size and arrow-offsets, we need to compensate.\n      // Otherwise, the secondary-offset will have no impact\n      const arrowCompensation =\n        triggerValue < limitMin\n          ? limitMin - triggerValue\n          : triggerValue > limitMax\n          ? limitMax - triggerValue\n          : 0;\n\n      // left = limit(\n      //   trigger.left + secondaryOffset + arrowCompensation,\n      //   limitMin,\n      //   limitMax\n      // )\n      result[sec.prop] = limit(\n        triggerValue + secondaryOffset + arrowCompensation,\n        limitMin,\n        limitMax\n      );\n\n      // right = left + layer.width\n      result[sec.opposite.prop] =\n        result[sec.prop] + secondary.factor(layer[oppositeSizeProp]);\n    }\n\n    // set the correct dimensions\n    result.width = result.right - result.left;\n    result.height = result.bottom - result.top;\n\n    // create new bounds object\n    const layerBounds = Bounds.create(result);\n\n    if (secondaryOffset === 0) {\n      this._cachedLayerBounds = layerBounds;\n    }\n\n    return layerBounds;\n  }\n\n  /**\n   * Checks whether the trigger is bigger on the opposite side\n   * ie. placement \"top-start\" -> has trigger a bigger width?\n   */\n  public get triggerIsBigger() {\n    const { isHorizontal } = this.secondary;\n    const { triggerHasBiggerWidth, triggerHasBiggerHeight } =\n      this.subjectsBounds;\n\n    return (\n      (isHorizontal && triggerHasBiggerWidth) ||\n      (!isHorizontal && triggerHasBiggerHeight)\n    );\n  }\n\n  /**\n   * Checks whether the placement fits within all it's container (including container-offset)\n   */\n  public get fitsContainer(): boolean {\n    return this.getContainerOffsets().allSidesArePositive;\n  }\n\n  /**\n   * Returns the surface in square pixels of the visible part of the layer\n   */\n  public get visibleSurface(): number {\n    const layerBounds = this.getLayerBounds();\n    const containerOffsets = this.getContainerOffsets(layerBounds);\n\n    const substract = containerOffsets.negativeSides;\n    for (const side in substract) {\n      // @ts-ignore\n      substract[side] = -substract[side]; // make positive for substraction;\n    }\n\n    return layerBounds.substract(substract).surface;\n  }\n\n  /**\n   * Returns a BoundSide by looking at the most negative offset that is the opposite direction\n   */\n  public get secondaryOffsetSide(): BoundSideType | null {\n    // Given placement 'top-start' and containerOffsets { left: -20, top: -10, right: -10, bottom: 200 }...\n    // the only negative offsets on the opposite side are { left: -20, right: -10 }\n    // since we have to return only 1 side, we pick the most negative, which is 'left'\n\n    const containerOffsets = this.getContainerOffsets();\n\n    const [mostNegativeSide] =\n      Object.entries(containerOffsets.negativeSides)\n        .map(\n          ([side, value]) => [BoundSide[side as BoundSideProp], value] as const\n        )\n        .filter(([side]) => this.primary.isOppositeDirection(side))\n        .sort(([, a], [, b]) => b! - a!)?.[0] ?? [];\n\n    return mostNegativeSide || null;\n  }\n\n  /**\n   * returns getLayerBounds(), including container-offsets\n   */\n  private getLayerCollisionBounds(): Bounds {\n    const { container } = this.offsets;\n\n    return this.getLayerBounds()\n      .mapSides((side, value) => (value -= side.factor(container)))\n      .merge(({ width, height }) => ({\n        width: width + container * 2,\n        height: height + container * 2\n      }));\n  }\n\n  /**\n   * Returns a BoundsOffsets instance containing merged offsets to containers with the most\n   * negative scenario\n   */\n  public getContainerOffsets(layerBounds?: Bounds): BoundsOffsets {\n    if (this._cachedContainerOffsets && !layerBounds) {\n      return this._cachedContainerOffsets;\n    }\n\n    const subjectBounds = this.subjectsBounds.merge({\n      layer: layerBounds || this.getLayerCollisionBounds()\n    });\n\n    const offsets = BoundsOffsets.mergeSmallestSides(\n      subjectBounds.layerOffsetsToScrollContainers\n    );\n\n    if (!layerBounds) {\n      this._cachedContainerOffsets = offsets;\n    }\n\n    return offsets;\n  }\n}\n\nexport class PlacementCenter extends Placement {\n  getLayerBounds(): Bounds {\n    const { trigger, layer } = this.subjectsBounds;\n\n    const result = Bounds.empty() as IBounds;\n\n    result.top = trigger.top + trigger.height / 2 - layer.height / 2;\n    result.bottom = result.top + layer.height;\n    result.left = trigger.left + trigger.width / 2 - layer.width / 2;\n    result.right = result.left + layer.width;\n    result.width = result.right - result.left;\n    result.height = result.bottom - result.top;\n\n    return result as Bounds;\n  }\n}\n","import { limit } from \"./util\";\nimport { SubjectsBounds } from \"./SubjectsBounds\";\nimport { Placement } from \"./Placement\";\n\n// how much pixels is the center of layer removed from edge of trigger?\nfunction getNegativeOffsetBetweenLayerCenterAndTrigger(\n  subjectsBounds: SubjectsBounds,\n  placement: Placement,\n  arrowOffset: number\n) {\n  const { layer, trigger, arrow } = subjectsBounds;\n\n  const sizeProperty = placement.primary.oppositeSizeProp;\n\n  const [sideA, sideB] = !placement.primary.isHorizontal\n    ? ([\"left\", \"right\"] as const)\n    : ([\"top\", \"bottom\"] as const);\n\n  const offsetA =\n    layer[sideA] +\n    layer[sizeProperty] / 2 -\n    trigger[sideA] -\n    arrow[sizeProperty] / 2 -\n    arrowOffset;\n  const offsetB =\n    layer[sideB] -\n    layer[sizeProperty] / 2 -\n    trigger[sideB] +\n    arrow[sizeProperty] / 2 +\n    arrowOffset;\n\n  return (offsetA < 0 ? -offsetA : 0) + (offsetB > 0 ? -offsetB : 0);\n}\n\nconst STYLE_BASE: React.CSSProperties = {\n  position: \"absolute\",\n  willChange: \"top, left\",\n  left: null!,\n  right: null!,\n  top: null!,\n  bottom: null!\n};\n\nexport function getArrowStyle(\n  subjectsBounds: SubjectsBounds,\n  placement: Placement,\n  arrowOffset: number\n): React.CSSProperties {\n  if (placement.primary.isCenter) {\n    return STYLE_BASE;\n  }\n\n  const { layer, trigger, arrow } = subjectsBounds;\n\n  const sizeProperty = placement.primary.oppositeSizeProp;\n  const triggerIsBigger = trigger[sizeProperty] > layer[sizeProperty];\n\n  const min = arrowOffset + arrow[sizeProperty] / 2;\n  const max = layer[sizeProperty] - arrow[sizeProperty] / 2 - arrowOffset;\n\n  const negativeOffset = getNegativeOffsetBetweenLayerCenterAndTrigger(\n    subjectsBounds,\n    placement,\n    arrowOffset\n  );\n\n  const primarySide = placement.primary.prop;\n  const secondarySide = placement.primary.oppositeCssProp;\n\n  const secondaryValue = triggerIsBigger\n    ? layer[sizeProperty] / 2 + negativeOffset\n    : trigger[secondarySide] + trigger[sizeProperty] / 2 - layer[secondarySide];\n\n  return {\n    ...STYLE_BASE,\n    [primarySide]: \"100%\",\n    [secondarySide]: limit(secondaryValue, min, max)\n  };\n}\n","import { CSSProperties } from \"react\";\nimport {\n  BoundSide,\n  Side,\n  BoundSideType,\n  SideType,\n  BoundSideProp,\n  SideProp\n} from \"./Sides\";\nimport { PlacementType } from \"./PlacementType\";\nimport { Placement, PlacementCenter } from \"./Placement\";\nimport { SubjectsBounds } from \"./SubjectsBounds\";\nimport {\n  PositionConfig,\n  Offsets,\n  ScrollOffsets,\n  BorderOffsets,\n  DisappearType,\n  Styles\n} from \"./types\";\nimport { Bounds } from \"./Bounds\";\nimport { getArrowStyle } from \"./getArrowStyle\";\nimport { BoundsOffsets } from \"./BoundsOffsets\";\n\n/**\n * Class mostly concerned about calculating and finding the right placement\n */\nexport class Placements {\n  protected constructor(\n    public readonly placements: Placement[],\n    private config: PositionConfig,\n    private subjectsBounds: SubjectsBounds\n  ) {}\n\n  /**\n   * Converts a placement-type into a primary-side and a secondary-side\n   */\n  static getSidesFromPlacementType(\n    type: PlacementType\n  ): [BoundSideType, SideType] {\n    let [a, b] = type.split(\"-\") as unknown as [\n      keyof typeof BoundSide,\n      \"start\" | \"center\" | \"end\"\n    ];\n\n    const primary = BoundSide[a];\n    let secondary: SideType;\n    if (b === \"center\") {\n      secondary = Side.center;\n    } else if (primary.isHorizontal) {\n      secondary = b === \"start\" ? Side.top : Side.bottom;\n    } else {\n      secondary = b === \"start\" ? Side.left : Side.right;\n    }\n\n    return [primary, secondary];\n  }\n\n  /**\n   * Main static method to create a Placements instance\n   * @param subjectsBounds instance of the SubjectsBounds class\n   * @param config config provided by the user\n   */\n  static create(\n    subjectsBounds: SubjectsBounds,\n    config: PositionConfig\n  ): Placements {\n    // create offsets-object from user config\n    const offsets: Offsets = {\n      arrow: config.arrowOffset,\n      container: config.containerOffset,\n      trigger: config.triggerOffset\n    };\n\n    // function which creates a prioritized list of possible placments\n    // by looking at user-config\n    function getListOfPlacements(preferedPlacement = config.placement) {\n      const [primary, secondary] =\n        Placements.getSidesFromPlacementType(preferedPlacement);\n\n      const preferredSide =\n        BoundSide[primary.isHorizontal ? config.preferY : config.preferX];\n\n      // some priorities may alter when the trigger is bigger\n      const triggerIsBigger =\n        (!primary.isHorizontal && subjectsBounds.triggerHasBiggerWidth) ||\n        (primary.isHorizontal && subjectsBounds.triggerHasBiggerHeight);\n\n      // utility function which constructs a placement by primary and secondary sides\n      function placementFrom(\n        primary: BoundSideType,\n        secondary: SideType\n      ): Placement {\n        return new Placement(\n          primary,\n          secondary,\n          subjectsBounds,\n          config.layerDimensions,\n          offsets\n        );\n      }\n\n      // creating the list\n      let list: Placement[] = [];\n      list[0] = placementFrom(primary, secondary);\n      list[1] = placementFrom(\n        primary,\n        secondary.isCenter ? preferredSide : Side.center\n      );\n      list[2] = placementFrom(\n        primary,\n        Side[\n          (secondary.opposite.isCenter\n            ? preferredSide.opposite\n            : secondary.opposite\n          ).prop\n        ]\n      );\n      list[3] = placementFrom(\n        preferredSide,\n        triggerIsBigger ? primary : Side[primary.opposite.prop]\n      );\n      list[4] = placementFrom(preferredSide, Side.center);\n      list[5] = placementFrom(\n        preferredSide,\n        triggerIsBigger ? Side[primary.opposite.prop] : primary\n      );\n      list[6] = placementFrom(\n        BoundSide[preferredSide.opposite.prop],\n        triggerIsBigger ? primary : Side[primary.opposite.prop]\n      );\n      list[7] = placementFrom(\n        BoundSide[preferredSide.opposite.prop],\n        Side.center\n      );\n      list[8] = placementFrom(\n        BoundSide[preferredSide.opposite.prop],\n        triggerIsBigger ? Side[primary.opposite.prop] : primary\n      );\n      list[9] = placementFrom(BoundSide[primary.opposite.prop], secondary);\n      list[10] = placementFrom(\n        BoundSide[primary.opposite.prop],\n        secondary.isCenter ? preferredSide : Side.center\n      );\n      list[11] = placementFrom(\n        BoundSide[primary.opposite.prop],\n        Side[\n          (secondary.opposite.isCenter\n            ? preferredSide.opposite\n            : secondary.opposite\n          ).prop\n        ]\n      );\n\n      // only include placements that are part of 'possible-placements'\n      list = list.filter(\n        placement =>\n          placement.type === config.placement ||\n          config.possiblePlacements.includes(placement.type)\n      );\n\n      return list;\n    }\n\n    // treat placement 'center' a little bit different\n    if (config.placement === \"center\") {\n      return new Placements(\n        [\n          new PlacementCenter(\n            Side.center,\n            Side.center,\n            subjectsBounds,\n            config.layerDimensions,\n            offsets\n          ),\n          ...getListOfPlacements(\n            `${config.preferY}-${config.preferX}` as PlacementType\n          )\n        ],\n        config,\n        subjectsBounds\n      );\n    }\n\n    return new Placements(getListOfPlacements(), config, subjectsBounds);\n  }\n\n  private filterPlacementsBySide(side: SideType): Placement[] {\n    return this.placements.filter(placement => placement.primary === side);\n  }\n\n  private findFirstPlacementThatFits(): Placement | undefined {\n    return this.placements.find(placement => placement.fitsContainer);\n  }\n\n  private placementWithBiggestVisibleSurface(): Placement {\n    const [{ placement: placementWithBiggestSurface }] = this.placements\n      .map(placement => ({\n        placement,\n        surface: placement.visibleSurface\n      }))\n      // sort -> biggest surface first\n      .sort((a, b) => b.surface - a.surface);\n\n    return placementWithBiggestSurface;\n  }\n\n  private findSuitablePlacement(): Placement {\n    if (!this.config.auto) {\n      return this.placements[0];\n    }\n\n    return (\n      this.findFirstPlacementThatFits() ||\n      this.placementWithBiggestVisibleSurface()\n    );\n  }\n\n  /**\n   * secondary offset: the number of pixels between the edge of the\n   * scroll-container and the current placement, on the side of the layer\n   * that didn't fit.\n   * Eventually this secondary offset gets added / subtracted from the\n   * placement that does fit in order to move the layer closer to the\n   * position of the placement that just would not fit.\n   * This creates the effect that the layer is moving gradually from one\n   * placement to the next as the users scrolls the page or scroll-container\n   */\n  private getSecondaryOffset(placement: Placement): number {\n    const { auto, snap } = this.config;\n\n    // return early when we're not interested...\n    if (!auto || snap || placement instanceof PlacementCenter) {\n      return 0;\n    }\n\n    // if current placement fits and is prefered placement...\n    // return early\n    const placementsOnSameSide = this.filterPlacementsBySide(placement.primary);\n    const currentPlacementHasHighestPriority =\n      placementsOnSameSide.indexOf(placement) === 0;\n    if (currentPlacementHasHighestPriority && placement.fitsContainer) {\n      return 0;\n    }\n\n    const firstPlacementThatDoesNotFit = placementsOnSameSide.find(\n      placement => !placement.fitsContainer\n    );\n    if (!firstPlacementThatDoesNotFit) {\n      return 0;\n    }\n    const secondaryOffsetSide =\n      firstPlacementThatDoesNotFit.secondaryOffsetSide!;\n    if (!secondaryOffsetSide) {\n      return 0;\n    }\n\n    const containerOffsets = placement.getContainerOffsets();\n\n    // determine whether we should add or substract the secondary-offset\n    const { secondary } = placement;\n    let factor: number;\n    if (\n      placement.triggerIsBigger ||\n      firstPlacementThatDoesNotFit === placement\n    ) {\n      factor = secondaryOffsetSide.isPush ? -1 : 1;\n    } else {\n      factor =\n        secondary === Side.left ||\n        ([Side.top, Side.center].includes(secondary) &&\n          secondaryOffsetSide.isPush)\n          ? -1\n          : 1;\n    }\n\n    // get number of pixels between placement that did not fit and current\n    // placement\n    const secondaryOffset = containerOffsets[secondaryOffsetSide!.prop];\n\n    return secondaryOffset * factor;\n  }\n\n  private getStyles(\n    layerBounds: Bounds,\n    placement: Placement,\n    scrollOffsets: ScrollOffsets,\n    borderOffsets: BorderOffsets\n  ): Styles {\n    const layerStyleBase: CSSProperties = {\n      willChange: \"top, left, width, height\"\n    };\n\n    const arrow = getArrowStyle(\n      this.subjectsBounds.merge({ layer: layerBounds }),\n      placement,\n      this.config.arrowOffset\n    );\n\n    const layer: CSSProperties = this.config.overflowContainer\n      ? {\n          ...layerStyleBase,\n          position: \"fixed\",\n          top: layerBounds.top,\n          left: layerBounds.left\n        }\n      : {\n          ...layerStyleBase,\n          position: \"absolute\",\n          top:\n            layerBounds.top -\n            this.subjectsBounds.parent.top +\n            scrollOffsets.top -\n            borderOffsets.top,\n          left:\n            layerBounds.left -\n            this.subjectsBounds.parent.left +\n            scrollOffsets.left -\n            borderOffsets.left\n        };\n\n    return {\n      arrow,\n      layer\n    };\n  }\n\n  private getHasDisappeared(layerBounds: Bounds): DisappearType | null {\n    const subject = this.config.overflowContainer\n      ? this.subjectsBounds.trigger\n      : layerBounds;\n\n    const containerOffsets = BoundsOffsets.mergeSmallestSides(\n      this.subjectsBounds.offsetsToScrollContainers(subject, true)\n    );\n\n    const entries = Object.entries(\n      containerOffsets.negativeSides\n    ) as unknown as [BoundSideProp, number][];\n\n    const hasFullyDisappeared = entries.some(([prop, value]) => {\n      const side = BoundSide[prop];\n      return value <= -subject[side.sizeProp];\n    });\n\n    if (hasFullyDisappeared) {\n      return \"full\";\n    }\n\n    if (!containerOffsets.allSidesArePositive) {\n      return \"partial\";\n    }\n\n    return null;\n  }\n\n  public result(scrollOffsets: ScrollOffsets, borderOffsets: BorderOffsets) {\n    const suitablePlacement = this.findSuitablePlacement();\n    const secondaryOffset = this.getSecondaryOffset(suitablePlacement);\n    const layerBounds = suitablePlacement.getLayerBounds(secondaryOffset);\n    const styles = this.getStyles(\n      layerBounds,\n      suitablePlacement,\n      scrollOffsets,\n      borderOffsets\n    );\n    const layerSide = suitablePlacement.primary.prop as SideProp;\n\n    return {\n      styles,\n      layerSide,\n      placement: suitablePlacement,\n      layerBounds,\n      hasDisappeared: this.getHasDisappeared(layerBounds)\n    };\n  }\n}\n","import { Bounds, IBounds, boundsToObject } from \"./Bounds\";\n\ninterface ISubjectsBounds {\n  trigger: IBounds;\n  layer: IBounds;\n  arrow: IBounds;\n  parent: IBounds;\n  window: IBounds;\n  scrollContainers: IBounds[];\n}\n\nexport class SubjectsBounds implements ISubjectsBounds {\n  public readonly trigger!: Bounds;\n  public readonly layer!: Bounds;\n  public readonly arrow!: Bounds;\n  public readonly parent!: Bounds;\n  public readonly window!: Bounds;\n  public readonly scrollContainers!: Bounds[];\n\n  private constructor(\n    subjectsBounds: ISubjectsBounds,\n    private readonly overflowContainer: boolean\n  ) {\n    Object.assign(this, subjectsBounds);\n  }\n\n  static create(\n    environment: Window,\n    layer: HTMLElement,\n    trigger: HTMLElement,\n    parent: HTMLElement | undefined,\n    arrow: HTMLElement | null,\n    scrollContainers: HTMLElement[],\n    overflowContainer: boolean,\n    getTriggerBounds?: () => IBounds\n  ) {\n    const window = Bounds.fromWindow(environment);\n\n    return new SubjectsBounds(\n      {\n        layer: Bounds.fromElement(layer, {\n          environment,\n          withTransform: false\n        }),\n        trigger: getTriggerBounds\n          ? Bounds.create(boundsToObject(getTriggerBounds()))\n          : Bounds.fromElement(trigger),\n        arrow: arrow ? Bounds.fromElement(arrow) : Bounds.empty(),\n        parent: parent ? Bounds.fromElement(parent) : window,\n        window,\n        scrollContainers: [\n          window,\n          ...scrollContainers.map(container =>\n            Bounds.fromElement(container, { withScrollbars: false })\n          )\n        ]\n      },\n      overflowContainer\n    );\n  }\n\n  merge(subjectsBounds: Partial<ISubjectsBounds>) {\n    return new SubjectsBounds(\n      {\n        ...this,\n        ...subjectsBounds\n      },\n      this.overflowContainer\n    );\n  }\n\n  get layerOffsetsToScrollContainers() {\n    return this.offsetsToScrollContainers(this.layer);\n  }\n\n  get triggerHasBiggerWidth() {\n    return this.trigger.width > this.layer.width;\n  }\n\n  get triggerHasBiggerHeight() {\n    return this.trigger.height > this.layer.height;\n  }\n\n  offsetsToScrollContainers(subject: Bounds, allContainers = false) {\n    const scrollContainers =\n      this.overflowContainer && !allContainers\n        ? [this.window]\n        : this.scrollContainers;\n\n    return scrollContainers.map(scrollContainer =>\n      scrollContainer.offsetsTo(subject)\n    );\n  }\n}\n","import {\n  useCallback,\n  useState,\n  useRef,\n  createElement,\n  ReactNode,\n  ReactPortal,\n  MutableRefObject,\n  CSSProperties,\n  useEffect\n} from \"react\";\nimport { createPortal } from \"react-dom\";\nimport warning from \"tiny-warning\";\nimport {\n  Options,\n  LayerSide,\n  Styles,\n  ScrollOffsets,\n  BorderOffsets,\n  PositionConfig,\n  RefCallback,\n  Container\n} from \"./types\";\nimport { useTrackElements, OnChangeElements } from \"./useTrackElements\";\nimport { useGroup, GroupProvider } from \"./useGroup\";\nimport { PlacementType, PLACEMENT_TYPES } from \"./PlacementType\";\nimport { Placements } from \"./Placements\";\nimport { SubjectsBounds } from \"./SubjectsBounds\";\nimport { useLastState } from \"./hooks\";\nimport { isSet, mergeRefs } from \"./util\";\n\nlet GLOBAL_CONTAINER: HTMLElement | null = null;\n\nexport function setGlobalContainer(container: Container) {\n  if (typeof document === \"undefined\") {\n    return;\n  }\n\n  warning(\n    !(GLOBAL_CONTAINER instanceof HTMLElement),\n    `react-laag: You've called 'setGlobalContainer() previously'. It is recommended to only set the global container once, otherwise this may lead to unexpected behaviour.`\n  );\n\n  if (typeof container === \"function\") {\n    GLOBAL_CONTAINER = container();\n  } else if (typeof container === \"string\") {\n    GLOBAL_CONTAINER = document.getElementById(container);\n  } else {\n    GLOBAL_CONTAINER = container;\n  }\n\n  warning(\n    GLOBAL_CONTAINER instanceof HTMLElement,\n    `react-laag: You've called 'setGlobalContainer()', but it didn't result in a valid html-element`\n  );\n}\n\nexport type LayerProps = { ref: RefCallback; style: Styles[\"layer\"] };\nexport type TriggerProps = { ref: RefCallback };\nexport type UseLayerArrowProps = {\n  ref: MutableRefObject<any> | RefCallback;\n  layerSide: LayerSide;\n  style: Styles[\"arrow\"];\n};\n\nexport type UseLayerProps = {\n  renderLayer: (children: ReactNode) => ReactPortal | null;\n  triggerProps: TriggerProps;\n  layerProps: LayerProps;\n  arrowProps: UseLayerArrowProps;\n  layerSide: LayerSide;\n  triggerBounds: ClientRect | null;\n};\n\ntype State = {\n  layerSide: LayerSide;\n  styles: Styles;\n};\n\nexport const DEFAULT_OPTIONS: Required<\n  Omit<\n    Options,\n    | \"ResizeObserver\"\n    | \"environment\"\n    | \"onParentClose\"\n    | \"onOutsideClick\"\n    | \"onDisappear\"\n    | \"isOpen\"\n    | \"layerDimensions\"\n  >\n> = {\n  auto: false,\n  arrowOffset: 0,\n  containerOffset: 10,\n  triggerOffset: 0,\n  overflowContainer: true,\n  placement: \"top-center\",\n  possiblePlacements: PLACEMENT_TYPES as unknown as PlacementType[],\n  preferX: \"right\",\n  preferY: \"bottom\",\n  snap: false,\n  container: undefined!,\n  trigger: undefined!\n};\n\nexport function useLayer({\n  isOpen = false,\n  overflowContainer = DEFAULT_OPTIONS.overflowContainer,\n  environment = typeof window !== \"undefined\" ? window : undefined,\n  ResizeObserver: ResizeObserverPolyfill,\n  placement = DEFAULT_OPTIONS.placement,\n  possiblePlacements = DEFAULT_OPTIONS.possiblePlacements,\n  preferX = DEFAULT_OPTIONS.preferX,\n  preferY = DEFAULT_OPTIONS.preferY,\n  auto = DEFAULT_OPTIONS.auto,\n  snap = DEFAULT_OPTIONS.snap,\n  triggerOffset = DEFAULT_OPTIONS.triggerOffset,\n  containerOffset = DEFAULT_OPTIONS.containerOffset,\n  arrowOffset = DEFAULT_OPTIONS.arrowOffset,\n  container = DEFAULT_OPTIONS.container,\n  layerDimensions = null,\n  onDisappear,\n  onOutsideClick,\n  onParentClose,\n  trigger: triggerOption\n}: Options): UseLayerProps {\n  // initialize styles\n  const [state, setState] = useState<State>(() => ({\n    layerSide:\n      placement === \"center\"\n        ? \"center\"\n        : Placements.getSidesFromPlacementType(placement)[0].prop,\n    styles: {\n      layer: {\n        position: overflowContainer ? \"fixed\" : \"absolute\",\n        top: 0,\n        left: 0\n      },\n      arrow: {\n        position: \"absolute\",\n        top: 0,\n        left: 0\n      }\n    }\n  }));\n\n  const triggerBoundsRef = useRef<HTMLElement>(null!);\n\n  // tracks state in order for us to use read inside functions that require dependencies,\n  // like `useCallback`, without triggering an update\n  const lastState = useLastState(state, isOpen);\n\n  // track invalidations for scheduled position updates\n  const repositioningToken = useRef({ cancelled: false });\n  useEffect(() => {\n    return () => {\n      // when this hook unmounts, make sure to cancel any scheduled position updates\n      repositioningToken.current.cancelled = true;\n    };\n  }, []);\n\n  // Most important function regarding positioning\n  // It receives boundaries collected by `useTrackElements`, does some calculations,\n  // sets new styles, and handles when a layer has disappeared.\n  const handlePositioning = useCallback(\n    function handlePositioning(\n      { arrow, layer, scrollContainers, trigger }: OnChangeElements,\n      scrollOffsets: ScrollOffsets,\n      borderOffsets: BorderOffsets\n    ) {\n      const parent = scrollContainers[0];\n\n      const subjectsBounds = SubjectsBounds.create(\n        environment!,\n        layer,\n        trigger,\n        parent,\n        arrow,\n        scrollContainers,\n        overflowContainer,\n        triggerOption?.getBounds\n      );\n\n      const config: PositionConfig = {\n        placement,\n        possiblePlacements,\n        auto,\n        layerDimensions,\n        arrowOffset,\n        containerOffset,\n        triggerOffset,\n        preferX,\n        preferY,\n        snap,\n        overflowContainer\n      };\n\n      const { hasDisappeared, layerSide, styles } = Placements.create(\n        subjectsBounds,\n        config\n      ).result(scrollOffsets, borderOffsets);\n\n      const newState: State = {\n        layerSide,\n        styles\n      };\n\n      if (!lastState.current || didStateChange(lastState.current, newState)) {\n        lastState.current = newState; // optimistically update lastState to prevent infinite loop\n\n        /**\n         * Throttle state updates slightly by delaying them using an immediately\n         * resolved promise, only applying them if there is no later update.\n         * This helps for multiple updates that happens synchronously one after another.\n         */\n        repositioningToken.current.cancelled = true;\n        const token = { cancelled: false };\n        repositioningToken.current = token;\n\n        Promise.resolve().then(() => {\n          if (!token.cancelled) {\n            setState(newState);\n          }\n        });\n      }\n\n      if (isSet(hasDisappeared) && isSet(onDisappear)) {\n        onDisappear(hasDisappeared);\n      }\n    },\n    [\n      arrowOffset,\n      auto,\n      containerOffset,\n      environment,\n      layerDimensions,\n      onDisappear,\n      overflowContainer,\n      placement,\n      possiblePlacements,\n      preferX,\n      preferY,\n      snap,\n      triggerOffset,\n      lastState,\n      triggerOption\n    ]\n  );\n\n  const { triggerRef, layerRef, arrowRef, closestScrollContainer } =\n    useTrackElements({\n      ResizeObserverPolyfill,\n      environment,\n      enabled: isOpen,\n      overflowContainer,\n      onChange: handlePositioning,\n      triggerOption\n    });\n\n  const { closeOnOutsideClickRefs, registrations } = useGroup({\n    isOpen,\n    onOutsideClick,\n    onParentClose\n  });\n\n  const props: UseLayerProps = {\n    triggerProps: Boolean(triggerOption)\n      ? ({} as any) // when using the `trigger` option, make `triggerProps` useless\n      : {\n          ref: mergeRefs(\n            triggerRef,\n            closeOnOutsideClickRefs.trigger,\n            triggerBoundsRef\n          )\n        },\n    layerProps: {\n      ref: mergeRefs(layerRef, closeOnOutsideClickRefs.layer),\n      style: state.styles.layer\n    },\n    arrowProps: {\n      ref: arrowRef,\n      style: state.styles.arrow,\n      layerSide: state.layerSide\n    },\n    layerSide: state.layerSide,\n    triggerBounds: isOpen\n      ? triggerOption\n        ? triggerOption.getBounds()\n        : triggerBoundsRef.current?.getBoundingClientRect()\n      : null,\n    renderLayer: children =>\n      typeof document !== \"undefined\"\n        ? createPortal(\n            createElement(GroupProvider, { registrations, children }),\n            overflowContainer || !closestScrollContainer\n              ? getContainerElement(container)\n              : closestScrollContainer\n          )\n        : null\n  };\n\n  return props;\n}\n\nfunction didStateChange(previous: State, next: State): boolean {\n  if (previous.layerSide !== next.layerSide) {\n    return true;\n  }\n\n  const styleProps: Array<keyof CSSProperties> = [\n    \"position\",\n    \"top\",\n    \"left\",\n    \"right\",\n    \"bottom\"\n  ];\n  for (const prop of styleProps) {\n    if (\n      previous.styles.layer[prop] !== next.styles.layer[prop] ||\n      previous.styles.arrow[prop] !== next.styles.arrow[prop]\n    ) {\n      return true;\n    }\n  }\n\n  return false;\n}\n\nconst DEFAULT_CONTAINER_ID = \"layers\";\n\nfunction getContainerElement(container?: Container): HTMLElement {\n  let element: HTMLElement;\n\n  if (typeof container === \"function\") {\n    element = container();\n    if (!element || !(element instanceof HTMLElement)) {\n      throw new Error(\n        `react-laag: You've passed a function to the 'container' prop, but it returned no valid HTMLElement`\n      );\n    }\n  } else if (container instanceof HTMLElement) {\n    element = container;\n  } else if (typeof container === \"string\") {\n    element = document.getElementById(container)!;\n    if (!element) {\n      throw new Error(\n        `react-laag: You've passed element with id '${container}' to the 'container' prop, but it returned no valid HTMLElement`\n      );\n    }\n  } else if (GLOBAL_CONTAINER instanceof HTMLElement) {\n    return GLOBAL_CONTAINER;\n  } else {\n    element = document.getElementById(DEFAULT_CONTAINER_ID)!;\n    if (!element) {\n      element = document.createElement(\"div\");\n      element.id = DEFAULT_CONTAINER_ID;\n      element.style.cssText = `\n        position: absolute;\n        top: 0px;\n        left: 0px;\n        right: 0px;\n      `;\n      document.body.appendChild(element);\n    }\n  }\n\n  return element;\n}\n","import { createElement, forwardRef } from \"react\";\nimport { BoundSide, BoundSideType } from \"./Sides\";\nimport { LayerSide } from \"./types\";\n\nconst LEFT = \"left\";\nconst TOP = \"top\";\nconst BOTTOM = \"bottom\";\nconst RIGHT = \"right\";\n\nfunction getWidthBasedOnAngle(angle: number, size: number) {\n  return Math.tan(angle * (Math.PI / 180)) * size;\n}\n\nfunction getViewBox(\n  sizeA: number,\n  sizeB: number,\n  side: BoundSideType,\n  borderWidth: number\n) {\n  const map = {\n    [BOTTOM]: `0 ${-borderWidth} ${sizeB} ${sizeA}`,\n    [TOP]: `0 0 ${sizeB} ${sizeA + borderWidth}`,\n    [RIGHT]: `${-borderWidth} 0 ${sizeA} ${sizeB}`,\n    [LEFT]: `0 0 ${sizeA + borderWidth} ${sizeB}`\n  };\n\n  return map[side.prop];\n}\n\nfunction getTrianglePath(\n  sizeA: number,\n  sizeB: number,\n  side: BoundSideType,\n  roundness: number,\n  angle: number\n) {\n  const relativeRoundness = (roundness / 10) * sizeA * 2;\n\n  const A = {\n    [BOTTOM]: [0, sizeA],\n    [TOP]: [0, 0],\n    [RIGHT]: [sizeA, sizeB],\n    [LEFT]: [0, sizeB]\n  }[side.prop].join(\" \");\n\n  const B = side.isHorizontal ? `V 0` : `H ${sizeB}`;\n\n  const cPoint = sizeB / 2;\n  const c1A = sizeB / 2 + getWidthBasedOnAngle(angle, sizeA / 8);\n  const c1B = sizeA / 8;\n\n  const C = {\n    [BOTTOM]: [\"C\", c1A, c1B, cPoint + relativeRoundness, 0, cPoint, 0],\n    [TOP]: [\n      \"C\",\n      c1A,\n      sizeA - c1B,\n      cPoint + relativeRoundness,\n      sizeA,\n      cPoint,\n      sizeA\n    ],\n    [RIGHT]: [\"C\", c1B, sizeB - c1A, 0, cPoint - relativeRoundness, 0, cPoint],\n    [LEFT]: [\n      \"C\",\n      sizeA - c1B,\n      sizeB - c1A,\n      sizeA,\n      cPoint - relativeRoundness,\n      sizeA,\n      cPoint\n    ]\n  }[side.prop].join(\" \");\n\n  const d1A = sizeB / 2 - getWidthBasedOnAngle(angle, sizeA / 8);\n  const d1B = sizeA / 8;\n\n  const D = {\n    [BOTTOM]: [\"C\", cPoint - relativeRoundness, 0, d1A, d1B, A],\n    [TOP]: [\"C\", cPoint - relativeRoundness, sizeA, d1A, sizeA - d1B, A],\n    [RIGHT]: [\"C\", 0, cPoint + relativeRoundness, d1B, sizeB - d1A, A],\n    [LEFT]: [\n      \"C\",\n      sizeA,\n      cPoint + relativeRoundness,\n      sizeA - d1B,\n      sizeB - d1A,\n      A\n    ]\n  }[side.prop].join(\" \");\n\n  return [\"M\", A, B, C, D].join(\" \");\n}\n\nfunction getBorderMaskPath(\n  sizeA: number,\n  sizeB: number,\n  borderWidth: number,\n  side: BoundSideType,\n  angle: number\n) {\n  const borderOffset = getWidthBasedOnAngle(angle, borderWidth);\n\n  const [A, B] = !side.isPush ? [sizeA, sizeA - borderWidth] : [0, borderWidth];\n\n  if (side.isHorizontal) {\n    return [\n      \"M\",\n      A,\n      borderWidth,\n      \"V\",\n      sizeB - borderWidth,\n      \"L\",\n      B,\n      sizeB - borderWidth - borderOffset,\n      \"V\",\n      borderOffset + borderWidth,\n      \"Z\"\n    ].join(\" \");\n  }\n\n  return [\n    \"M\",\n    borderWidth,\n    A,\n    \"H\",\n    sizeB - borderWidth,\n    \"L\",\n    sizeB - borderWidth - borderOffset,\n    B,\n    \"H\",\n    borderOffset + borderWidth,\n    \"Z\"\n  ].join(\" \");\n}\n\nexport type ArrowProps = React.ComponentPropsWithoutRef<\"svg\"> & {\n  /**\n   * angle of triangle\n   * default is `45`\n   */\n  angle?: number;\n  /**\n   * distance in pixels between point of triangle and layer\n   * default is `8`\n   */\n  size?: number;\n  /**\n   * roundness of the point of the arrow\n   * range: 0 - 1\n   * default is `0`\n   */\n  roundness?: number;\n  /**\n   * width of the layers border\n   * default is `0`\n   */\n  borderWidth?: number;\n  /**\n   * color of the layers border\n   * default is `\"black\"`\n   */\n  borderColor?: string;\n  /**\n   * background-color of the layer\n   * default is `\"white\"`\n   */\n  backgroundColor?: string;\n  /**\n   * Given by `useLayer()` and determines the direction the arrow should\n   * be pointing to\n   */\n  layerSide?: LayerSide;\n};\n\nexport const Arrow = forwardRef<SVGSVGElement, ArrowProps>(function Arrow(\n  {\n    size = 8,\n    angle = 45,\n    borderWidth = 0,\n    borderColor = \"black\",\n    roundness = 0,\n    backgroundColor = \"white\",\n    layerSide = \"top\",\n    style = {},\n    ...rest\n  },\n  ref\n) {\n  if (layerSide === \"center\") {\n    return null;\n  }\n\n  const side = BoundSide[layerSide];\n  const sizeA = size;\n  const sizeB = getWidthBasedOnAngle(angle, size) * 2;\n\n  const maxSize = Math.max(sizeA, sizeB);\n\n  return createElement(\n    \"svg\",\n    {\n      ref,\n      ...rest,\n      style: {\n        ...style,\n        transform: `translate${side.isHorizontal ? \"Y\" : \"X\"}(-50%)`\n      },\n      width: maxSize,\n      height: maxSize,\n      preserveAspectRatio: side.isPush ? \"xMinYMin\" : \"xMaxYMax\",\n      viewBox: getViewBox(sizeA, sizeB, side, borderWidth)\n    },\n    createElement(\"path\", {\n      fill: backgroundColor,\n      strokeWidth: borderWidth,\n      stroke: borderColor,\n      d: getTrianglePath(sizeA, sizeB, side, roundness, angle)\n    }),\n    createElement(\"path\", {\n      fill: backgroundColor,\n      d: getBorderMaskPath(sizeA, sizeB, borderWidth, side, angle)\n    })\n  );\n});\n","import { useState, useRef, useCallback, useEffect, MouseEvent } from \"react\";\n\nexport type UseHoverOptions = {\n  /**\n   * Amount of milliseconds to wait while hovering before opening.\n   * Default is `0`\n   */\n  delayEnter?: number;\n  /**\n   * Amount of milliseconds to wait when mouse has left the trigger before closing.\n   * Default is `0`\n   */\n  delayLeave?: number;\n  /**\n   * Determines whether the layer should hide when the user starts scrolling.\n   * Default is `true`\n   */\n  hideOnScroll?: boolean;\n};\n\nexport type PlainCallback = (...args: any[]) => void;\n\nexport type UseHoverProps = {\n  onMouseEnter: PlainCallback;\n  onMouseLeave: PlainCallback;\n  onTouchStart: PlainCallback;\n  onTouchMove: PlainCallback;\n  onTouchEnd: PlainCallback;\n};\n\nenum Status {\n  ENTERING,\n  LEAVING,\n  IDLE\n}\n\nexport function useHover({\n  delayEnter = 0,\n  delayLeave = 0,\n  hideOnScroll = true\n}: UseHoverOptions = {}): readonly [boolean, UseHoverProps, () => void] {\n  const [show, setShow] = useState(false);\n\n  const timeout = useRef<number | null>(null);\n\n  const status = useRef<Status>(Status.IDLE);\n\n  const hasTouchMoved = useRef<boolean>(false);\n\n  const removeTimeout = useCallback(function removeTimeout() {\n    clearTimeout(timeout.current!);\n    timeout.current = null;\n    status.current = Status.IDLE;\n  }, []);\n\n  function onMouseEnter() {\n    // if was leaving, stop leaving\n    if (status.current === Status.LEAVING && timeout.current) {\n      removeTimeout();\n    }\n\n    if (show) {\n      return;\n    }\n\n    status.current = Status.ENTERING;\n    timeout.current = window.setTimeout(() => {\n      setShow(true);\n      timeout.current = null;\n      status.current = Status.IDLE;\n    }, delayEnter);\n  }\n\n  function onMouseLeave(_: MouseEvent<any>, immediate?: boolean) {\n    // if was waiting for entering,\n    // clear timeout\n    if (status.current === Status.ENTERING && timeout.current) {\n      removeTimeout();\n    }\n\n    if (!show) {\n      return;\n    }\n\n    if (immediate) {\n      setShow(false);\n      timeout.current = null;\n      status.current = Status.IDLE;\n      return;\n    }\n\n    status.current = Status.LEAVING;\n    timeout.current = window.setTimeout(() => {\n      setShow(false);\n      timeout.current = null;\n      status.current = Status.IDLE;\n    }, delayLeave);\n  }\n\n  // make sure to clear timeout on unmount\n  useEffect(() => {\n    function onScroll() {\n      if (show && hideOnScroll) {\n        removeTimeout();\n        setShow(false);\n      }\n    }\n\n    window.addEventListener(\"scroll\", onScroll, true);\n\n    return () => {\n      window.removeEventListener(\"scroll\", onScroll, true);\n\n      if (timeout.current) {\n        clearTimeout(timeout.current);\n      }\n    };\n  }, [show, hideOnScroll, removeTimeout]);\n\n  const hoverProps: UseHoverProps = {\n    onMouseEnter,\n    onMouseLeave,\n    onTouchStart: () => {\n      hasTouchMoved.current = false;\n    },\n    onTouchMove: () => {\n      hasTouchMoved.current = true;\n    },\n    onTouchEnd: () => {\n      if (!hasTouchMoved.current && !show) {\n        setShow(true);\n      }\n\n      hasTouchMoved.current = false;\n    }\n  };\n\n  return [show, hoverProps, () => onMouseLeave(null!, true)] as const;\n}\n","import { useState, useRef, useEffect } from \"react\";\nimport warning from \"tiny-warning\";\n\nexport type TransitionProps = {\n  isOpen: boolean;\n  children: (\n    isOpen: boolean,\n    onTransitionEnd: any,\n    isLeaving: boolean\n  ) => React.ReactElement;\n};\n\n/**\n * @deprecated\n * Note: this component is marked as deprecated and will be removed and a possible\n * future release\n */\nexport function Transition({\n  isOpen: isOpenExternal,\n  children\n}: TransitionProps) {\n  const [state, setState] = useState({\n    isOpenInternal: isOpenExternal,\n    isLeaving: false\n  });\n\n  const didMount = useRef(false);\n\n  useEffect(() => {\n    if (isOpenExternal) {\n      setState({\n        isOpenInternal: true,\n        isLeaving: false\n      });\n    } else if (didMount.current) {\n      setState({\n        isOpenInternal: false,\n        isLeaving: true\n      });\n    }\n  }, [isOpenExternal, setState]);\n\n  useEffect(() => {\n    warning(\n      children,\n      `react-laag: You are using 'Transition'. Note that this component is marked as deprecated and will be removed at future releases`\n    );\n  }, [children]);\n\n  useEffect(() => {\n    didMount.current = true;\n  }, []);\n\n  if (!isOpenExternal && !state.isOpenInternal && !state.isLeaving) {\n    return null;\n  }\n\n  return children(\n    state.isOpenInternal,\n    () => {\n      if (!state.isOpenInternal) {\n        setState(s => ({ ...s, isLeaving: false }));\n      }\n    },\n    state.isLeaving\n  );\n}\n"],"names":["useTrackRef","onRefChange","storedReference","useRef","setter","element","current","useMutableStore","initialState","state","useMemo","set","get","useEventSubscriptions","subscriptions","hasEventSubscriptions","length","removeAllEventSubscriptions","unsubscribe","addEventSubscription","unsubscriber","push","useIsomorphicLayoutEffect","window","useLayoutEffect","useEffect","useLastState","currentState","enabled","lastState","EMPTY_BOUNDS","top","left","right","bottom","width","height","useMousePositionAsTrigger","preventDefault","parentRef","useState","mouseBounds","setMouseBounds","resetMousePosition","hasMousePosition","handleMouseEvent","evt","clientX","clientY","trigger","getBounds","getParent","undefined","getPixelValue","value","parseFloat","replace","limit","min","max","isSet","mergeRefs","refs","ref","getResizeObserver","environment","polyfill","ResizeObserver","findScrollContainers","result","document","body","getComputedStyle","overflow","overflowX","overflowY","some","prop","includes","parentElement","createReferenceError","subject","useTrackElements","onChange","ResizeObserverPolyfill","overflowContainer","triggerOption","warning","arrowRef","hasTriggerOption","Boolean","scrollContainers","layer","handleChange","useCallback","closestScrollContainer","Error","scrollOffsets","scrollLeft","scrollTop","scrollX","scrollY","borderOffsets","borderLeftWidth","borderTopWidth","arrow","addEventListeners","ignoredInitialCall","observerCallback","observer","observe","unobserve","disconnect","listenForScrollElements","addEventListener","removeEventListener","resetWhenReferenceChangedWhileTracking","previous","next","layerRef","previousLayer","getScrollContainers","handleScrollContainers","position","closestScrollContainerHasCorrectStyling","style","triggerRef","previousTrigger","triggerOptionParent","GroupContext","createContext","GroupProvider","children","registrations","handleRegister","register","registration","add","delete","createElement","Provider","getShouldCloseAccordingToChildren","event","shouldCloseWhenClickedOutside","useGroup","isOpen","onOutsideClick","onParentClose","Set","possibleRegisterFn","useContext","target","clickedOnTrigger","contains","clickedOnLayer","shouldCloseAccordingToChildren","forEach","closeChild","isChild","shouldNotListen","handleClick","closeOnOutsideClickRefs","PLACEMENT_TYPES","OPPOSITES","center","SideBase","opposite","isHorizontal","sizeProp","oppositeSizeProp","cssProp","oppositeCssProp","isCenter","isPush","factor","isOppositeDirection","side","createSide","recursive","BoundSide","Side","SIDES","BoundsOffsets","offsets","Object","assign","mergeSmallestSides","boundsOffsets","first","rest","fromEntries","map","boundsOffset","Math","every","filter","sumOfPropertyValues","propertyValues","reduce","sum","propertyValue","boundsToObject","EMPTY","Bounds","create","bounds","fromElement","options","withTransform","withScrollbars","plain","getBoundingClientRect","boxSizing","borderLeft","borderRight","borderTop","borderBottom","paddingLeft","paddingRight","paddingTop","paddingBottom","boxWidth","boxHeight","scrollbarWidth","clientWidth","scrollbarHeight","clientHeight","substract","empty","fromWindow","scrollingElement","documentElement","toObject","merge","partialBoundsOrMergeFn","entries","boundSide","offsetsTo","child","mapSides","mapper","boundSides","values","Placement","primary","secondary","subjectBounds","layerDimensions","subjectsBounds","_cachedLayerBounds","_cachedContainerOffsets","setSubjectsBounds","dimensions","getLayerBounds","secondaryOffset","arrowOffsetBase","limitMin","limitMax","propertyA","propertyB","sec","triggerValue","arrowCompensation","layerBounds","getLayerCollisionBounds","container","getContainerOffsets","layerOffsetsToScrollContainers","triggerHasBiggerWidth","triggerHasBiggerHeight","allSidesArePositive","containerOffsets","negativeSides","surface","sort","a","b","mostNegativeSide","PlacementCenter","getNegativeOffsetBetweenLayerCenterAndTrigger","placement","arrowOffset","sizeProperty","sideA","sideB","offsetA","offsetB","STYLE_BASE","willChange","getArrowStyle","triggerIsBigger","negativeOffset","primarySide","secondarySide","secondaryValue","Placements","placements","config","getSidesFromPlacementType","type","split","containerOffset","triggerOffset","getListOfPlacements","preferedPlacement","preferredSide","preferY","preferX","placementFrom","list","possiblePlacements","filterPlacementsBySide","findFirstPlacementThatFits","find","fitsContainer","placementWithBiggestVisibleSurface","visibleSurface","placementWithBiggestSurface","findSuitablePlacement","auto","getSecondaryOffset","snap","placementsOnSameSide","currentPlacementHasHighestPriority","indexOf","firstPlacementThatDoesNotFit","secondaryOffsetSide","getStyles","layerStyleBase","parent","getHasDisappeared","offsetsToScrollContainers","hasFullyDisappeared","suitablePlacement","styles","layerSide","hasDisappeared","SubjectsBounds","getTriggerBounds","allContainers","scrollContainer","GLOBAL_CONTAINER","setGlobalContainer","HTMLElement","getElementById","DEFAULT_OPTIONS","useLayer","onDisappear","setState","triggerBoundsRef","repositioningToken","cancelled","handlePositioning","newState","didStateChange","token","Promise","resolve","then","props","triggerProps","layerProps","arrowProps","triggerBounds","renderLayer","createPortal","getContainerElement","styleProps","DEFAULT_CONTAINER_ID","id","cssText","appendChild","LEFT","TOP","BOTTOM","RIGHT","getWidthBasedOnAngle","angle","size","tan","PI","getViewBox","sizeA","sizeB","borderWidth","getTrianglePath","roundness","relativeRoundness","A","join","B","cPoint","c1A","c1B","C","d1A","d1B","D","getBorderMaskPath","borderOffset","Arrow","forwardRef","borderColor","backgroundColor","maxSize","transform","preserveAspectRatio","viewBox","fill","strokeWidth","stroke","d","Status","useHover","delayEnter","delayLeave","hideOnScroll","show","setShow","timeout","status","IDLE","hasTouchMoved","removeTimeout","clearTimeout","onMouseEnter","LEAVING","ENTERING","setTimeout","onMouseLeave","_","immediate","onScroll","hoverProps","onTouchStart","onTouchMove","onTouchEnd","Transition","isOpenExternal","isOpenInternal","isLeaving","didMount","s"],"mappings":"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"}